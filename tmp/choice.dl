// calculate tree size (fast)

//  utility relations to simulate recursive aggregation

// child ordering
.decl next(parent : symbol, a : symbol, b : symbol) choice-domain (parent, a), (parent, b)

next(parent, "nil", "head") :-
  st(_, parent, _).

next(parent, p, n) :-
  st(_, parent, n),
  next(parent, _, p).

.decl last(parent : symbol, a : symbol)

last(parent, n) :-
  st(_, parent, n),
  ! next(parent, n, _).

.output next, last

//  recursive aggregation using a specific visit order (like a for loop)

.decl tree_size_fast(n : symbol, size : number)

.decl size_accumulator(n : symbol, v : number) // loop variable
.output size_accumulator, tree_size_fast

size_accumulator(n, s) :-
  next(_, "head", n),
  tree_size_fast(n, s).

size_accumulator(n, prev_size + s) :-
  size_accumulator(prev, prev_size),
  next(_, prev, n),
  tree_size_fast(n, s).

// inductive case: parent size = 1 + children size
tree_size_fast(parent, 1 + s) :-
  size_accumulator(n, s),
  last(parent, n).

// base case: leaf size = 1
tree_size_fast(n, 1) :-
  tree_edge(_, n),
  ! tree_edge(n, _).
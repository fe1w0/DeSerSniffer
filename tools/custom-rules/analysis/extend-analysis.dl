/**
 * 对于 反序列化 漏洞检测来说, 需要考虑到子类的函数调用。
 * 但原 doop 中的 污点分析中，常规选择下无法实现对应的功能。
 * Idea:
 * 通过构建 ContextRequest 和 PointsTo 关系，避免分析缺失的情况。
*/

/**
 * 分析从 source 的 CallGraph
*/
.decl fromSourceCallGraph(fromMethod: Method, toMethod: Method, label: Lable)

/**
 * 检测函数是否在从Source开始的CallGraph中
*/
.decl isMethodInSourceCallGraph(method: Method)

/**
 * method 被认为 无法在 fromSourceCallGraph中传递，只能作为 End 结点。
*/
.decl EndMethodInTransfer(method: Method)

// EndMethodInTransfer(method) :-
//     match("<java[.].*", method),
//     isMethod(method).

EndMethodInTransfer("<java.lang.Class: java.lang.Class forName(java.lang.String)>").
EndMethodInTransfer("<java.lang.Throwable: void printStackTrace()>").
EndMethodInTransfer("<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>").
EndMethodInTransfer("<java.lang.Class: java.lang.Object newInstance()>").
EndMethodInTransfer("<java.io.ObjectInputStream: void defaultReadObject()>").


// Todo: 优化，循环卡住

.decl TaintedInvocation(invocation: symbol)

TaintedInvocation(invocation) :-
    TaintedVarPointsTo(_, _, base),
    MethodInvocation_Base(invocation, base).

TaintedInvocation(invocation) :-
    TaintedVarPointsTo(_, _, var),
    ActualParam(_, invocation, var).

TaintedInvocation(invocation) :-
    MethodInvocation_Method(invocation, "<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>"),
    TaintedVarPointsTo(_, _, base_var),
    ActualParam(_, invocation, var),
    StoreArrayIndex(base_var, var, _).

.output TaintedInvocation

fromSourceCallGraph("<Start Method>", sourceMethod, label) :-
    // sourceMethod
    TaintSourceMethod(label, sourceMethod),
    mainAnalysis.Reachable(sourceMethod).

// 开始递归
fromSourceCallGraph(fromMethod, toMethod, label) :-
    mainAnalysis.AnyCallGraphEdge(invocation, toMethod),
    TaintedInvocation(invocation),
    fromSourceCallGraph(_, fromMethod, label),
    fromMethod != toMethod,
    // 修改为 Response
    Instruction_Method(invocation, fromMethod),
    !EndMethodInTransfer(fromMethod).

isMethodInSourceCallGraph(toMethod) :-
    fromSourceCallGraph(_, toMethod, _).

/**
 * Doop 中 isStaticMethodInvocation_Insn 等 rules 需要 为 非 ApplicationMethod 才补充。 
 * 注意: 以下三条rules，绝对不可以忽略掉
*/
.decl Extend_Obtain_Invocation(instruction: symbol)

// Todo: 优化
Extend_Obtain_Invocation(instruction),
isStaticMethodInvocation_Insn(instruction) :-
    isMethodInSourceCallGraph(method),
    _StaticMethodInvocation(instruction, _, _, method).

Extend_Obtain_Invocation(instruction),
isSpecialMethodInvocation_Insn(instruction),
SpecialMethodInvocation_Base(instruction, base) :-
    isMethodInSourceCallGraph(method),
    _SpecialMethodInvocation(instruction, _, _, base, method).

Extend_Obtain_Invocation(instruction),
isVirtualMethodInvocation_Insn(instruction),
VirtualMethodInvocation_Base(instruction, base) :-
    isMethodInSourceCallGraph(method),
    _VirtualMethodInvocation(instruction, _, _, base, method).

.output Extend_Obtain_Invocation
/**
 * 在 app-only 下，存在 VarPointsTo 缺失的情况
 * 只有符合CheckThisTaint条件的base，才重新考虑新的 VarPoinstTo
*/

.decl Extend_VarPointsTo(valueType: symbol, invocation: symbol, base: symbol)

// Todo: 必须优化
/**
 * 添加 VarPointsTo 信息，采用 non-recursive 的方式来分析
*/
Extend_VarPointsTo(valueType, invocation, base),
mainAnalysis.Value_isMock(value), isValue(value), mainAnalysis.Value_Type(value, valueType), mainAnalysis.Value_DeclaringType(value, valueType),
MockObject(value, valueType),
mainAnalysis.VarPointsTo(hctx, value, callerCtx, base) :-
    TaintedInvocation(invocation),
    // Copy 之前的 上下文 信息
    mainAnalysis.VarPointsTo(hctx, _, callerCtx, base),
    // 依赖于 basic.ResolveInvocation 中是否有解
    // 如果 没有 该 valueType信息，说明存在问题
    basic.ResolveInvocation(valueType, invocation, _),
    mainAnalysis.OptVirtualMethodInvocationBase(invocation, base),
    value = cat(valueType, "::MockObject").

.output Extend_VarPointsTo

.limitsize Extend_VarPointsTo(n=200)

/**
 * LeakingTaintedInformation: 用于判断是否存在漏洞，即SinkMethod被污点传播的判断规则
 * 根据doop源代码分析，实际由 LeakingSinkVariable。
 * 原逻辑中分析了：
 * 1. sink 无参数，污点源为 base
 * 2. sink 有参数，且与 source 存在关系
 * 但还需要考虑，
 * 1. sink 有参数，污点源为 base
*/

LeakingSinkVariable(label, invocation, ctx, var) :-
    LeakingSinkMethod(label, tomethod),
    MethodInvocationInContextInApplication(ctx, invocation, tomethod),
    MethodInvocation_Base(invocation, var).

.decl ReachableSinks(invocation:MethodInvocation)

// ReachableTaintedSinks Sinks 中哪些变量是可被污染的
.decl ReachableTaintedSinks(invocation:MethodInvocation, param:Var)
.decl SinkVariable(param:Var)

ReachableSinks(invocation) :-
    LeakingTaintedInformation(_, _, _, invocation, _).

ReachableTaintedSinks(invocation, actual) :-
    ReachableSinks(invocation),
    ActualParam(_, invocation, actual), // FIXME set index in sink
    mainAnalysis.VarPointsTo(_, value, _, actual),
    MockObject(value, _).

ReachableTaintedSinks(invocation, actual) :-
    ReachableSinks(invocation),
    // actual 为 base
    actual = varBase,
    MethodInvocation_Base(invocation, varBase),
    mainAnalysis.VarPointsTo(_, _, _, varBase).

SinkVariable(v) :-
   ReachableTaintedSinks(_, v).
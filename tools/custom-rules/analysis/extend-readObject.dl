/**
 * $stack20 = virtualinvoke l5#_51.<java.io.ObjectInputStream: java.lang.Object readObject()>();
 * l6#_53 = (sources.serialize.UnsafeSerialize) $stack20;
 * 
 * 1. 完善 readObject 关系
 * <sources.serialize.UnsafeSerialize: java.lang.Object readObject()>
 * 注意: 该关系无法 通过函数泛化实现
*/


.decl TaintTranferToObjectField(hctx:mainAnalysis.configuration.HContext, value:Value, ctx:mainAnalysis.configuration.Context, var:Var)

TaintSourceMethod(label, method),
LabelFromSource(invo,  label),
// 强制产生 上下文
mainAnalysis.ForcedReachable(method),
TaintTranferToObjectField(hctx, cat(cat(invo, "::: ")), ctx, this),
mainAnalysis.Value_isMock( cat(cat(cat(cat(invo, "::: "),  type), "::: "),  "ASSIGN")), 
isValue( cat(cat(cat(cat(invo, "::: "),  type), "::: "),  "ASSIGN")), 
TaintedValue( cat(cat(cat(cat(invo, "::: "),  type), "::: "),  "ASSIGN")), 
SourceFromTaintedValue( cat(cat(cat(cat(invo, "::: "),  type), "::: "),  "ASSIGN"), invo), 
mainAnalysis.Value_Type( cat(cat(cat(cat(invo, "::: "),  type), "::: "),  "ASSIGN"), type), 
mainAnalysis.Value_DeclaringType( cat(cat(cat(cat(invo, "::: "),  type), "::: "),  "ASSIGN"), declaringType),
mainAnalysis.VarPointsTo(hctx, cat(cat(cat(cat(invo, "::: "),  type), "::: "),  "ASSIGN"), ctx, to) :-
    TaintSourceMethod(INFO_FLOW_LABEL, method),
    label = MINING_LABEL,
    // 对于 readObject 来说 需要将 第一个
    FormalParam(0, method, to),
    ThisVar(method, this),
    // type
    type = declaringType,
    // create invo
    Method_DeclaringType(method, declaringType),
    invo = cat(method, "::MockObject"),
    // mainAnalysis.isImmutableHContext(hctx),
    hctx = "<<immutable-hcontext>>",
    ctx = "<<immutable-context>>".


// readObject 中 所有的 field 理应当被污染
TaintedValue(new_value), 
mainAnalysis.VarPointsTo(hctx, new_value, ctx, to) :-
    TaintTranferToObjectField(hctx, value, ctx, this),
    // 这个 this 是抽象的,非method中具体的 this 变量
    ThisVar(inmethod, this),
    AssignLocal(this, actualThis, inmethod),
    LoadInstanceField(actualThis, _sign, to, inmethod),
    Var_Type(to, type),
    new_value = cat(cat(value, type), "::: ASSIGN"),
    // InValidReturnType taken from method-summary.dl
    !InValidReturnType(type).

mainAnalysis.VarPointsTo(hctx, new_value, ctx, actualThis) :-
    TaintTranferToObjectField(hctx, value, ctx, this),
    // 这个 this 是抽象的,非method中具体的 this 变量
    ThisVar(inmethod, this),
    new_value = cat(cat(value, type), "::: ASSIGN"),
    Method_DeclaringType(inmethod, type),
    AssignLocal(this, actualThis, inmethod).


/**
 * 需要考虑漏洞挖掘情况下，当前 application 中不存在调用，但也需要查找潜在的利用链:
 * 算法如下:
 * 1. 获得 readObject 函数，当发现无实际的 invocation 时，
 *      1. 设置新的 Label， Label=MINING
 *      2. 构建污点源和指针信息
 *      3. 构建新的 fromSourceMethod
 * 2. 获得 reaObject 函数，且存在实际的 invocation 时，由默认的漏洞分析模块(extend-analysis)处理。
 * 此外，还需要分析 chains 是由 application 中代码导致的，还是 libraries 中的代码导致的。
 * 当前的分析，为了效率，设置了 Analysis 从 Application 中的 `readObject` 函数开始分析。
 * 当上述分析，遇到断开情况时，即 base 的 不在 application 中时，会导致 三类 Invocation_Instruction 缺失（被屏蔽），
 * 且 VarPointsTo 信息缺失。这两个问题已在 extend-analysis 中得到修复。
 * 所以，还需要 对于 readObject 无实际调用的 source 函数，也需要完善指针分析和污点分析。
*/

.output TaintTranferToObjectField

// .decl ExtendReadObjectMiddle_ContextRequest(ctx:mainAnalysis.configuration.Context, hctx:mainAnalysis.configuration.HContext, invo:MethodInvocation, value:Value, method:Method, createCGE:number)

// .decl ExtendReadObjectMiddle_ContextRequest_Method(method: Method)
// 强制产生 上下文
// mainAnalysis.ForcedReachable(newMethod),
// mainAnalysis.Value_isMock(newValue),
// MockObject(newValue, type),
// TaintTranferToObjectField(hctx, cat(cat(cat(cat(invocation, "::: "), type), "::: "), "ASSIGN"), ctx, this),
// MethodInvocationInContext(ctx, invocation, newMethod),
// TypeForReturnValue(type, to, invocation),
// ExtendReadObjectMiddle_ContextRequest_Method(newMethod),
// ExtendReadObjectMiddle_ContextRequest(ctx, hctx, invocation, newValue, newMethod, 1) :-
//     // type = sources.serialize.UnsafeSerialize
//     AssignCast(type, _, to, inmethod),
//     ThisVar(newMethod, this),
//     // 不能直接用 VirtualMethodInvocation
//     Instruction_Method(invocation, inmethod),
//     MethodInvocation_Method(invocation, "<java.io.ObjectInputStream: java.lang.Object readObject()>"),
//     // newMethod 为 该type下, <sources.serialize.UnsafeSerialize: void readObject(java.io.ObjectInputStream)>
//     newMethod = cat("<", cat(type, ": void readObject(java.io.ObjectInputStream)>")),
//     TaintSourceMethod(_label, newMethod),
//     newValue = cat(type, "::MockObject"),
//     hctx = "<<immutable-hcontext>>",
//     ctx = "<<immutable-context>>".

// mainAnalysis.configuration.ContextRequest(ctx, hctx, invocation, value, method, 1) :-
//     ExtendReadObjectMiddle_ContextRequest(ctx, hctx, invocation, value, method, 1).
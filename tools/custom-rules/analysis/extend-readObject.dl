/**
 * $stack20 = virtualinvoke l5#_51.<java.io.ObjectInputStream: java.lang.Object readObject()>();
 * l6#_53 = (sources.serialize.UnsafeSerialize) $stack20;
 * 
 * 1. 完善 readObject 关系
 * <sources.serialize.UnsafeSerialize: java.lang.Object readObject()>
 * 注意: 该关系无法 通过函数泛化实现
*/

/**
 * 需要考虑漏洞挖掘情况下，当前 application 中不存在调用，但也需要查找潜在的利用链:
 * 算法如下:
 * 1. 获得 readObject 函数，当发现无实际的 invocation 时，
 *      1. 设置新的 Label， Label=MINING
 *      2. 构建污点源和指针信息
 *      3. 构建新的 fromSourceMethod
 * 2. 获得 reaObject 函数，且存在实际的 invocation 时，由默认的漏洞分析模块(extend-analysis)处理。
 * 此外，还需要分析 chains 是由 application 中代码导致的，还是 libraries 中的代码导致的。
 * 当前的分析，为了效率，设置了 Analysis 从 Application 中的 `readObject` 函数开始分析。
 * 当上述分析，遇到断开情况时，即 base 的 不在 application 中时，会导致 三类 Invocation_Instruction 缺失（被屏蔽），
 * 且 VarPointsTo 信息缺失。这两个问题已在 extend-analysis 中得到修复。
 * 所以，还需要 对于 readObject 无实际调用的 source 函数，也需要完善指针分析和污点分析。
*/

/**
 * 需要添加以下信息，以便于 informant analysis 和 VarPointsTo: 
 * 1. readObject 中的参数需要被设置为 污点源，同时需要设置 Mock
 * 2. readObject 中的 this 需要被设置为 污点源
 * 3. Declaring Type 中的 fields 需要 被设置为污点源, 同时需要设置 Mock
 * 4. 其他污染到的 Tainted_Var, 如果不存在 Assign 的情况，需要考虑模拟 Assign 的功能，以使污点进行传播
*/

/**
 * 将 readObject 中的参数(FormalParam)设置为 污点源，同时需要设置 Mock
*/

.decl RootSource(source_method: Method, source: symbol)
.output RootSource

RootSource(method, invocation),
Var_DeclaringMethod(invocation, method),
MICRO_CUSTOM_TAINT_ENTRY(method, value, MINING_LABEL, value, formal_param),
MICRO_MOCK_VALUE_MICRO_ALL(value, type, declaringType, hctx, ctx, formal_param) :-
    TaintSourceMethod(INFO_FLOW_LABEL, method),
    Method_DeclaringType(method, declaringType),
    
    FormalParam(_index, method, formal_param),
    Var_Type(formal_param, type),
    invocation = cat(cat(method, "/TaintedMock "), type),
    
    value = invocation,

    mainAnalysis.isImmutableHContext(hctx),
    mainAnalysis.isImmutableContext(ctx).

/**
 * 将 readObject 中的 this 设置为 污点源
*/
MICRO_CUSTOM_TAINT(source, MINING_LABEL, value, method) :-
    TaintSourceMethod(MINING_LABEL, method),
    ThisVar(method, this),
    RootSource(method, source),
    Method_DeclaringType(method, declaringType),
    mainAnalysis.VarPointsTo(_hctx, value, _ctx, actual_this),
    AssignLocal(this, actual_this, method).

/**
 * 将 Declaring Type 中的 fields 设置为污点源, 同时需要设置 Mock
 * Log: 1.3 中进行修复，应当是 Load 过程中
*/
MICRO_CUSTOM_TAINT(source, MINING_LABEL, value, method) :-
    TaintSourceMethod(MINING_LABEL, method),
    Method_DeclaringType(method, declaringType),
    RootSource(method, source),

    Field_DeclaringType(sign, declaringType),
    LoadInstanceField(base, sign, to_field, method),
    mainAnalysis.VarPointsTo(_, value, _, to_field),
    !Field_Modifier("transient", sign),
    Var_Type(to_field, field_type),
    // InValidReturnType taken from method-summary.dl
    !InValidReturnType(field_type).

.output SourceFromTaintedValue


/**
 * MaybeTaintedField 为当前Reachable中， this 可被污染，但其 field 因为 <init> 缺少，导致无法传播断开
*/
.decl MaybeTaintedField(varibale: symbol, base_value: symbol, ctx: symbol)

.decl Fields_Dont_Store_inSameMethod(to_field: symbol, base_this: symbol) inline

Fields_Dont_Store_inSameMethod(to_field, base_this) :-
    !Field_Modifier("transient", signature),
    !_StoreInstanceField(_, _, _, _, signature, in_method),
    _LoadInstanceField(_, _, to_field, base_this, signature, in_method).

MaybeTaintedField(to_field, base_value, ctx) :-
    SerializableValue(base_value),
    TaintedVarPointsTo(base_value, ctx, base_this),
    // 若终止序列化，不进行设置
    Fields_Dont_Store_inSameMethod(to_field, base_this).

VarIsTaintedFromValue(type, base_value, ctx, to_field) :-
    MaybeTaintedField(to_field, base_value, ctx),
    Var_Type(to_field, type).

.output MaybeTaintedField

// 确实，可以有效的构建
.limitsize MaybeTaintedField(n=MAX_Number_MaybeTaintedField)
.printsize MaybeTaintedField
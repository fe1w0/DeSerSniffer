/**
 * 对于 反序列化 漏洞检测来说, 需要考虑到子类的函数调用。
 * 但原 doop 中的 污点分析中，常规选择下无法实现对应的功能。
 * Idea:
 * 通过构建 ContextRequest 和 PointsTo 关系，避免分析缺失的情况。
*/

/**
 * PotentialType 主要为 函数泛化 提供支持。
 * 认为可泛化点存在两个条件:
 * 1. 被反序列化控制，即从 readObject 开始
 * 2. 
*/
.decl PotentialType(type: symbol)

.decl PotentialOnlyType(type: symbol)

.decl AbortClass(type: symbol)

.decl AbortClassJavaLang(type: symbol)

AbortClassJavaLang(type) :-
  (type = "java.lang.Void"
  ;type = "java.lang.Boolean"
  ;type = "java.lang.Byte"
  ;type = "java.lang.Character"
  ;type = "java.lang.Double"
  ;type = "java.lang.Float"
  ;type = "java.lang.Integer"
  ;type = "java.lang.Long"
  ;type = "java.lang.Short"
  ;type = "java.lang.String").

AbortClass(type) :-
    match("sun[.].*|java[.]io.*|java[.]lang[.]reflect.*|java[.]security.*|java[.]util[.]stream.*|java[.]net.*|javax[.].*|jdk[.]internal.*|java[.]nio[.].*", type),
    _ClassType(type).

AbortClass(type) :-
    AbortClassJavaLang(type).

AbortClass(type) :-
    Type_object(type).

AbortClass(type) :-
    Type_null(type).

AbortClass(type) :-
    isPrimitiveType(type).

// Todo: 优化
// 从 反序列化的所有可行field 中，得到 潜在泛化能力的 Value
PotentialType(potential_type) :-
    DefineSourceMethod(method),
    // 函数 存在于 哪些 class 中
    Method_DeclaringType(method, class),
    // field 存在于 哪些 class 中
    // Field_DeclaringType 为 显式声明
    // 但存在 field 继承的问题
    Field_DeclaringType(field_signature, class),
    // field 属于 什么类型
    Field_Type(field_signature, field_type),
    // potential_type 是 field_type 的子类
    basic.SubtypeOf(potential_type, field_type),
    _ClassType(potential_type),
    !AbortClass(field_type),
    !AbortClass(potential_type).

// 从 已探索的 Value中，将其对应的 field 再次设置为 PotentialType
PotentialType(potential_type) :-
    PotentialType(original_value_type),
    Field_DeclaringType(next_field_signature, original_value_type),
    Field_Type(next_field_signature, next_field_type),
    basic.SubtypeOf(potential_type, next_field_type),
    _ClassType(potential_type),
    !AbortClass(potential_type).

PotentialOnlyType(type) :-
    PotentialType(type).

PotentialOnlyType("java.lang.Object").
PotentialOnlyType("java.lang.Class").

.output AbortClass
.output PotentialOnlyType
.output basic.SubtypeOf
.output PotentialType


/**
 * 在 app-only 模式中，以下数据必须要得到分析，
*/
.decl Extend_Obtain_Invocation(instruction: symbol)



Extend_Obtain_Invocation(instruction),
isStaticMethodInvocation_Insn(instruction) :-
    PotentialOnlyType(type),
    Method_DeclaringType(inmethod, type),
    _StaticMethodInvocation(instruction, _, _, inmethod).

Extend_Obtain_Invocation(instruction),
isSpecialMethodInvocation_Insn(instruction),
SpecialMethodInvocation_Base(instruction, base) :-
    PotentialOnlyType(type),
    Method_DeclaringType(signature, type),
    _SpecialMethodInvocation(instruction, _, signature, base, _).

Extend_Obtain_Invocation(instruction),
isVirtualMethodInvocation_Insn(instruction),
VirtualMethodInvocation_Base(instruction, base) :-
    PotentialOnlyType(type),
    Method_DeclaringType(signature, type),
    _VirtualMethodInvocation(instruction, _, signature, base, _).

.output Extend_Obtain_Invocation

/**
 * 添加 VarPointsTo 信息，采用 non-recursive 的方式来分析,
 * 以下 rules 实现 泛化函数功能。
 * 需要注意，有些 type 是 java.lang.Object, 利用 ResolveInvocation 降低空间。
*/
.decl Extend_VarPointsTo(valueType: symbol, invocation: symbol, base: symbol)

/**
 * Todo: 优化 
*/
Extend_VarPointsTo(valueType, invocation, base),
mainAnalysis.Value_isMock(value), isValue(value), mainAnalysis.Value_Type(value, valueType), mainAnalysis.Value_DeclaringType(value, valueType),
MockObject(value, valueType),
mainAnalysis.VarPointsTo(hctx, value, ctx, base) :-
    VirtualMethodInvocation_SimpleName(invocation, simplename),
    VirtualMethodInvocation_Descriptor(invocation, descriptor),
    basic.MethodLookup(simplename, descriptor, valueType, to_method),
    PotentialOnlyType(valueType),
    mainAnalysis.isImmutableContext(ctx),
    mainAnalysis.isImmutableHContext(hctx),
    _VirtualMethodInvocation(invocation, _, to_method, base, _),
    // 构造新的value
    value = cat(valueType, "::MockObject").

.output Extend_VarPointsTo
.output basic.ResolveInvocation


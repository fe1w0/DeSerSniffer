#define Enable_Other_Method

/**
 * 对于 反序列化 漏洞检测来说, 需要考虑到子类的函数调用。
 * 但原 doop 中的 污点分析中，常规选择下无法实现对应的功能。
 * Idea:
 * 通过构建 ContextRequest 和 PointsTo 关系，避免分析缺失的情况。
*/

/**
 * PotentialType 主要为 函数泛化 提供支持。
 * 认为可泛化点存在两个条件:
 * 1. 被反序列化控制，即从 readObject 开始
 * 2. PotentialType 为所有的的子类（含自身）
 * 从 1、 2 中可以推断出，若存在泛化导致的污点分析，最直接的原因是因为反序列化导致的类型泛化，也即是 field 上的泛化问题
 *（还有一种可能，控制流的不同，导致的泛化，但不是本研究的重点
*/
.decl PotentialType(type: symbol)

/**
 * PotentialEnd_Type 表示 在属性树中的 部分 End Node
*/
.decl PotentialEnd_Type(type: symbol)

.decl PotenticalField(field: symbol)

.decl PotentialOnlyType(type: symbol)

.decl PotentialAllType(type: symbol)

.decl AbortClass(type: symbol)

.decl AllCollectionClass(class: symbol)

AllCollectionClass(class) :-
  isClassType(class),
  !DenyEntryClass(class),
  basic.SubtypeOf(class, superclass),
  (superclass = "java.util.Map";
   superclass = "java.util.Collection";
   superclass = "java.util.Iterable";
   superclass = "java.util.Iterator";
   superclass = "java.util.Comparator";
   superclass = "java.util.Dictionary";
   superclass = "java.util.Arrays";
   superclass = "java.util.Objects";
   superclass = "java.util.Collections").

.decl DataStructureInnerClass(class: Type)

DataStructureInnerClass(inner_class) :-
    AllCollectionClass(class),
    isClassType(inner_class),
    match(cat(class, "[$].*"), inner_class).

AbortClass(type) :-
    DenyEntryClass(type).

AbortClass(type) :-
    AbortClassJavaLang(type).

AbortClass(type) :-
    Type_object(type).

AbortClass(type) :-
    Type_null(type).

AbortClass(type) :-
    isPrimitiveType(type).

AbortClass(type) :-
    AllCollectionClass(type).


// Todo: 提取能力，过于弱小

// 从 反序列化的所有可行field 中，得到 潜在泛化能力的 Value
PotenticalField(field_signature),
PotentialType(potential_type) :-
    DefineSourceMethod(method),
    // 函数 存在于 哪些 class 中
    Method_DeclaringType(method, class),
    // field 存在于 哪些 class 中
    // Field_DeclaringType 为 显式声明
    // 但存在 field 继承的问题
    Field_DeclaringType(field_signature, class),
    // field 属于 什么类型
    Field_Type(field_signature, field_type),
    // potential_type 是 field_type 的子类
    basic.SubtypeOf(potential_type, field_type),
    !AbortClass(field_type),
    !AbortClass(potential_type).

// // 从 已探索的 Value中，将其对应的 field 再次设置为 PotentialType
PotenticalField(next_field_signature),
PotentialType(potential_type) :-
    PotentialType(original_value_type),
    Field_DeclaringType(next_field_signature, original_value_type),
    Field_Type(next_field_signature, next_field_type),
    basic.SubtypeOf(potential_type, next_field_type),
    !AbortClass(next_field_type),
    !AbortClass(potential_type).

PotentialEnd_Type(next_field_type) :-
    PotentialType(original_value_type),
    Field_DeclaringType(next_field_signature, original_value_type),
    Field_Type(next_field_signature, next_field_type),
    (
        AllCollectionClass(next_field_type);
        Type_object(next_field_type)
    ).

PotentialEnd_Type(class) :-
    DefineSourceMethod(method),
    // 函数 存在于 哪些 class 中
    Method_DeclaringType(method, class).

PotentialEnd_Type(field_type) :-
    DefineSourceMethod(method),
    // 函数 存在于 哪些 class 中
    Method_DeclaringType(method, class),
    // field 存在于 哪些 class 中
    // Field_DeclaringType 为 显式声明
    // 但存在 field 继承的问题
    Field_DeclaringType(field_signature, class),
    // field 属于 什么类型
    Field_Type(field_signature, field_type),
    // potential_type 是 field_type 的子类
    (
        AllCollectionClass(field_type);
        Type_object(field_type)
    ).

PotentialOnlyType(type) :-
    PotentialType(type).

PotentialOnlyType(type) :-
    PotentialEnd_Type(type).

PotentialAllType(type) :-
    PotentialOnlyType(type).

PotentialAllType(type) :-
    (AllCollectionClass(type);
    Type_object(type)).

.output AbortClass
.output DataStructureInnerClass
.output PotentialOnlyType
.output basic.SubtypeOf
.output AllCollectionClass
.output Field_DeclaringType
.output PotentialType
.output PotenticalField
.output PotentialEnd_Type
.output PotentialAllType

/**
 * 以下内容是来解决 ApplicationClass 问题。
 * 具体的优化问题如下: 
 * - 在doop框架中， `--app-only` 选项下， 不会认为 rt.jar 这类底层组件是 application
 * - 但对于 反序列化来说，最常用和最可能的利用链中，就可以存在于 rt.jar 中，如 java.util.hashMap, java.util.hashSet
 * 如果直接不采用 `--app-only`，主要是分析的空间会爆炸，时间成本也高。
*/

/**
 * 目前的版本，是手动的将一些需要考虑的 Method 添加进去 到 Accept_Extend_Obtain_Method 中。
 * Todo: 从一个压缩且完备的Domain空间中，对其中所有的invocation进行分析。
 * 对应的压缩且完备的Domain空间，预计定义为: 从 source_method，到其中 invocation 的 所有子类 signature
 * 这也是为什么 不能直接用 PotentialType 构建压缩空间的原因。
 * 且需要注意，一定不能构建 CallGraph, recursive-exection 一定不能存在。
 * 且为了避免分析中的爆炸问题，需要构建一个 whole-may-call-graph ，以此自动得到所有的 Accept_Extend_Obtain_Method
 * 否则还是陷入到 recursive-exection 爆炸。
*/
.decl Accept_Extend_Obtain_Method(method: Method)
.decl Deny_Obtain_Method(method: Method)
.decl Accept_Extend_Obtain_Class(class: symbol)
.decl Extend_Obtain_Invocation(instruction: symbol)

/**
 * 最困难的地方，需要提出一个 whole-may-call-graph，从污点源开始。
 * 在readObect中，存在两种不同分析路径和污点源设置，
 * 第一种：readObject在inmethod中，后面在inmethod中分析
 * 第二种: 从 <Class>: readObject 中分析调用
 * 本项目中，选择第二种分析方式，认为最具有普遍分析价值。
*/
.decl WHOLE_MAY_CALL_GRAPH(invocation:Instruction, to_method: Method)

// 反射相关
Accept_Extend_Obtain_Method(method) :-
    (
        method = "<java.lang.Class: java.lang.Class forName(java.lang.String)>";
        method = "<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>";
        method = "<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>";
        method = "<java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])>";
        method = "<java.lang.Class: java.lang.reflect.Constructor getConstructor(java.lang.Class[])>";
        method = "<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>";
        method = "<java.lang.Class: java.lang.Object newInstance()>"
    ),
    isOpaqueMethod(method).
// <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>

// 反序列化相关
Accept_Extend_Obtain_Method(method) :-
    (
        method = "<java.io.ObjectInputStream: java.lang.Object readObject()>";
        method = "<java.io.ObjectInputStream: float readFloat()>";
        method= "<java.io.ObjectInputStream: float readFloat()>"
    ),
    isOpaqueMethod(method).

// 从 PotentialOnlyType 中提取所有的 Method
Accept_Extend_Obtain_Method(method) :-
    PotentialAllType(class),
    Method_DeclaringType(method, class),
    isOpaqueMethod(method).

Accept_Extend_Obtain_Method(method) :-
    LeakingSinkMethod(_label, method),
    isOpaqueMethod(method).

.decl Extend_OpaqueMethod(method: Method)

Extend_OpaqueMethod(method) :-
    class = "java.io.ObjectInputStream",
    Method_DeclaringType(method, class).

.output Extend_OpaqueMethod

/**
 * 采用 Accept_Extend_Obtain_Method 是因为，signature 的空间比 instruction 要小很多。
*/
Extend_Obtain_Invocation(instruction),
isStaticMethodInvocation_Insn(instruction) :-
    Accept_Extend_Obtain_Method(signature),
    !Extend_OpaqueMethod(in_method),
    _StaticMethodInvocation(instruction, _, signature, in_method).



Extend_Obtain_Invocation(instruction),
isSpecialMethodInvocation_Insn(instruction),
SpecialMethodInvocation_Base(instruction, base) :-
    Accept_Extend_Obtain_Method(signature),
    !Extend_OpaqueMethod(in_method),
    _SpecialMethodInvocation(instruction, _, signature, base, in_method).

Extend_Obtain_Invocation(instruction),
isVirtualMethodInvocation_Insn(instruction),
VirtualMethodInvocation_Base(instruction, base) :-
    Accept_Extend_Obtain_Method(signature),
    !Extend_OpaqueMethod(in_method),
    _VirtualMethodInvocation(instruction, _, signature, base, in_method).

.printsize Extend_Obtain_Invocation

.output basic.MethodOverridesOther
.output WHOLE_MAY_CALL_GRAPH
.output Accept_Extend_Obtain_Method
.output Extend_Obtain_Invocation

#define MAX_Scalability_Number 6


/**
 * Determined_Type_Domain 用于控制 Extend_VarPointsTo 的 循环次数，用于快速收敛
 * n 表示第几轮拓展中，进行的类型泛化
*/
.decl Determined_Type_Domain(valueType: symbol, invocation: symbol, n: number)

.decl ReachableContextMethodDomain(in_method: Method, step: number)

ReachableContextMethodDomain(in_method, 0) :-
    mainAnalysis.ReachableContext(_ctx, in_method).

.output ReachableContextMethodDomain

.decl Deny_Class_For_Extend_VarPointsTo(class: Type)

Deny_Class_For_Extend_VarPointsTo(type) :-
    (
        DenyEntryClass(type);
        AbortClassJavaLang(type);
        DataStructureInnerClass(type);
        AbortClassJavaLang(type)
    ).

/**
 * 添加 VarPointsTo 信息，利用 PotentialType 来实现泛化和优化。
*/
.decl Extend_VarPointsTo(valueType: symbol,  invocation: symbol, var: symbol, value: symbol)

// Todo value 值 无法使用

// Extend_VarPointsTo(value_type, invocation, var, new_value) :-
//     TaintedVarPointsTo(value, _ctx, var),
//     ActualParam(_idx, invocation, var),
//     Var_Type(var, var_type),

//     basic.SubtypeOf(value_type, var_type),
//     !Deny_Class_For_Extend_VarPointsTo(var_type),
//     !Deny_Class_For_Extend_VarPointsTo(value_type),
//     ApplicationClass(value_type),

//     Instruction_Method(invocation, in_method),
//     isMethodInSourceCallGraph(in_method),
    

//     MethodInvocation_Method(invocation, to_method),
//     Method_SimpleName(to_method, to_method_simple_name),
//     (
//         to_method_simple_name = "put";
//         to_method_simple_name = "get"
//     ),
    
//     Method_DeclaringType(to_method, to_method_declaring_type),
//     AllCollectionClass(to_method_declaring_type),
//     new_value  = cat(cat(cat(value, "::: "), value_type), "::: Extend").

// Extend_VarPointsTo(value_type, invocation, base, new_value) :-
//     Instruction_Method(invocation, in_method),
//     isMethodInSourceCallGraph(in_method),

//     TaintedVarPointsTo(value, _ctx, base),
//     basic.ResolveInvocation(value_type, invocation, _),
//     VirtualMethodInvocation_Base(invocation, base),

//     ApplicationClass(value_type),
//     new_value  = cat(cat(cat(value, "::: "), value_type), "::: Extend").

// Extend_VarPointsTo(value_type, invocation, var, new_value) :-
//     TaintedVarPointsTo(value, _ctx, var),
//     ActualParam(_idx, invocation, var),
//     Var_Type(var, var_type),

//     basic.SubtypeOf(value_type, var_type),
//     !Deny_Class_For_Extend_VarPointsTo(var_type),
//     !Deny_Class_For_Extend_VarPointsTo(value_type),
//     ApplicationClass(value_type),

//     Instruction_Method(invocation, in_method),
//     isMethodInSourceCallGraph(in_method),

//     ApplicationClass(value_type),
//     new_value  = cat(cat(cat(value, "::: "), value_type), "::: Extend").

TaintedValue(value),
mainAnalysis.VarPointsTo(hctx, value, ctx, var),
mainAnalysis.Value_isMock(value), isValue(value), mainAnalysis.Value_Type(value, value_type), mainAnalysis.Value_DeclaringType(value, value_type),
MockObject(value, value_type) :- 
    mainAnalysis.isImmutableHContext(hctx),
    mainAnalysis.isImmutableContext(ctx),
    Extend_VarPointsTo(value_type, _invocation, var, value).

.output Extend_VarPointsTo
.output TaintedValue
.printsize Extend_VarPointsTo
.limitsize Extend_VarPointsTo(n=1000)
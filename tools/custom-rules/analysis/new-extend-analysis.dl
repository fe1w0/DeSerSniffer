#define Enable_Other_Method

/**
 * 对于 反序列化 漏洞检测来说, 需要考虑到子类的函数调用。
 * 但原 doop 中的 污点分析中，常规选择下无法实现对应的功能。
 * Idea:
 * 通过构建 ContextRequest 和 PointsTo 关系，避免分析缺失的情况。
*/

/**
 * 目前的版本，是手动的将一些需要考虑的 Method 添加进去 到 Accept_Extend_Obtain_Method 中。
 * Todo: 从一个压缩且完备的Domain空间中，对其中所有的invocation进行分析。
 * 对应的压缩且完备的Domain空间，预计定义为: 从 source_method，到其中 invocation 的 所有子类 signature
 * 这也是为什么 不能直接用 PotentialType 构建压缩空间的原因。
 * 且需要注意，一定不能构建 CallGraph, recursive-exection 一定不能存在。
 * 且为了避免分析中的爆炸问题，需要构建一个 whole-may-call-graph ，以此自动得到所有的 Accept_Extend_Obtain_Method
 * 否则还是陷入到 recursive-exection 爆炸。
*/
.decl Accept_Extend_Obtain_Method(method: Method)
.decl Deny_Obtain_Method(method: Method)
.decl Accept_Extend_Obtain_Class(class: symbol)
.decl Extend_Obtain_Invocation(instruction: symbol)

/**
 * 在readObect中，存在两种不同分析路径和污点源设置，
 * 第一种：readObject在inmethod中，后面在inmethod中分析
 * 第二种: 从 <Class>: readObject 中分析调用
 * 本项目中，选择第二种分析方式，认为最具有普遍分析价值。
*/
.decl WHOLE_MAY_CALL_GRAPH(invocation:Instruction, to_method: Method)

// 反射相关
Accept_Extend_Obtain_Method(method) :-
    (
        class = "java.lang.Class"
        ;class = "java.lang.reflect.Constructor"
        ;class = "java.lang.reflect.Method"
        ;class = "java.lang.reflect.Field"
        ;class = "java.lang.reflect.Modifier"
    ),
    isClassType(class),
    Method_DeclaringType(method, class),
    isOpaqueMethod(method).

// 反序列化相关
Accept_Extend_Obtain_Method(method) :-
    (
        method = "<java.io.ObjectInputStream: java.lang.Object readObject()>";
        method = "<java.io.ObjectInputStream: float readFloat()>";
        method= "<java.io.ObjectInputStream: float readFloat()>"
    ),
    isOpaqueMethod(method).

// 从 PotentialOnlyType 中提取所有的 Method
Accept_Extend_Obtain_Method(method) :-
    PotentialAllType(class),
    Method_DeclaringType(method, class),
    isOpaqueMethod(method).

Accept_Extend_Obtain_Method(method) :-
    LeakingSinkMethod(_label, method),
    isOpaqueMethod(method).

.decl Extend_OpaqueMethod(method: Method)

Extend_OpaqueMethod(method) :-
    class = "java.io.ObjectInputStream",
    Method_DeclaringType(method, class).

.output Extend_OpaqueMethod

/**
 * 采用 Accept_Extend_Obtain_Method 是因为，signature 的空间比 instruction 要小很多。
*/
Extend_Obtain_Invocation(instruction),
isStaticMethodInvocation_Insn(instruction) :-
    Accept_Extend_Obtain_Method(signature),
    !Extend_OpaqueMethod(in_method),
    _StaticMethodInvocation(instruction, _, signature, in_method).

Extend_Obtain_Invocation(instruction),
isSpecialMethodInvocation_Insn(instruction),
SpecialMethodInvocation_Base(instruction, base) :-
    Accept_Extend_Obtain_Method(signature),
    !Extend_OpaqueMethod(in_method),
    _SpecialMethodInvocation(instruction, _, signature, base, in_method).

Extend_Obtain_Invocation(instruction),
isVirtualMethodInvocation_Insn(instruction),
VirtualMethodInvocation_Base(instruction, base) :-
    Accept_Extend_Obtain_Method(signature),
    !Extend_OpaqueMethod(in_method),
    _VirtualMethodInvocation(instruction, _, signature, base, in_method).

.output Accept_Extend_Obtain_Method
.output Extend_Obtain_Invocation
.printsize Extend_Obtain_Invocation

/**
 * 拒绝 DenyEntryClass AbortClassJavaLang DataStructureInnerClass
*/
.decl Deny_Class_For_Extend_VarPointsTo(class: Type)

Deny_Class_For_Extend_VarPointsTo(type) :-
    (
        DenyEntryClass(type)
        ;AbortClassJavaLang(type)
        ;DataStructureInnerClass(type)
    ).

/**
 * 添加 VarPointsTo 信息，利用 PotentialType 来实现泛化和优化。
*/
.decl Extend_VarPointsTo(valueType: symbol, source: symbol, base: symbol, to_method: symbol)


.decl Allow_Class_For_Extend_VarPointsTo(type: symbol)


/**
 * ApplicationClass, AllCollectionClass
*/
Allow_Class_For_Extend_VarPointsTo(type) :-
    basic.SupertypeOf("java.io.Serializable", type),
    (
        ApplicationClass(type),
        !ApplicationClassInnerClass(type)
        // ;AllCollectionClass(type)
    ).

/**
 * 泛化对象: Virtual Invocation 中 base
 * 泛化目标: base的可调用子类, 范围在 ApplicationClass
 * 补充说明: 
*/
Extend_VarPointsTo(value_type, source, base, to_method) :-
    Instruction_Method(invocation, in_method),
    isMethodInSourceCallGraph(in_method),
    VirtualMethodInvocation_Base(invocation, base),
    Var_Type(base, base_type),
    !SubCollectionClass(base_type),
    TaintedVarPointsTo(source, _ctx, base),
    basic.ResolveInvocation(value_type, invocation, to_method),
    Allow_Class_For_Extend_VarPointsTo(value_type).

MICRO_MOCK_VALUE_MICRO_PART(source, value_type) :- 
    Extend_VarPointsTo(value_type, source, _, _).

.output Extend_VarPointsTo
.printsize Extend_VarPointsTo

/**
 * 补充 Invoke 函数的 SinkMethod 调用图
*/
mainAnalysis.configuration.ContextRequest(ctx, hctx, invocation, value, method, 1) :-
    mainAnalysis.isImmutableHContext(hctx),
    mainAnalysis.isImmutableContext(ctx),
    mainAnalysis.java_lang_reflect_Method_invoke(invocation, base),
    method = "<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>",
    _AssignReturnValue(value, base).
//functor declarations need to be first
















// Copy of MockValueConsMacro but with proper component qualifers.












// Android-specific macro to qualify unqualified types in layout controls.
// Heuristic: if the name is unqualified, it may come from android.view or
// android.widget ("Android Programming: The Big Nerd Ranch Guide", chapter 32).







.type Modifier = symbol
.decl isModifier(?m:Modifier)

.decl Modifier_abstract(?mod:Modifier)
.decl Modifier_final(?mod:Modifier)
.decl Modifier_public(?mod:Modifier)
.decl Modifier_private(?mod:Modifier)
.decl Modifier_static(?mod:Modifier)

// Java Type Hierarchy
.type Type          = symbol
.type PrimitiveType = Type
.type ReferenceType = Type
.type NullType      = ReferenceType
.type ArrayType     = ReferenceType
.type ClassType     = ReferenceType
.type InterfaceType = ReferenceType

.decl isType(?t:Type)
.decl isPrimitiveType(?t:PrimitiveType)
.decl isReferenceType(?t:ReferenceType)
.decl isNullType(?t:ReferenceType)
.decl isArrayType(?t:ArrayType)
.decl isClassType(?t:ClassType)
.decl isInterfaceType(?t:InterfaceType)

// Inheritance and Subtyping

.decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)
.decl DirectSuperinterface(?ref:ReferenceType, ?interface:InterfaceType)

// Important class subsets

.decl ConcreteClass(?ref:ClassType)
.decl MainClass(?class:ClassType)

// Common type selectors

.decl Type_boolean(?t:PrimitiveType)
.decl Type_byte(?t:PrimitiveType)
.decl Type_char(?t:PrimitiveType)
.decl Type_short(?t:PrimitiveType)
.decl Type_int(?t:PrimitiveType)
.decl Type_long(?t:PrimitiveType)
.decl Type_float(?t:PrimitiveType)
.decl Type_double(?t:PrimitiveType)
.decl Type_void(?t:Type)
.decl Type_null(?t:NullType)
.decl Type_object(?t:ReferenceType)

.decl isIntegerType(?type:Type)

.decl ClassModifier(?mod:Modifier, ?class:ReferenceType)

//-----------------------------------------------------------------------------

.type Field = symbol
.decl isField(?field:Field)

.decl Field_DeclaringType(?field:Field, ?declaringClass:ReferenceType)
.decl Field_SimpleName(?field:Field, ?simpleName:symbol)
.decl Field_Type(?field:Field, ?type:Type)
.decl Field_Modifier(?mod:Modifier, ?field:Field)

//-----------------------------------------------------------------------------

// Represents the return type and the argument types of a method
.type MethodDescriptor = symbol
.decl isMethodDescriptor(?md:MethodDescriptor)

.type Method = symbol
.decl isMethod(?m:Method)

.decl Method_DeclaringType(?method:Method, ?declaringType:ReferenceType)
.decl Method_ReturnType(?method:Method, ?returnType:Type)
.decl Method_SimpleName(?method:Method, ?simpleName:symbol)
.decl Method_ParamTypes(?method:Method, ?params:symbol)
.decl Method_Descriptor(?method:Method, ?descriptor:MethodDescriptor)
.decl Method_Arity(?method:Method, ?arity:number)

.type JVMDescriptor = symbol
.decl isJVMDescriptor(?jvmd:JVMDescriptor)

// JVM method descriptor
.decl Method_JVMDescriptor(?method:Method, ?descriptor:JVMDescriptor)

.decl Method_Modifier(?mod:Modifier, ?method:Method)

// Method ?method declares to throw exception ?exceptionType.
// This predicate corresponds to Java's throws clause, or the
// Exceptions clause in Java bytecode.
.decl Method_DeclaresException(?exceptionType:ReferenceType, ?method:Method)

.decl FormalParam(?index:number, ?method:Method, ?var:Var)

.decl ThisVar(?method:Method, ?var:Var)

//-----------------------------------------------------------------------------

.type Var = symbol
.decl isVar(v:Var)

.decl Var_Type(?var:Var, ?type:Type)
.decl Var_DeclaringMethod(?var:Var, ?method:Method)
.decl Var_SimpleName(?var:Var, ?simplename:symbol)


//-----------------------------------------------------------------------------
// [Value]
//-----------------------------------------------------------------------------

.type Value = symbol

.decl isValue(?value:Value)

//-----------------------------------------------------------------------------
// [Constant numbers]
//-----------------------------------------------------------------------------

.type NumConstant = Value

.decl isNumConstant(?n:NumConstant)

//-----------------------------------------------------------------------------
// [Heap Allocation]
//-----------------------------------------------------------------------------

.type HeapAllocation       = Value
.type NormalHeap           = HeapAllocation
.type StringConstant       = HeapAllocation
.type ClassHeap            = HeapAllocation
.type MethodHandleConstant = HeapAllocation
.type MethodTypeConstant   = HeapAllocation

.decl isHeapAllocation(?h:HeapAllocation)
.decl isNormalHeap(?h:NormalHeap)
.decl isStringConstant(?h:StringConstant)
.decl isClassHeap(?h:ClassHeap)
.decl isMethodHandleConstant(?h:MethodHandleConstant)
.decl isMethodTypeConstant(?h:MethodTypeConstant)
.decl isStringRaw(?id:symbol)

.decl HeapAllocation_Type(?heap:HeapAllocation, ?type:ReferenceType)
.decl OriginalHeapAllocation_Type(?heap:HeapAllocation, ?type:ReferenceType)

// [Miscellaneous]
.decl HeapAllocation_EmptyArray(?heap:HeapAllocation)
.decl HeapAllocation_Null(?null:HeapAllocation)
.decl MainMethodArgArray(?heap:HeapAllocation)
.decl MainMethodArgArrayContent(?heap:HeapAllocation)

.decl ClassHeap_InstanceType(?classHeap:ClassHeap, ?instanceType:ReferenceType)
.decl MethodHandleConstant_Method(?heap:MethodHandleConstant, ?method:Method)
.decl MethodHandleConstant_ReturnType(?heap:MethodHandleConstant, ?retType:Type)
.decl MethodHandleConstant_ParamTypes(?heap:MethodHandleConstant, ?paramTypes:symbol)
.decl MethodHandleConstant_Arity(?heap:MethodHandleConstant, ?arity:number)
.decl MethodTypeConstant_Arity(?heap:MethodTypeConstant, ?arity:number)
.decl MethodTypeConstant_ReturnType(?heap:MethodTypeConstant, ?retType:Type)
.decl MethodTypeConstant_ParamTypes(?heap:MethodTypeConstant, ?paramTypes:symbol)

//-----------------------------------------------------------------------------
// [Bytecode Instructions]
//-----------------------------------------------------------------------------

.type Instruction = symbol
.decl isInstruction(?insn:Instruction)

.decl Instruction_Index(?insn:Instruction, ?index:number)
.decl Instruction_Line(?insn:Instruction, ?index:number)
.decl Instruction_Method(?insn:Instruction, ?inMethod:Method)

.type Throw_Insn                      = Instruction
.type ThrowNull_Insn                  = Throw_Insn
.type Goto_Insn                       = Instruction
.type If_Insn                         = Instruction
.type Switch_Insn                     = Instruction
.type TableSwitch_Insn                = Switch_Insn
.type LookupSwitch_Insn               = Switch_Insn
.type MonitorInstruction              = Instruction
.type EnterMonitor_Insn               = MonitorInstruction
.type ExitMonitor_Insn                = MonitorInstruction
.type FieldInstruction                = Instruction
.type LoadInstanceField_Insn          = FieldInstruction
.type StoreInstanceField_Insn         = FieldInstruction
.type LoadStaticField_Insn            = FieldInstruction
.type StoreStaticField_Insn           = FieldInstruction
.type ArrayInstruction                = Instruction
.type LoadArrayIndex_Insn             = ArrayInstruction
.type StoreArrayIndex_Insn            = ArrayInstruction

.decl isThrow_Insn(?insn:Throw_Insn)
.decl isThrowNull_Insn(?insn:ThrowNull_Insn)
.decl isGoto_Insn(?insn:Goto_Insn)
.decl isIf_Insn(?insn:If_Insn)
.decl isSwitch_Insn(?insn:Switch_Insn)
.decl isTableSwitch_Insn(?insn:TableSwitch_Insn)
.decl isLookupSwitch_Insn(?insn:LookupSwitch_Insn)
.decl isMonitorInstruction(?insn:MonitorInstruction)
.decl isEnterMonitor_Insn(?insn:EnterMonitor_Insn)
.decl isExitMonitor_Insn(?insn:ExitMonitor_Insn)
.decl isFieldInstruction(?insn:FieldInstruction)
.decl isLoadInstanceField_Insn(?insn:LoadInstanceField_Insn)
.decl isStoreInstanceField_Insn(?insn:StoreInstanceField_Insn)
.decl isLoadStaticField_Insn(?insn:LoadStaticField_Insn)
.decl isStoreStaticField_Insn(?insn:StoreStaticField_Insn)
.decl isArrayInstruction(?insn:ArrayInstruction)
.decl isLoadArrayIndex_Insn(?insn:LoadArrayIndex_Insn)
.decl isStoreArrayIndex_Insn(?insn:StoreArrayIndex_Insn)

.type AssignInstruction               = Instruction
.type AssignOper_Insn                 = AssignInstruction
.type AssignBinop_Insn                = AssignOper_Insn
.type AssignUnop_Insn                 = AssignOper_Insn
.type AssignLocal_Insn                = AssignOper_Insn
.type AssignInstanceOf_Insn           = AssignInstruction
.type AssignNull_Insn                 = AssignInstruction
.type AssignNumConstant_Insn          = AssignInstruction
.type AssignCast_Insn                 = AssignInstruction
.type AssignCastNull_Insn             = AssignCast_Insn
.type AssignCastNumConstant_Insn      = AssignCast_Insn
.type AssignHeapAllocation_Insn       = AssignInstruction
.type ReturnInstruction               = Instruction
.type ReturnVoid_Insn                 = ReturnInstruction
.type ReturnNonvoid_Insn              = ReturnInstruction

.decl isAssignInstruction(?insn:AssignInstruction)
.decl isAssignOper_Insn(?insn:AssignOper_Insn)
.decl isAssignBinop_Insn(?insn:AssignBinop_Insn)
.decl isAssignUnop_Insn(?insn:AssignUnop_Insn)
.decl isAssignLocal_Insn(?insn:AssignLocal_Insn)
.decl isAssignInstanceOf_Insn(?insn:AssignInstanceOf_Insn)
.decl isAssignNull_Insn(?insn:AssignNull_Insn)
.decl isAssignNumConstant_Insn(?insn:AssignNumConstant_Insn)
.decl isAssignCast_Insn(?insn:AssignCast_Insn)
.decl isAssignCastNull_Insn(?insn:AssignCastNull_Insn)
.decl isAssignCastNumConstant_Insn(?insn:AssignCastNumConstant_Insn)
.decl isAssignHeapAllocation_Insn(?insn:AssignHeapAllocation_Insn)
.decl isReturnInstruction(?insn:ReturnInstruction)
.decl isReturnVoid_Insn(?insn:ReturnVoid_Insn)
.decl isReturnNonvoid_Insn(?insn:ReturnNonvoid_Insn)

.type MethodInvocation                = Instruction
.type VirtualMethodInvocation_Insn    = MethodInvocation
.type SpecialMethodInvocation_Insn    = MethodInvocation
.type StaticMethodInvocation_Insn     = MethodInvocation
.type SuperMethodInvocation_Insn      = MethodInvocation
.type DynamicMethodInvocation_Insn    = MethodInvocation

.decl isMethodInvocation(?insn:MethodInvocation)
.decl isVirtualMethodInvocation_Insn(?insn:VirtualMethodInvocation_Insn)
.decl isSpecialMethodInvocation_Insn(?insn:SpecialMethodInvocation_Insn)
.decl isStaticMethodInvocation_Insn(?insn:StaticMethodInvocation_Insn)
.decl isSuperMethodInvocation_Insn(?insn:SuperMethodInvocation_Insn)
.decl isDynamicMethodInvocation_Insn(?insn:DynamicMethodInvocation_Insn)

.type UnsupportedInstruction          = Instruction
.type AssignPhantomInvoke             = UnsupportedInstruction
.type BreakpointStmt                  = UnsupportedInstruction

.decl isUnsupportedInstruction(?insn:UnsupportedInstruction)
.decl isAssignPhantomInvoke(?insn:AssignPhantomInvoke)
.decl isBreakpointStmt(?insn:BreakpointStmt)

//-----------------------------------------------------------------------------

.decl DummyIf_Var(?insn:If_Insn, ?Var:Var)
.decl If_Var(?insn:If_Insn, ?pos:number, ?var:Var)
.decl If_Constant(?insn:If_Insn, ?pos: number, ?cons: NumConstant)
.decl Throw_Var(?insn:Throw_Insn, ?var:Var)
.decl Goto_Target(?insn:Goto_Insn, ?index:number)
.decl If_Target(?insn:If_Insn, ?index:number)
.decl Switch_Key(?insn:Switch_Insn, ?key:Var)
.decl Switch_Target(?insn:Switch_Insn, ?value:number, ?index:number)
.decl Switch_DefaultTarget(?insn:Switch_Insn, ?index:number)
.decl EnterMonitor_Var(?insn:EnterMonitor_Insn, ?var:Var)
.decl ExitMonitor_Var(?insn:ExitMonitor_Insn, ?var:Var)


//-----------------------------------------------------------------------------
// [Field Instructions]
//-----------------------------------------------------------------------------

// The associated *field* of this instruction. It applies to
// all types of field instuctions.

.decl FieldInstruction_Signature(?insn:FieldInstruction, ?sign:Field)

//------------------------------------------------
// A LoadInstanceField instruction has the form:
// x = y.f
//
// Its three components are:
//   1. Base (y)
//   2. Field (f)
//   3. To (x)
//------------------------------------------------

.decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)
.decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)

//------------------------------------------------
// A StoreInstanceField instruction has the form:
// x.f = y
//
// Its three components are:
//   1. Base (x)
//   2. Field (f)
//   3. From (y)
//------------------------------------------------

.decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)
.decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)

//------------------------------------------------

//------------------------------------------------
// A LoadStaticField instruction has the form:
// x = Y.f
//
// Its two components are:
//   1. Field (Y.f)
//   2. To (x)
//------------------------------------------------

.decl LoadStaticField_To(?insn:LoadStaticField_Insn, ?var:Var)

//------------------------------------------------
// A StoreStaticField instruction has the form:
// X.f = y
//
// Its two components are:
//   1. Field (X.f)
//   2. From (y)
//------------------------------------------------

.decl StoreStaticField_From(?insn:StoreStaticField_Insn, ?var:Var)


//-----------------------------------------------------------------------------
// [Array Instructions]
//-----------------------------------------------------------------------------

.decl ArrayInsnIndex(?insn:Instruction, ?index:Var)
.decl ArrayNumIndex(?insn:Instruction, ?index:number)

.decl ComponentType(?arrayType:ArrayType, ?componentType:Type)

.decl LoadArrayIndex_Base(?insn:LoadArrayIndex_Insn, ?var:Var)
.decl LoadArrayIndex_To(?insn:LoadArrayIndex_Insn, var:Var)

.decl StoreArrayIndex_From(?insn:StoreArrayIndex_Insn, ?var:Var)
.decl StoreArrayIndex_Base(?insn:StoreArrayIndex_Insn, ?var:Var)

.decl ArrayAllocation(?insn:Instruction, ?pos:number, ?sizeVar:Var)


//-----------------------------------------------------------------------------
// [Assign Instructions]
//-----------------------------------------------------------------------------

// The target of all assignment instructions
.decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)

// Assign numeric constant instruction
.decl AssignNumConstant_Id(?insn:AssignNumConstant_Insn, ?const:symbol)

// Assign cast instruction
.decl AssignCast_From(?insn:AssignCast_Insn, ?from:Var)

.decl AssignCast_Type(?insn:AssignCast_Insn, ?type:Type)

// Assign numeric constant casting instruction
.decl AssignCastNumConstant_Id(?insn:AssignCastNumConstant_Insn, ?const:symbol)

// Assign local instruction
.decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)

// Assign instanceof expression
.decl AssignInstanceOf_From(?insn:AssignInstanceOf_Insn, ?from:Var)

.decl AssignInstanceOf_Type(?insn:AssignInstanceOf_Insn, ?type:Type)

// Assign expression vars
.decl AssignOper_From(?insn:AssignOper_Insn, ?pos:number, ?from:Var)

// Assign constants
.decl AssignOper_FromConstant(?insn:AssignOper_Insn, ?pos: number, ?from:NumConstant)

// Assign Heap Allocation
.decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)


//-----------------------------------------------------------------------------
// [Return Instructions]
//-----------------------------------------------------------------------------

.decl ReturnNonvoid_Var(?return:ReturnNonvoid_Insn, ?var:Var)


//-----------------------------------------------------------------------------
// [Invocation Instructions]
//-----------------------------------------------------------------------------

// The line number of a method invocation
.decl MethodInvocation_Line(?invocation:MethodInvocation, ?line:number)

// The signature of the method being called
.decl MethodInvocation_Method(?invocation:MethodInvocation, ?signature:Method)

// The (call-site) variable that holds the result of the invocation
.decl AssignReturnValue(?invocation:MethodInvocation, ?to:Var)

// The actual parameters of the invocation. Note: this does not
// contain the receiver object (see MethodInvocation:Base predicates).
.decl ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)

// Virtual Method Invocation
.decl VirtualMethodInvocation_Base(?invocation:VirtualMethodInvocation_Insn, ?base:Var)
.decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)

// Super Method Invocation
.decl SuperMethodInvocation_Base(?invocation:SuperMethodInvocation_Insn, ?base:Var)
.decl SuperMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl SuperMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)

// Dynamic Method Invocation
.decl DynamicMethodInvocation_Bootstrap(?invocation:DynamicMethodInvocation_Insn, ?bootSignature:Method)

// The following triplet is the dynamic method and can be anything
// (these are parts of a single UTF-8 string in the bytecode).
.decl DynamicMethodInvocation_DynName(?invocation:DynamicMethodInvocation_Insn, ?dynName:symbol)
.decl DynamicMethodInvocation_DynReturnType(?invocation:DynamicMethodInvocation_Insn, ?dynRetType:Type)
.decl DynamicMethodInvocation_DynParamTypes(?invocation:DynamicMethodInvocation_Insn, ?dynParamTypes:symbol)
// Arity of the dynamic method (calculated by the front-end).
.decl DynamicMethodInvocation_DynArity(?invocation:DynamicMethodInvocation_Insn, ?dynArity:number)
// The tag of the method handle (spec: JVMS 5.4.3.5).
.decl DynamicMethodInvocation_HandleTag(?instruction:DynamicMethodInvocation_Insn, ?tag:number)

// The bootstrap parameters of a dynamic invocation.
.decl BootstrapParam(?index:number, ?invocation:DynamicMethodInvocation_Insn, ?var:Var)

// Static Method Invocation
.decl StaticMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl StaticMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)

// Special Method Invocation
.decl SpecialMethodInvocation_Base(?invocation:SpecialMethodInvocation_Insn, ?base:Var)
.decl SpecialMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)
.decl SpecialMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)

.decl MethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)


//-----------------------------------------------------------------------------
// [Exception Handlers]
//-----------------------------------------------------------------------------

.type ExceptionHandler = Instruction
.decl isExceptionHandler(?handler:ExceptionHandler)

.decl ExceptionHandler_Method(?handler:ExceptionHandler, ?inmethod:Method)

// Instruction index of handling code
.decl ExceptionHandler_Index(?handler:ExceptionHandler, ?index:number)
.decl ExceptionHandler_Type(?handler:ExceptionHandler, ?type:Type)

// Variable to which caught exceptions are assigned
.decl ExceptionHandler_FormalParam(?handler:ExceptionHandler, ?var:Var)

// First index of the bytecodes covered by this handler
.decl ExceptionHandler_Begin(?handler:ExceptionHandler, ?index:number)

// Last index (excluding this index) of the bytecodes covered by this
// handler
.decl ExceptionHandler_End(?handler:ExceptionHandler, ?index:number)

// Previous exception handler (handlers are ordered inside a method)
.decl ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)

// Application subsets
.decl ApplicationClass(?ref:ReferenceType)
.decl ApplicationField(?field:Field)
.decl ApplicationMethod(?method:Method)
.decl ApplicationVar(?var:Var)
.decl ApplicationInvocation(?invocation:MethodInvocation)
.decl ApplicationAllocation(?allocation:HeapAllocation)


//-----------------------------------------------------------------------------
// [Miscellaneous]
//-----------------------------------------------------------------------------

// Contents of properties files
.decl Properties(?path:StringConstant, ?key:StringConstant, ?value:StringConstant)

// Return variables of native methods (no instructions exist)
.decl NativeReturnVar(?var:Var, ?method:Method)

// Annotations
.type Annotation = ReferenceType
.decl isAnnotation(?a:Annotation)
.decl Type_Annotation(?type:ReferenceType, ?annotation:Annotation)
.decl Method_Annotation(?method:Method, ?annotation:Annotation)
.decl Field_Annotation(?fld:Field, ?annotation:Annotation)
.decl Param_Annotation(?method:Method, ?index:number, ?annotation:Annotation)
.decl AnnotationElement(?annotationKind:symbol, ?element:symbol, ?parentId:symbol, ?id:symbol, ?name:symbol, ?value1:symbol, ?value2:symbol)

// The definition should appear outside the include, because a few rules negatively refer to it
.decl isOpaqueMethod(?m:Method)


// Predicate to store analysis statistics
.decl Stats_Metrics(order:symbol, msg:symbol, c:number)


// Mock objects participating in mocked methods and argument/return values.
// Declared here so that they are available for statistics even when
// implicitly reachable entry points are disabled.
.decl MockObject(?value:Value, ?class:ReferenceType)
.output MockObject
.decl MockObjFromOpenProgramEntryPointReceiver(?value:Value)
.decl ExercisedEntryPointMethod(?class:Type, ?method:Method)
.decl MockObjFromOpenProgramEntryPointArg(?value:Value)
.decl UnmockableFormalOfForcedReachableContext(?formal:Var, ?formalType:Type)

//-----------------------------------------------------------------------------
// [Flow-insensitive Schema Layer]
//
// The following section contains a slightly modified schema that hides the
// underlying instruction entities, which are irrelevant to flow-insensitive
// analyses.
//
// The basic pattern is that, for each instruction entity, we introduce another
// predicate that joins all of its properties (encoded as functional
// predicates) but does not contain the instruction itself.
//
// Note that this pattern applies only to a subset of instructions that is
// important for flow-insensitive analysis.
//-----------------------------------------------------------------------------

.decl Throw(?insn:Throw_Insn, ?var:Var)

.decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)

.decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod:Method)

.decl LoadStaticField(?sig:Field, ?to:Var, ?inmethod:Method)

.decl StoreStaticField(?from:Var, ?signature:Field, ?inmethod:Method)

.decl LoadArrayIndex(?base:Var, ?to:Var, ?inmethod:Method)

.decl StoreArrayIndex(?from:Var, ?base:Var, ?inmethod:Method)

.decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)

.decl AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)

.decl AssignNull(?to:Var, ?inmethod:Method)

.decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inmethod:Method)

// Note: a Jimple method can have multiple return variables
.decl ReturnVar(?var:Var, ?method:Method)

.decl VirtualMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)

.decl SuperMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)

.decl StaticMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)


Throw(?insn, ?var) :-
	isThrow_Insn(?insn),
	Throw_Var(?insn, ?var).

LoadInstanceField(?base, ?sig, ?to, ?inmethod) :-
	isLoadInstanceField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	LoadInstanceField_Base(?insn, ?base),
	FieldInstruction_Signature(?insn, ?sig),
	LoadInstanceField_To(?insn, ?to).

StoreInstanceField(?from, ?base, ?sig, ?inmethod) :-
	isStoreInstanceField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreInstanceField_From(?insn, ?from),
	StoreInstanceField_Base(?insn, ?base),
	FieldInstruction_Signature(?insn, ?sig).

LoadStaticField(?sig, ?to, ?inmethod) :-
	isLoadStaticField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	FieldInstruction_Signature(?insn, ?sig),
	LoadStaticField_To(?insn, ?to).

StoreStaticField(?from, ?sig, ?inmethod) :-
	isStoreStaticField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreStaticField_From(?insn, ?from),
	FieldInstruction_Signature(?insn, ?sig).

LoadArrayIndex(?base, ?to, ?inmethod) :-
	isLoadArrayIndex_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	LoadArrayIndex_Base(?insn, ?base),
	LoadArrayIndex_To(?insn, ?to).

StoreArrayIndex(?from, ?base, ?inmethod) :-
	isStoreArrayIndex_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreArrayIndex_From(?insn, ?from),
	StoreArrayIndex_Base(?insn, ?base).

AssignCast(?type, ?from, ?to, ?inmethod) :-
	isAssignCast_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	AssignCast_From(?insn, ?from),
	AssignInstruction_To(?insn, ?to),
	AssignCast_Type(?insn, ?type).

AssignLocal(?from, ?to, ?inmethod) :-
	isAssignLocal_Insn(?insn),
	AssignInstruction_To(?insn, ?to),
	Instruction_Method(?insn, ?inmethod),
	AssignLocal_From(?insn, ?from).

AssignNull(?to, ?inmethod) :-
	isAssignNull_Insn(?insn),
	AssignInstruction_To(?insn, ?to),
	Instruction_Method(?insn, ?inmethod).

AssignHeapAllocation(?heap, ?to, ?inmethod) :-
	isAssignHeapAllocation_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	AssignHeapAllocation_Heap(?insn, ?heap),
	AssignInstruction_To(?insn, ?to).

ReturnVar(?var, ?method) :-
	isReturnNonvoid_Insn(?insn),
	Instruction_Method(?insn, ?method),
	ReturnNonvoid_Var(?insn, ?var).

ReturnVar(?var, ?method) :-
	NativeReturnVar(?var, ?method).

VirtualMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isVirtualMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

StaticMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isStaticMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

SuperMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isSuperMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
VirtualMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isVirtualMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

StaticMethodInvocation_SimpleName(?invocation, ?simplename),
StaticMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isStaticMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

SpecialMethodInvocation_SimpleName(?invocation, ?simplename),
SpecialMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isSpecialMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

SuperMethodInvocation_SimpleName(?invocation, ?simplename),
SuperMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isSuperMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

.decl MethodInvocation_SimpleName(?invocation:Instruction, ?simpleName:symbol)

MethodInvocation_SimpleName(?invocation, ?simplename) :-
	VirtualMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	SpecialMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	StaticMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	SuperMethodInvocation_SimpleName(?invocation, ?simplename).

// Keep information.
.decl KeepMethod(?m:Method)
.decl KeepClassMembers(?m:Method)
.decl KeepClassesWithMembers(?m:Method)
.decl KeepClass(?c:ReferenceType)
.decl RootCodeElement(?id:symbol)

.input KeepMethod(filename="KeepMethod.facts")
.input KeepClassMembers(filename="KeepClassMembers.facts")
.input KeepClassesWithMembers(filename="KeepClassesWithMembers.facts")
.input KeepClass(filename="KeepClass.facts")
.input RootCodeElement(filename="RootCodeElement.facts")



// Opaque methods are really opaque method signatures that are not
// subject to normal handling of method invocation. Such invocations
// are not resolved by method lookup/resolution and arguments/return
// values are not handled. There is only ad-hoc handling of these
// signatures in various places in analysis logic. This helps with
// difficult methods that only contribute noise to the analysis and
// thus the analysis should never enter them.
//
// A rule handling an opaque method invocation should:
// (a) Use the imported facts directly (e.g., _VirtualMethodInvocation).
// (b) Create call-graph edges manually via OpaqueCallGraphEdge.

.type OpaqueInstruction = Instruction

.decl isOpaqueInstruction(?insn:OpaqueInstruction)
.output isOpaqueInstruction

// Opaque method invocations

isOpaqueInstruction(?instruction) :-
   _StaticMethodInvocation(?instruction, _, ?signature, _),
   isOpaqueMethod(?signature).
isOpaqueInstruction(?instruction) :-
   _SpecialMethodInvocation(?instruction, _, ?signature, _, _),
   isOpaqueMethod(?signature).
isOpaqueInstruction(?instruction) :-
   _VirtualMethodInvocation(?instruction, _, ?signature, _, _),
   isOpaqueMethod(?signature).







// There is special support for dynamic proxies API, API internals are not analyzed.
isOpaqueMethod(m) :- isMethod(m), m = "<sun.misc.ProxyGenerator: byte[] generateClassFile()>".















isType(?t) :- isPrimitiveType(?t) ; isReferenceType(?t).

isReferenceType(?t) :-
  isNullType(?t) ; isArrayType(?t) ; isClassType(?t) ; isInterfaceType(?t) ; isAnnotation(?t).

isHeapAllocation(?h) :-
  isNormalHeap(?h) ; isStringConstant(?h) ; isClassHeap(?h) ; isMethodHandleConstant(?h) ; isMethodTypeConstant(?h).


isInstruction(?i) :-
  isThrow_Insn(?i) ; isGoto_Insn(?i) ; isIf_Insn(?i) ; isSwitch_Insn(?i) ; isMonitorInstruction(?i) ;
  isFieldInstruction(?i) ; isArrayInstruction(?i) ; isAssignInstruction(?i) ;
  isReturnInstruction(?i) ; isMethodInvocation(?i) ; isUnsupportedInstruction(?i).

isThrowNull_Insn(?i) :- isThrow_Insn(?i).

isSwitch_Insn(?i) :- isTableSwitch_Insn(?i) ; isLookupSwitch_Insn(?i).

isMonitorInstruction(?i) :- isEnterMonitor_Insn(?i) ; isExitMonitor_Insn(?i).

isFieldInstruction(?i) :-
  isLoadInstanceField_Insn(?i) ; isStoreInstanceField_Insn(?i) ;
  isLoadStaticField_Insn(?i) ; isStoreStaticField_Insn(?i).

isArrayInstruction(?i) :- isLoadArrayIndex_Insn(?i) ; isStoreArrayIndex_Insn(?i).

isAssignInstruction(?i) :-
  isAssignOper_Insn(?i) ; isAssignInstanceOf_Insn(?i) ; isAssignNull_Insn(?i) ;
  isAssignNumConstant_Insn(?i) ; isAssignCast_Insn(?i) ; isAssignHeapAllocation_Insn(?i).

isAssignOper_Insn(?i) :-
  isAssignBinop_Insn(?i) ; isAssignUnop_Insn(?i) ; isAssignLocal_Insn(?i).

isAssignCast_Insn(?i) :- isAssignCastNumConstant_Insn(?i) ; isAssignCastNull_Insn(?i).

isReturnInstruction(?i) :- isReturnVoid_Insn(?i) ; isReturnNonvoid_Insn(?i).

isMethodInvocation(?i) :-
  isVirtualMethodInvocation_Insn(?i) ; isSpecialMethodInvocation_Insn(?i) ; isStaticMethodInvocation_Insn(?i) ;
  isSuperMethodInvocation_Insn(?i) ; isDynamicMethodInvocation_Insn(?i).

isUnsupportedInstruction(?i) :- isAssignPhantomInvoke(?i) ; isBreakpointStmt(?i).



// ClassType

.decl _ClassType(?class:ClassType)
.input _ClassType(filename="ClassType.facts")

isClassType(?class) :- _ClassType(?class).


// ArrayType

.decl _ArrayType(?arrayType:ArrayType)
.input _ArrayType(filename="ArrayType.facts")

isArrayType(?arrayType) :- _ArrayType(?arrayType).


// InterfaceType

.decl _InterfaceType(?interface:InterfaceType)
.input _InterfaceType(filename="InterfaceType.facts")

isInterfaceType(?interface) :- _InterfaceType(?interface).


// ComponentType

.decl _ComponentType(?arrayType:ArrayType, ?componentType:Type)
.input _ComponentType(filename="ComponentType.facts")

isArrayType(?arrayType),
isType(?componentType),
ComponentType(?arrayType, ?componentType) :-
  _ComponentType(?arrayType, ?componentType).


// ActualParam

.decl _ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)
.input _ActualParam(filename="ActualParam.facts")

isMethodInvocation(?invocation),
isVar(?var),
ActualParam(?index, ?invocation, ?var) :-
  _ActualParam(?index, ?invocation, ?var).

// BootstrapParam

.decl _BootstrapParam(?index:number, ?invocation:MethodInvocation, ?var:Var)
.input _BootstrapParam(filename="BootstrapParam.facts")

isDynamicMethodInvocation_Insn(?invocation),
isVar(?var),
BootstrapParam(?index, ?invocation, ?var) :-
  _BootstrapParam(?index, ?invocation, ?var).

// DirectSuperinterface

.decl _DirectSuperinterface(?class:ReferenceType, ?interface:InterfaceType)
.input _DirectSuperinterface(filename="DirectSuperinterface.facts")

isReferenceType(?class),
isInterfaceType(?interface),
DirectSuperinterface(?class, ?interface) :-
  _DirectSuperinterface(?class, ?interface).


// DirectSuperclass

.decl _DirectSuperclass(?class:ClassType, ?superclass:ClassType)
.input _DirectSuperclass(filename="DirectSuperclass.facts")

isClassType(?class),
isClassType(?superclass),
DirectSuperclass(?class, ?superclass) :-
  _DirectSuperclass(?class, ?superclass).


// Field:Modifier

.decl _Field_Modifier(?modifier:Modifier, ?field:Field)
.input _Field_Modifier(filename="Field-Modifier.facts")

isModifier(?modifier),
isField(?field),
Field_Modifier(?modifier, ?field) :-
  _Field_Modifier(?modifier, ?field).


// ClassModifier

.decl _ClassModifier(?modifier:Modifier, ?class:ReferenceType)
.input _ClassModifier(filename="ClassModifier.facts")

ClassModifier(?modifier, ?class) :-
  _ClassModifier(?modifier, ?class).


// FormalParam

.decl _FormalParam(?index:number, ?method:Method, ?var:Var)
.input _FormalParam(filename="FormalParam.facts")

isMethod(?method),
isVar(?var),
FormalParam(?index, ?method, ?var) :-
  _FormalParam(?index, ?method, ?var).


// Method:DeclaresException

.decl _Method_DeclaresException(?exceptionType:ReferenceType, ?method:Method)
.input _Method_DeclaresException(filename="Method-DeclaresException.facts")

isReferenceType(?exceptionType),
isMethod(?method),
Method_DeclaresException(?exceptionType, ?method) :-
  _Method_DeclaresException(?exceptionType, ?method).


// Method:Modifier

.decl _Method_Modifier(?mod:Modifier, ?method:Method)
.input _Method_Modifier(filename="Method-Modifier.facts")

isModifier(?mod),
isMethod(?method),
Method_Modifier(?mod, ?method) :-
  _Method_Modifier(?mod, ?method).


// NativeReturnVar

.decl _NativeReturnVar(?var:Var, ?method:Method)
.input _NativeReturnVar(filename="NativeReturnVar.facts")

isVar(?var),
isMethod(?method),
NativeReturnVar(?var, ?method) :-
  _NativeReturnVar(?var, ?method).


// Var:Type

.decl _Var_Type(?var:Var, ?type:Type)
.input _Var_Type(filename="Var-Type.facts")

isVar(?var),
isType(?type),
Var_Type(?var, ?type) :-
  _Var_Type(?var, ?type).


// Var:DeclaringMethod

.decl _Var_DeclaringMethod(?var:Var, ?method:Method)
.input _Var_DeclaringMethod(filename="Var-DeclaringMethod.facts")

isVar(?var),
isMethod(?method),
Var_DeclaringMethod(?var, ?method) :-
  _Var_DeclaringMethod(?var, ?method).


// Var:SimpleName

.decl _Var_SimpleName(?var:Var, ?simplename:symbol)
.input _Var_SimpleName(filename="Var-SimpleName.facts")

isVar(?var),
Var_SimpleName(?var, ?simplename) :-
  _Var_SimpleName(?var, ?simplename).


// ApplicationClass

.decl _ApplicationClass(?type:ReferenceType)
.input _ApplicationClass(filename="ApplicationClass.facts")

isReferenceType(?type),
ApplicationClass(?type) :-
  _ApplicationClass(?type).


// ApplicationPackage

.decl _ApplicationPackage(?package:symbol)
.input _ApplicationPackage(filename="ApplicationPackage.facts")


// ThisVar

.decl _ThisVar(?method:Method, ?var:Var)
.input _ThisVar(filename="ThisVar.facts")

isMethod(?method),
isVar(?var),
ThisVar(?method, ?var) :-
  _ThisVar(?method, ?var).


// ExceptionHandler:Previous

.decl _ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)
.input _ExceptionHandler_Previous(filename="ExceptionHandler-Previous.facts")

isExceptionHandler(?handler),
isExceptionHandler(?previous),
ExceptionHandler_Previous(?handler, ?previous) :-
  _ExceptionHandler_Previous(?handler, ?previous).


// AssignReturnValue

.decl _AssignReturnValue(?invocation:MethodInvocation, ?to:Var)
.input _AssignReturnValue(filename="AssignReturnValue.facts")

isMethodInvocation(?invocation),
isVar(?to),
AssignReturnValue(?invocation, ?to) :-
  _AssignReturnValue(?invocation, ?to).


// Properties
.input Properties


.decl _OperatorAt(?instruction:Instruction, ?operator:symbol)
.input _OperatorAt(filename="OperatorAt.facts")

// MainClass
.input MainClass

// ClassArtifact
.decl _ClassArtifact(?artifact:symbol, ?className:ReferenceType, ?subArtifact:symbol, ?size:number)
.input _ClassArtifact(filename="Class-Artifact.facts")

// NormalHeap

.decl _NormalHeap(?id:NormalHeap, ?type:ReferenceType)
.input _NormalHeap(filename="NormalHeap.facts")

isType(?type),
isNormalHeap(?id),
OriginalHeapAllocation_Type(?id, ?type),
HeapAllocation_Type(?id, ?type) :-
  _NormalHeap(?id, ?type).

isClassType("java.lang.String").


// StringConstant

.decl _StringConstant(?id:StringConstant)
.input _StringConstant(filename="StringConstant.facts")

isStringConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.String"),
HeapAllocation_Type(?id, "java.lang.String") :-
  _StringConstant(?id).


// StringRaw

.decl _StringRaw(?id:symbol, ?rawId:symbol)
.input _StringRaw(filename="StringRaw.facts")

.decl String_toRaw(?id:symbol, ?rawId:symbol)

isStringRaw(?id),
String_toRaw(?id, ?rawId) :-
  _StringRaw(?id, ?rawId).


// ClassHeap

.decl _ClassHeap(?id:ClassHeap, ?instanceType:ReferenceType)
.input _ClassHeap(filename="ClassHeap.facts")

isType(?instanceType),
isClassHeap(?id),
ClassHeap_InstanceType(?id, ?instanceType),
OriginalHeapAllocation_Type(?id, "java.lang.Class"),
HeapAllocation_Type(?id, "java.lang.Class") :-
  _ClassHeap(?id, ?instanceType).

// MethodHandleConstant

.decl _MethodHandleConstant(?id:MethodHandleConstant, ?method:Method, ?retType:Type, ?paramTypes:symbol, ?arity:number)
.input _MethodHandleConstant(filename="MethodHandleConstant.facts")

isType("java.lang.invoke.MethodHandle").
isReferenceType("java.lang.invoke.MethodHandle").
isClassType("java.lang.invoke.MethodHandle").

isMethodHandleConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodHandle"),
MethodHandleConstant_Method(?id, ?method),
MethodHandleConstant_Arity(?id, ?arity),
MethodHandleConstant_ReturnType(?id, ?retType),
MethodHandleConstant_ParamTypes(?id, ?paramTypes),
HeapAllocation_Type(?id, "java.lang.invoke.MethodHandle") :-
  _MethodHandleConstant(?id, ?method, ?retType, ?paramTypes, ?arity).

// MethodTypeConstant

.decl _MethodTypeConstant(?id:MethodTypeConstant, ?arity:number, ?retType:Type, ?paramTypes:symbol)
.input _MethodTypeConstant(filename="MethodTypeConstant.facts")

isMethodTypeConstant(?id),
HeapAllocation_Type(?id, "java.lang.invoke.MethodType"),
MethodTypeConstant_Arity(?id, ?arity),
MethodTypeConstant_ReturnType(?id, ?retType),
MethodTypeConstant_ParamTypes(?id, ?paramTypes),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodType") :-
  _MethodTypeConstant(?id, ?arity, ?retType, ?paramTypes).

.decl _MethodTypeConstantParam(?id:MethodTypeConstant, ?idx:number, ?type:Type)
.input _MethodTypeConstantParam(filename="MethodTypeConstantParam.facts")

// Native code facts

.decl _NativeLibEntryPoint(?lib:symbol, ?function:symbol, ?addr:symbol)
.input _NativeLibEntryPoint(filename="NativeLibEntryPoint.facts")

.decl _NativeMethodTypeCandidate(?lib:symbol, ?function:symbol, ?descriptor:symbol, ?offset2:number)
.input _NativeMethodTypeCandidate(filename="NativeMethodTypeCandidate.facts")

.decl _NativeNameCandidate(?lib:symbol, ?function:symbol, ?name:symbol, ?offset1:number)
.input _NativeNameCandidate(filename="NativeNameCandidate.facts")

.decl _NativeMethodId(?javaMethod:Method, ?nativeId:symbol)
.input _NativeMethodId(filename="NativeMethodId.facts")

.decl _NativeXRef(?string:symbol, ?lib:symbol, ?function:symbol, ?dataAddr:number)
.input _NativeXRef(filename="NativeXRef.facts")

// EmptyArray

.decl _EmptyArray(?id:HeapAllocation)
.input _EmptyArray(filename="EmptyArray.facts")

HeapAllocation_EmptyArray(?id) :-
  _EmptyArray(?id).

// Array Allocation

.decl _ArrayAllocation(?instruction:Instruction, ?pos:number, ?sizeVar:Var)
.input _ArrayAllocation(filename="ArrayAllocation.facts")

ArrayAllocation(?insn, ?pos, ?sizeVar) :-
  _ArrayAllocation(?insn, ?pos, ?sizeVar).


// AssignHeapAllocation

.decl _AssignHeapAllocation(?instruction:AssignHeapAllocation_Insn, ?index:number, ?heap:HeapAllocation, ?to:Var, ?inmethod:Method, ?linenumber:number)
.input _AssignHeapAllocation(filename="AssignHeapAllocation.facts")

isAssignHeapAllocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Line(?instruction, ?linenumber),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to),
AssignHeapAllocation_Heap(?instruction, ?heap) :-
  _AssignHeapAllocation(?instruction, ?index, ?heap, ?to, ?method, ?linenumber).


// AssignLocal

.decl _AssignLocal(?instruction:AssignLocal_Insn, ?index:number, ?from:Var, ?to:Var, ?inmethod:Method)
.input _AssignLocal(filename="AssignLocal.facts")

isAssignLocal_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignLocal_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  _AssignLocal(?instruction, ?index, ?from, ?to, ?method).


// AssignBinop

.decl _AssignBinop(?instruction:AssignBinop_Insn, ?index:number, ?to:Var, ?inmethod:Method)
.input _AssignBinop(filename="AssignBinop.facts")

isAssignBinop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignBinop(?instruction, ?index, ?to, ?method).


// AssignUnop

.decl _AssignUnop(?instruction:AssignUnop_Insn, ?index:number, ?to:Var, ?inmethod:Method)
.input _AssignUnop(filename="AssignUnop.facts")

isAssignUnop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignUnop(?instruction, ?index, ?to, ?method).


// AssignOperFrom

.decl _AssignOperFrom(?instruction:AssignOper_Insn, ?pos: number, ?from:Var)
.input _AssignOperFrom(filename="AssignOperFrom.facts")

AssignOper_From(?instruction, ?pos, ?from) :-
  _AssignOperFrom(?instruction, ?pos, ?from).

// AssignOperFromConstant

.decl _AssignOperFromConstant(?instruction:AssignOper_Insn, ?pos: number, ?from:NumConstant)
.input _AssignOperFromConstant(filename="AssignOperFromConstant.facts")

AssignOper_FromConstant(?instruction, ?pos, ?from) :-
  _AssignOperFromConstant(?instruction, ?pos, ?from).

// IfConstant

.decl _IfConstant(?instruction:If_Insn, ?pos:number, ?cons:NumConstant)
.input _IfConstant(filename="IfConstant.facts")

If_Constant(?instruction, ?pos, ?cons) :-
  _IfConstant(?instruction, ?pos, ?cons).


// IfVar

.decl _IfVar(?instruction:If_Insn, ?pos:number, ?var:Var)
.input _IfVar(filename="IfVar.facts")

If_Var(?instruction, ?pos, ?var) :-
  _IfVar(?instruction, ?pos, ?var).

// DummyIfVar

.decl _DummyIfVar(?instruction:If_Insn, ?var:Var)
.input _DummyIfVar(filename="DummyIfVar.facts")

DummyIf_Var(?instruction, ?var) :-
  _DummyIfVar(?instruction, ?var).

// AssignCast

.decl _AssignCast(?instruction:AssignCast_Insn, ?index:number, ?from:Var, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignCast(filename="AssignCast.facts")

isAssignCast_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignCast_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCast(?instruction, ?index, ?from, ?to, ?type, ?method).


// AssignCastNumConstant

.decl _AssignCastNumConstant(?instruction:AssignCastNumConstant_Insn, ?index:number, ?const:symbol, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignCastNumConstant(filename="AssignCastNumConstant.facts")

isAssignCastNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignCastNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCastNumConstant(?instruction, ?index, ?const, ?to, ?type, ?method).


// AssignCastNull

.decl _AssignCastNull(?instruction:AssignCastNull_Insn, ?index:number, ?to:Var, ?type:Type, ?method:Method)
.input _AssignCastNull(filename="AssignCastNull.facts")

isAssignCastNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  _AssignCastNull(?instruction, ?index, ?to, ?type, ?method).


// AssignNumConstant

.decl _AssignNumConstant(?instruction:AssignNumConstant_Insn, ?index:number, ?const:NumConstant, ?to:Var, ?inmethod:Method)
.input _AssignNumConstant(filename="AssignNumConstant.facts")

isNumConstant(?const),
isAssignNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  _AssignNumConstant(?instruction, ?index, ?const, ?to, ?method).


// AssignNull

.decl _AssignNull(?instruction:AssignNull_Insn, ?index:number, ?to:Var, ?method:Method)
.input _AssignNull(filename="AssignNull.facts")

isAssignNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  _AssignNull(?instruction, ?index, ?to, ?method).


// AssignInstanceOf

.decl _AssignInstanceOf(?instruction:AssignInstanceOf_Insn, ?index:number, ?from:Var, ?to:Var, ?type:Type, ?inmethod:Method)
.input _AssignInstanceOf(filename="AssignInstanceOf.facts")

isAssignInstanceOf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstanceOf_From(?instruction, ?from),
AssignInstanceOf_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  _AssignInstanceOf(?instruction, ?index, ?from, ?to, ?type, ?method).


// Field

.decl _Field(?signature:Field, ?declaringClass:ReferenceType, ?simplename:symbol, ?type:Type)
.input _Field(filename="Field.facts")

isField(?signature),
Field_DeclaringType(?signature, ?declaringType),
Field_SimpleName(?signature, ?simplename),
Field_Type(?signature, ?type) :-
  _Field(?signature, ?declaringType, ?simplename, ?type).

// EnterMonitor

.decl _EnterMonitor(?instruction:EnterMonitor_Insn, ?index:number, ?var:Var, ?method:Method)
.input _EnterMonitor(filename="EnterMonitor.facts")

isEnterMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
EnterMonitor_Var(?instruction, ?var) :-
  _EnterMonitor(?instruction, ?index, ?var, ?method).


// ExitMonitor

.decl _ExitMonitor(?instruction:ExitMonitor_Insn, ?index:number, ?var:Var, ?method:Method)
.input _ExitMonitor(filename="ExitMonitor.facts")

isExitMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
ExitMonitor_Var(?instruction, ?var) :-
  _ExitMonitor(?instruction, ?index, ?var, ?method).


// Method Invocation line numbers

.decl _MethodInvocation_Line(?instruction:MethodInvocation, line:number)
.input _MethodInvocation_Line(filename="MethodInvocation-Line.facts")

isMethodInvocation(?instruction),
MethodInvocation_Line(?instruction, ?line) :-
  _MethodInvocation_Line(?instruction, ?line).

MethodInvocation_Base(?invocation, ?base) :-
  VirtualMethodInvocation_Base(?invocation, ?base).
MethodInvocation_Base(?invocation, ?base) :-
  SpecialMethodInvocation_Base(?invocation, ?base).


// Static method invocation

.decl _StaticMethodInvocation(?instruction:StaticMethodInvocation_Insn, ?index:number, ?signature:Method, ?method:Method)
.input _StaticMethodInvocation(filename="StaticMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _StaticMethodInvocation(?instruction, ?index, ?signature, ?method).

isStaticMethodInvocation_Insn(?instruction) :-
  _StaticMethodInvocation(?instruction, _, ?signature, _),
  !isOpaqueMethod(?signature).

// Special method invocation

.decl _SpecialMethodInvocation(?instruction:SpecialMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _SpecialMethodInvocation(filename="SpecialMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _SpecialMethodInvocation(?instruction, ?index, ?signature, _, ?method).

isSpecialMethodInvocation_Insn(?instruction),
SpecialMethodInvocation_Base(?instruction, ?base) :-
  _SpecialMethodInvocation(?instruction, _, ?signature, ?base, _),
  !isOpaqueMethod(?signature).

// Virtual method invocation

.decl _VirtualMethodInvocation(?instruction:VirtualMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _VirtualMethodInvocation(filename="VirtualMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  _VirtualMethodInvocation(?instruction, ?index, ?signature, _, ?method).

isVirtualMethodInvocation_Insn(?instruction),
VirtualMethodInvocation_Base(?instruction, ?base) :-
  _VirtualMethodInvocation(?instruction, _, ?signature, ?base, _),
  !isOpaqueMethod(?signature).

// Super method invocation

.decl _SuperMethodInvocation(?instruction:SuperMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)
.input _SuperMethodInvocation(filename="SuperMethodInvocation.facts")

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature),
isSuperMethodInvocation_Insn(?instruction),
SuperMethodInvocation_Base(?instruction, ?base) :-
  _SuperMethodInvocation(?instruction, ?index, ?signature, ?base, ?method).

// Dynamic method invocation

.decl _DynamicMethodInvocation(?instruction:DynamicMethodInvocation_Insn, ?index:number, ?bootSignature:Method, ?dynName:symbol, ?dynRetType:Type, ?dynArity:number, ?dynParamTypes:symbol, ?tag:number, ?method:Method)
.input _DynamicMethodInvocation(filename="DynamicMethodInvocation.facts")

isDynamicMethodInvocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
DynamicMethodInvocation_Bootstrap(?instruction, ?bootSignature),
DynamicMethodInvocation_DynName(?instruction, ?dynName),
DynamicMethodInvocation_DynReturnType(?instruction, ?dynRetType),
DynamicMethodInvocation_DynParamTypes(?instruction, ?dynParamTypes),
DynamicMethodInvocation_HandleTag(?instruction, ?tag),
DynamicMethodInvocation_DynArity(?instruction, ?dynArity) :-
  _DynamicMethodInvocation(?instruction, ?index, ?bootSignature, ?dynName, ?dynRetType, ?dynArity, ?dynParamTypes, ?tag, ?method).

.decl _DynamicMethodInvocation_DynParamType(?invocation:DynamicMethodInvocation_Insn, ?idx:number, ?pType:Type)
.input _DynamicMethodInvocation_DynParamType(filename="DynamicMethodInvocation-ParamType.facts")


// Polymorphic-signature method invocation

.decl _PolymorphicInvocation(?invocation:MethodInvocation, ?simpleName:symbol)
.input _PolymorphicInvocation(filename="PolymorphicInvocation.facts")

// Throw

.decl _Throw(?instruction:Throw_Insn, ?index:number, ?var:Var, ?method:Method)
.input _Throw(filename="Throw.facts")

isThrow_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Throw(?instruction, ?var),
Throw_Var(?instruction, ?var) :-
  _Throw(?instruction, ?index, ?var, ?method).


// ThrowNull

.decl _ThrowNull(?instruction:ThrowNull_Insn, ?index:number, ?method:Method)
.input _ThrowNull(filename="ThrowNull.facts")

isThrowNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _ThrowNull(?instruction, ?index, ?method).


// Exception handler

.decl _ExceptionHandler(?handler:ExceptionHandler, ?method:Method, ?index:number, ?type:ReferenceType, ?begin:number, ?end:number)
.input _ExceptionHandler(filename="ExceptionHandler.facts")

isExceptionHandler(?handler),
isInstruction(?handler),
Instruction_Index(?handler, ?index),
Instruction_Method(?handler, ?method),
ExceptionHandler_Method(?handler, ?method),
ExceptionHandler_Index(?handler, ?index),
ExceptionHandler_Type(?handler, ?type),
ExceptionHandler_Begin(?handler, ?begin),
ExceptionHandler_End(?handler, ?end) :-
  _ExceptionHandler(?handler, ?method, ?index, ?type, ?begin, ?end).

.input ExceptionHandler_FormalParam(filename="ExceptionHandler-FormalParam.facts")

// Method

.decl _Method(?method:Method, ?simplename:symbol, ?descriptor:symbol, ?declaringType:ReferenceType, ?returnType:Type, ?jvmDescriptor:JVMDescriptor, ?arity:number)
.input _Method(filename="Method.facts")

isMethod(?method),
isJVMDescriptor(?jvmDescriptor),
Method_SimpleName(?method, ?simplename),
Method_ParamTypes(?method, ?params),
Method_DeclaringType(?method, ?declaringType),
Method_JVMDescriptor(?method, ?jvmDescriptor),
Method_Arity(?method, ?arity),
Method_ReturnType(?method, ?returnType) :-
  _Method(?method, ?simplename, ?params, ?declaringType, ?returnType, ?jvmDescriptor, ?arity).

isMethodDescriptor(?descriptor),
Method_Descriptor(?method, ?descriptor) :-
  Method_ReturnType(?method, ?returnType),
  Method_ParamTypes(?method, ?params),
  ?descriptor = cat(?returnType, cat("(", cat(?params, ")"))).

// StoreInstanceField

.decl _StoreInstanceField(?instruction:StoreInstanceField_Insn, ?index:number, ?from:Var, ?base:Var, ?signature:Field, ?method:Method)
.input _StoreInstanceField(filename="StoreInstanceField.facts")

isStoreInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
StoreInstanceField_Base(?instruction, ?base),
StoreInstanceField_From(?instruction, ?from) :-
  _StoreInstanceField(?instruction, ?index, ?from, ?base, ?signature, ?method).


// LoadInstanceField

.decl _LoadInstanceField(?instruction:LoadInstanceField_Insn, ?index:number, ?to:Var, ?base:Var, ?signature:Field, ?method:Method)
.input _LoadInstanceField(filename="LoadInstanceField.facts")

isLoadInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
LoadInstanceField_Base(?instruction, ?base),
LoadInstanceField_To(?instruction, ?to) :-
  _LoadInstanceField(?instruction, ?index, ?to, ?base, ?signature, ?method).


// StoreStaticField

.decl _StoreStaticField(?instruction:StoreStaticField_Insn, ?index:number, ?from:Var, ?signature:Field, ?method:Method)
.input _StoreStaticField(filename="StoreStaticField.facts")

isStoreStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
StoreStaticField_From(?instruction, ?from) :-
  _StoreStaticField(?instruction, ?index, ?from, ?signature, ?method).


// LoadStaticField

.decl _LoadStaticField(?instruction:LoadStaticField_Insn, ?index:number, ?to:Var, ?signature:Field, ?method:Method)
.input _LoadStaticField(filename="LoadStaticField.facts")

isLoadStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
LoadStaticField_To(?instruction, ?to) :-
  _LoadStaticField(?instruction, ?index, ?to, ?signature, ?method).


// StoreArrayIndex

.decl _StoreArrayIndex(?instruction:StoreArrayIndex_Insn, ?index:number, ?from:Var, ?base:Var, ?method:Method)
.input _StoreArrayIndex(filename="StoreArrayIndex.facts")

isStoreArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
StoreArrayIndex_Base(?instruction, ?base),
StoreArrayIndex_From(?instruction, ?from) :-
  _StoreArrayIndex(?instruction, ?index, ?from, ?base, ?method).


// LoadArrayIndex

.decl _LoadArrayIndex(?instruction:LoadArrayIndex_Insn, ?index:number, ?to:Var, ?base:Var, ?method:Method)
.input _LoadArrayIndex(filename="LoadArrayIndex.facts")

isLoadArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
LoadArrayIndex_Base(?instruction, ?base),
LoadArrayIndex_To(?instruction, ?to) :-
  _LoadArrayIndex(?instruction, ?index, ?to, ?base, ?method).


// ArrayInsnIndex

.decl _ArrayInsnIndex(?instruction:Instruction, ?index:Var)
.input _ArrayInsnIndex(filename="ArrayInsnIndex.facts")

ArrayInsnIndex(?instruction, ?index) :-
  _ArrayInsnIndex(?instruction, ?index).


// ArrayNumIndex

.decl _ArrayNumIndex(?instruction:Instruction, ?index:number)
.input _ArrayNumIndex(filename="ArrayNumIndex.facts")

ArrayNumIndex(?instruction, ?index) :-
  _ArrayNumIndex(?instruction, ?index).


// Goto

.decl _Goto(?instruction:Goto_Insn, ?index:number, ?to:number, ?method:Method)
.input _Goto(filename="Goto.facts")

isGoto_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Goto_Target(?instruction, ?to) :-
  _Goto(?instruction, ?index, ?to, ?method).


// If

.decl _If(?instruction:If_Insn, ?index:number, ?to:number, ?method:Method)
.input _If(filename="If.facts")

isIf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
If_Target(?instruction, ?to) :-
  _If(?instruction, ?index, ?to, ?method).


// Switch Statements

.decl _TableSwitch(?instruction:TableSwitch_Insn, ?index:number, ?key:Var, ?method:Method)
.input _TableSwitch(filename="TableSwitch.facts")

isTableSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Switch_Key(?instruction, ?key) :-
  _TableSwitch(?instruction, ?index, ?key, ?method).


.decl _LookupSwitch(?instruction:LookupSwitch_Insn, ?index:number, ?key:Var, ?method:Method)
.input _LookupSwitch(filename="LookupSwitch.facts")

isLookupSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Switch_Key(?instruction, ?key) :-
  _LookupSwitch(?instruction, ?index, ?key, ?method).


// Targets

.decl _TableSwitch_Target(?instruction:Switch_Insn, ?value:number, ?target:number)
.input _TableSwitch_Target(filename="TableSwitch-Target.facts")

Switch_Target(?instruction, ?value, ?target) :-
  _TableSwitch_Target(?instruction, ?value, ?target).


.decl _LookupSwitch_Target(?instruction:Switch_Insn, ?value:number, ?target:number)
.input _LookupSwitch_Target(filename="LookupSwitch-Target.facts")

Switch_Target(?instruction, ?value, ?target) :-
  _LookupSwitch_Target(?instruction, ?value, ?target).

// Default target

.decl _TableSwitch_DefaultTarget(?instruction:Switch_Insn, ?target:number)
.input _TableSwitch_DefaultTarget(filename="TableSwitch-Default.facts")

Switch_DefaultTarget(?instruction, ?target) :-
  _TableSwitch_DefaultTarget(?instruction, ?target).


.decl _LookupSwitch_DefaultTarget(?instruction:Switch_Insn, ?target:number)
.input _LookupSwitch_DefaultTarget(filename="LookupSwitch-Default.facts")

Switch_DefaultTarget(?instruction, ?target) :-
  _LookupSwitch_DefaultTarget(?instruction, ?target).


// ReturnNonvoid

.decl _Return(?instruction:ReturnNonvoid_Insn, ?index:number, ?var:Var, ?method:Method)
.input _Return(filename="Return.facts")

isReturnNonvoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
ReturnNonvoid_Var(?instruction, ?var) :-
  _Return(?instruction, ?index, ?var, ?method).


// ReturnVoid

.decl _ReturnVoid(?instruction:ReturnVoid_Insn, ?index:number, ?method:Method)
.input _ReturnVoid(filename="ReturnVoid.facts")

isReturnVoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _ReturnVoid(?instruction, ?index, ?method).


// AssignPhantomInvoke

.decl _AssignPhantomInvoke(?instruction:AssignPhantomInvoke, ?index:number, ?method:Method)
.input _AssignPhantomInvoke(filename="AssignPhantomInvoke.facts")

isAssignPhantomInvoke(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _AssignPhantomInvoke(?instruction, ?index, ?method).


// BreakPointStmt

.decl _BreakpointStmt(?instruction:BreakpointStmt, ?index:number, ?method:Method)
.input _BreakpointStmt(filename="BreakpointStmt.facts")

isBreakpointStmt(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _BreakpointStmt(?instruction, ?index, ?method).


// UnsupportedInstruction

.decl _UnsupportedInstruction(?instruction:UnsupportedInstruction, ?index:number, ?method:Method)
.input _UnsupportedInstruction(filename="UnsupportedInstruction.facts")

isUnsupportedInstruction(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  _UnsupportedInstruction(?instruction, ?index, ?method).


// Access Modifiers

isModifier(?x), Modifier_abstract(?x) :- ?x = "abstract".
isModifier(?x), Modifier_public(?x)   :- ?x = "public".
isModifier(?x), Modifier_private(?x)  :- ?x = "private".
isModifier(?x), Modifier_final(?x)    :- ?x = "final".
isModifier(?x), Modifier_static(?x)   :- ?x = "static".


// Basic Types as nullary functional-predicates

isPrimitiveType(?t), Type_boolean(?t) :- ?t = "boolean".
isPrimitiveType(?t), Type_byte(?t)    :- ?t = "byte".
isPrimitiveType(?t), Type_char(?t)    :- ?t = "char".
isPrimitiveType(?t), Type_short(?t)   :- ?t = "short".
isPrimitiveType(?t), Type_int(?t)     :- ?t = "int".
isPrimitiveType(?t), Type_long(?t)    :- ?t = "long".
isPrimitiveType(?t), Type_float(?t)   :- ?t = "float".
isPrimitiveType(?t), Type_double(?t)  :- ?t = "double".
isPrimitiveType(?t), Type_void(?t)    :- ?t = "void".

isNullType(?t), Type_null(?t) :- ?t = "null_type".

isClassType(?t), Type_object(?t) :- ?t = "java.lang.Object".


// Annotations
// Type
.input Type_Annotation(filename="Type-Annotation.facts")
// Method
.input Method_Annotation(filename="Method-Annotation.facts")
// Field
.input Field_Annotation(filename="Field-Annotation.facts")
// Param
.input Param_Annotation(filename="Param-Annotation.facts")

isAnnotation(?annotation) :- isReferenceType(?annotation), Type_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Method_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Field_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), Param_Annotation(_, _, ?annotation).

// Annotation elements
.input AnnotationElement(filename="AnnotationElement.facts")

// Phantom types/methods and phantom-based methods.
.decl PhantomType(?t:ReferenceType)
.input PhantomType(filename="PhantomType.facts")
.decl PhantomMethod(?m:Method)
.input PhantomMethod(filename="PhantomMethod.facts")
.decl PhantomBasedMethod(?m:Method)
.input PhantomBasedMethod(filename="PhantomBasedMethod.facts")


isHeapAllocation(?heap), isMethodHandleConstant(?heap), MethodHandleConstant_Method(?heap,  ?method), HeapAllocation_Type(?heap,  "java.lang.invoke.MethodHandle") :-
  MethodHandleConstant_Method(?heap, ?method).

isHeapAllocation(?null), HeapAllocation_Type(?null,  ?type),
HeapAllocation_Null(?null) :-
  ?null = "<<null pseudo heap>>",
  Type_null(?type).

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type),
MainMethodArgArray(?heap) :-
  ?heap = "<<main method array>>",
  ?type = "java.lang.String[]".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type),
MainMethodArgArrayContent(?heap) :-
  ?heap = "<<main method array content>>",
  ?type = "java.lang.String".

ApplicationField(?field) :-
  Field_DeclaringType(?field, ?type),
  ApplicationClass(?type).

ApplicationMethod(?method) :-
  Method_DeclaringType(?method, ?class),
  ApplicationClass(?class).

ApplicationVar(?var) :-
  Var_DeclaringMethod(?var, ?method),
  ApplicationMethod(?method).

ApplicationInvocation(?invocation) :-
  isMethodInvocation(?invocation),
  Instruction_Method(?invocation, ?method),
  ApplicationMethod(?method).

ApplicationAllocation(?heap) :-
  isAssignHeapAllocation_Insn(?insn),
  Instruction_Method(?insn, ?method),
  ApplicationMethod(?method),
  AssignHeapAllocation_Heap(?insn, ?heap).

ConcreteClass(?class) :-
  isClassType(?class),
  !ClassModifier("abstract", ?class).




isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0",
  ?type = "java.lang.String[]".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<sun.misc.Perf: java.nio.ByteBuffer createLong(java.lang.String,int,int,long)>/new java.nio.DirectByteBuffer/0",
  ?type = "java.nio.DirectByteBuffer".


isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<string-constant>>",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<reflection-string-constant>>",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<string-buffer>>",
  ?type = "java.lang.StringBuffer".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<string-builder>>",
  ?type = "java.lang.StringBuilder".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<system-thread-group>>",
  ?type = "java.lang.ThreadGroup".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<main-thread-group>>",
  ?type = "java.lang.ThreadGroup".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<main-thread>>",
  ?type = "java.lang.Thread".

// Special heaps for contexts
// Note: the type is necessary (java.lang.Object), but never used. It could be
// anything. It also needs to be an existing type, otherwise the sanity checks
// will barf.
isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<initial-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<jvm-startup-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<jvm-startup-hcontext>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<clinit-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<immutable-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<immutable-hcontext>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap,  ?type) :-
  ?heap = "<<immutable>>",
  ?type = "java.lang.Object".


// Relation that triggers the creation of (non-heap) number constants from imported facts.
.decl CreateIntValue(?n:symbol, ?type:Type, ?declaringType:ReferenceType)

.decl NumConstantRaw(?const:symbol, ?type:Type)
.input NumConstantRaw(filename="NumConstantRaw.facts")

// XML facts.
.decl XMLNode(?file:symbol, ?nodeId:symbol, ?parentNodeId:symbol, ?namespaceURI:symbol, ?localName:symbol, ?qName:symbol)
.input XMLNode(filename="XMLNode.facts")
.decl XMLNodeAttribute(?file:symbol, ?nodeId:symbol, ?index:symbol, ?localName:symbol, ?qName:symbol, ?value:symbol)
.input XMLNodeAttribute(filename="XMLNodeAttribute.facts")
.decl XMLNodeData(?file:symbol, ?nodeId:symbol, ?data:symbol)
.input XMLNodeData(filename="XMLNodeData.facts")















// Copy of MockValueConsMacro but with proper component qualifers.












// Android-specific macro to qualify unqualified types in layout controls.
// Heuristic: if the name is unqualified, it may come from android.view or
// android.widget ("Android Programming: The Big Nerd Ranch Guide", chapter 32).




.comp Basic {



.decl ExceptionHandler_InRange(?handler:ExceptionHandler, ?instruction:Instruction)

   
.decl ExceptionHandler_Before(?before:ExceptionHandler, ?handler:ExceptionHandler)

.decl ExceptionHandler_SameInsn_Repr(?insn:Instruction, ?repr:ExceptionHandler)
.decl ExceptionHandler_SameInsn_PartialOrder(?h1:ExceptionHandler, ?h2:ExceptionHandler, ?insn:Instruction)
.decl ExceptionHandler_SameBlock_Repr(?handler:ExceptionHandler, ?repr:ExceptionHandler)
.decl ExceptionHandler_SameBlock_PartialOrder(?repr:ExceptionHandler, ?handler:ExceptionHandler)
.decl ExceptionHandler_TypeIsCaught(?type:Type, ?block:ExceptionHandler)
.decl ExceptionHandler_Impossible(?type:Type, ?h2:ExceptionHandler, ?insn:Instruction)


   
ExceptionHandler_TypeIsCaught(?type, ?block) :-
	ExceptionHandler_InRange(?handler, ?insn),
	ExceptionHandler_SameInsn_Repr(?insn, ?repr),
	ExceptionHandler_SameBlock_Repr(?repr, ?block),
	ExceptionHandler_Type(?handler, ?handlerType),
	basic.SubtypeOf(?type, ?handlerType),
	ConcreteClass(?type).


   
ExceptionHandler_Impossible(?type, ?h2, ?insn) :-
	ExceptionHandler_InRange(?h1, ?insn),
	ExceptionHandler_InRange(?h2, ?insn),
	ExceptionHandler_Before(?h1, ?h2),
	ExceptionHandler_Type(?h1, ?h1Type),
	ExceptionHandler_Type(?h2, ?h2Type),
	basic.SubtypeOf(?type, ?h1Type),
	basic.SubtypeOf(?type, ?h2Type),
	ConcreteClass(?type).

///////////////////////////////////////////////////////////////////////////////

// An "exception handler" has a separate identity and the following information:
//  -where it starts being active
//  -where it stops
//  -which type it handles
//  -where it jumps when an appropriate exception is caught ("catch block"). This is
//   independent from the instructions the handler covers and has no semantics
//   (e.g., no priority of handlers based on locations of catch blocks).
//  -in which order it appears in the program text. This is important for priority.

ExceptionHandler_InRange(?handler, ?instruction) :-
	ExceptionHandler_Method(?handler, ?method),
	Instruction_Method(?instruction, ?method),
	Instruction_Index(?instruction, ?index),
	ExceptionHandler_Begin(?handler, ?beginIndex),
	?beginIndex <= ?index,
	ExceptionHandler_End(?handler, ?endIndex),
	?endIndex > ?index.

ExceptionHandler_Before(?previous, ?handler) :-
	ExceptionHandler_Previous(?handler, ?previous).

ExceptionHandler_Before(?before, ?handler) :-
	ExceptionHandler_Before(?middle, ?handler),
	ExceptionHandler_Previous(?middle, ?before).


   
ExceptionHandler_SameInsn_PartialOrder(?h1, ?h2, ?insn) :-
	ExceptionHandler_InRange(?h1, ?insn),
	ExceptionHandler_InRange(?h2, ?insn),
	ExceptionHandler_Before(?h1, ?h2).

ExceptionHandler_SameInsn_Repr(?insn, ?handler) :-
	ExceptionHandler_InRange(?handler, ?insn),
	!ExceptionHandler_SameInsn_PartialOrder(_, ?handler, ?insn).


   
ExceptionHandler_SameBlock_PartialOrder(?h1, ?h2) :-
	ExceptionHandler_Before(?h1, ?h2),
	ExceptionHandler_Index(?h1, ?h1Index),
	ExceptionHandler_Index(?h2, ?h2Index),
	?h1Index = ?h2Index.

ExceptionHandler_SameBlock_Repr(?handler, ?handler) :-
	isExceptionHandler(?handler),
	!ExceptionHandler_SameBlock_PartialOrder(_, ?handler).

ExceptionHandler_SameBlock_Repr(?handler, ?repr) :-
	ExceptionHandler_SameBlock_PartialOrder(?repr, ?handler),
	!ExceptionHandler_SameBlock_PartialOrder(_, ?repr).
.decl AllocatedObjectSupportsFinalize(?heap:HeapAllocation, ?inmethod:Method)
.decl OverridesFinalize(?class:Type)

AllocatedObjectSupportsFinalize(?heap, ?inmethod) :-
    AssignHeapAllocation(?heap, _, ?inmethod),
    HeapAllocation_Type(?heap, ?class),
    OverridesFinalize(?class).

OverridesFinalize(?class) :-
    MethodLookup("finalize", "void()", ?class, ?method),
    ?method != "<java.lang.Object: void finalize()>".


.decl MethodLookup(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)

.decl _MethodLookup_WithLen(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method, ?len:number)
.decl _MethodLookup_MoreThanOne(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType)
.decl _MethodLookup_ClassResolution(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)
.decl _MethodLookup_ClosestInterface(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)
.decl _MethodLookup_MultiClosestInterfaces(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType)
.decl _MethodLookup_ImpossibleClosest(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)


   
// Only one candidate
MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, _),
    !_MethodLookup_MoreThanOne(?simplename, ?descriptor, ?type).

// Mutliple candidates, the one defined in a class wins
MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_ClassResolution(?simplename, ?descriptor, ?type, ?method).

// Multiple candidates, none defined in a class, pick the closest in the hierarchy
MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method),
    !_MethodLookup_MultiClosestInterfaces(?simplename, ?descriptor, ?type).

// Multiple candidates, none define in a class, picke the closest that is not also higher in the hierarchy
// E.g. interface A, interface B extends A, class C implements B, A
// Pick the definition from B, though C also implements A.
MethodLookup(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method),
    !_MethodLookup_ImpossibleClosest(?simplename, ?descriptor, ?type, ?method).


_MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, 0) :-
    MethodImplemented(?simplename, ?descriptor, ?type, ?method).

_MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, n + 1) :-
    DirectSuperclass(?type, ?supertype),
    _MethodLookup_WithLen(?simplename, ?descriptor, ?supertype, ?method, n),
    !MethodImplemented(?simplename, ?descriptor, ?type, _).

_MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, n + 1) :-
    DirectSuperinterface(?type, ?supertype),
    _MethodLookup_WithLen(?simplename, ?descriptor, ?supertype, ?method, n),
    !MethodImplemented(?simplename, ?descriptor, ?type, _).

_MethodLookup_MoreThanOne(?simplename, ?descriptor, ?type) :-
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method1, _),
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method2, _),
    ?method1 != ?method2.

_MethodLookup_ClassResolution(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_MoreThanOne(?simplename, ?descriptor, ?type),
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, _),
    Method_DeclaringType(?method, ?supertype),
    isClassType(?supertype).

_MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method) :-
    _MethodLookup_MoreThanOne(?simplename, ?descriptor, ?type),
    ?minLen = min ?len : { _MethodLookup_WithLen(?simplename, ?descriptor, ?type, _, ?len) },
    _MethodLookup_WithLen(?simplename, ?descriptor, ?type, ?method, ?minLen),
    !_MethodLookup_ClassResolution(?simplename, ?descriptor, ?type, _).

_MethodLookup_MultiClosestInterfaces(?simplename, ?descriptor, ?type) :-
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method1),
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method2),
    ?method1 != ?method2.

_MethodLookup_ImpossibleClosest(?simplename, ?descriptor, ?type, ?method2) :-
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method1),
    _MethodLookup_ClosestInterface(?simplename, ?descriptor, ?type, ?method2),
    Method_DeclaringType(?method1, ?type1),
    Method_DeclaringType(?method2, ?type2),
    SubtypeOf(?type1, ?type2),
    ?type1 != ?type2.



   
.decl MethodImplemented(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)





   
.decl MethodOverridesOther(?methodSub:Method, ?methodSuper:Method)
MethodOverridesOther(?methSub, ?methSuper) :-
  SubtypeOf(?subtype, ?supertype),
  Method_DeclaringType(?methSuper, ?supertype),
  Method_SimpleName(?methSuper, ?simplename),
  Method_Descriptor(?methSuper, ?descriptor),
  MethodLookup(?simplename, ?descriptor, ?subtype, ?methSub),
  ?methSub != ?methSuper.


   
MethodLookup(?simplename, ?descriptor, ?arraytype, ?method) :-
    isArrayType(?arraytype),
    isType(?objectType),
    MethodImplemented(?simplename, ?descriptor, ?objectType, ?method),
    ?objectType = "java.lang.Object".

MethodImplemented(?simplename, ?descriptor, ?type, ?method) :-
    Method_SimpleName(?method, ?simplename),
    Method_Descriptor(?method, ?descriptor),
    Method_DeclaringType(?method, ?type),
    ! Method_Modifier("abstract", ?method).

// Covariant method resolution, used to "go to definition" in server mode. Also
// used by the standalone CHA script.
//
// Logic that finds overridden methods with covariant return types.
// Covariant methods are found locally in each class by matching
// bridge methods (generated by javac) with normal methods.

.decl _BridgeMethod(?bridge:Method, ?name:symbol, ?type:Type)
.decl MethodMightBeCovariantBridge(?bridge:Method, ?meth:Method)

_BridgeMethod(?bridge, ?name, ?type) :-
   Method_Modifier("bridge", ?bridge),
   Method_SimpleName(?bridge, ?name),
   Method_DeclaringType(?bridge, ?type),
   ?name != "<clinit>",
   ?name != "<init>".

MethodMightBeCovariantBridge(?bridge, ?meth) :-
   Method_SimpleName(?meth, ?name),
   _BridgeMethod(?bridge, ?name, ?bridgetype),
   Method_DeclaringType(?meth, ?bridgetype),
   !Method_Modifier("bridge", ?meth).

//// Greatly suboptimal this way.
// MethodMightBeCovariantBridge(?bridge, ?meth) :-
//    Method_Modifier("bridge", ?bridge),
//    Method_SimpleName(?bridge, ?sameName),
//    ?sameName != "<clinit>",
//    ?sameName != "<init>",
//    Method_SimpleName(?meth, ?sameName),
//    !Method_Modifier("bridge", ?meth),
//    Method_DeclaringType(?bridge, ?type),
//    Method_DeclaringType(?meth, ?type).

.decl MethodNotCovariantBridge(?meth1:Method, ?meth2:Method)

// REVIEW: using _Var_Type instead of Var_Type to avoid
// recursion-through-negation.
MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, ?formal1),
   _Var_Type(?formal1, ?type1),
   FormalParam(?sameIndex, ?meth2, ?formal2),
   _Var_Type(?formal2, ?type2),
   ?type1 != ?type2.

MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth1, _),
   !FormalParam(?sameIndex, ?meth2, _).

MethodNotCovariantBridge(?meth1, ?meth2) :-
   MethodMightBeCovariantBridge(?meth1, ?meth2),
   FormalParam(?sameIndex, ?meth2, _),
   !FormalParam(?sameIndex, ?meth1, _).

.decl Method_CovariantBridge(?bridge:Method, ?cometh:Method)

Method_CovariantBridge(?bridge, ?cometh) :-
   MethodMightBeCovariantBridge(?bridge, ?cometh),
   !MethodNotCovariantBridge(?bridge, ?cometh),
   Method_ReturnType(?bridge, ?retType),
   Method_ReturnType(?cometh, ?coRetType),
   SubtypeOfDifferent(?coRetType, ?retType).

.decl MethodImplementedModuloCovariance(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)

// Superset of MethodImplemented, also containing covariant methods.
MethodImplementedModuloCovariance(?name, ?descriptor, ?type, ?method) :-
    MethodImplemented(?name, ?descriptor, ?type, ?method).
MethodImplementedModuloCovariance(?name, ?descriptor, ?type, ?comethod) :-
    MethodImplementedModuloCovariance(?name, _, ?type, ?comethod),
    Method_CovariantBridge(?method, ?comethod),
    Method_SimpleName(?method, ?name),
    Method_Descriptor(?method, ?descriptor).


.decl ResolveInvocation(?type:Type, ?invocation:MethodInvocation, ?tomethod:Method)
//.output ResolveInvocation

// Auxiliary
.decl VirtualMethodInvocation_BaseType(?invocation:MethodInvocation, ?type:Type)
VirtualMethodInvocation_BaseType(?invocation, ?basetype) :-
    VirtualMethodInvocation_Base(?invocation, ?base),
    Var_Type(?base, ?basetype).

ResolveInvocation(?type, ?invocation, ?tomethod) :-
    VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
    VirtualMethodInvocation_Descriptor(?invocation, ?descriptor),
    VirtualMethodInvocation_BaseType(?invocation, ?basetype),
    SubtypeOf(?type, ?basetype),
    MethodLookup(?simplename, ?descriptor, ?type, ?tomethod).

ResolveInvocation(?basetype, ?invocation, ?tomethod) :-
    SuperMethodInvocation_SimpleName(?invocation, ?simplename),
    SuperMethodInvocation_Descriptor(?invocation, ?descriptor),
    SuperMethodInvocation_Base(?invocation, ?base),
    Var_Type(?base, ?basetype),
    DirectSuperclass(?basetype, ?supertype),
    MethodLookup(?simplename, ?descriptor, ?supertype, ?tomethod).


.decl ConcreteMethodDeclared(?meth:Method, ?class:ClassType)
ConcreteMethodDeclared(?meth, ?class) :-
  isClassType(?class),
  Method_DeclaringType(?meth, ?class),
  !Method_Modifier("abstract", ?meth).

.decl MethodDeclaredOrInherited(?meth:Method, ?class:ReferenceType)
MethodDeclaredOrInherited(?meth, ?class) :-
//  isClassType(?class),
  Method_DeclaringType(?meth, ?class).

// This keeps the superclass signature of the method. Does not guarantee
// there is a concrete implementation until we do "MethodLookup".
MethodDeclaredOrInherited(?meth, ?class) :-
  MethodDeclaredOrInherited(?meth, ?superClass),
  DirectSuperclass(?class, ?superClass).

// Inherit default methods from interfaces.
MethodDeclaredOrInherited(?meth, ?class) :-
  MethodDeclaredOrInherited(?meth, ?superInterface),
  !Method_Modifier("abstract", ?meth),
  DirectSuperinterface(?class, ?superInterface).

// REVIEW: a little wasteful, but guessing it doesn't matter.
.decl MethodsOfSameOrSuperType(?method1:Method, ?method2:Method)
MethodsOfSameOrSuperType(?method1, ?method2) :-
  MethodDeclaredOrInherited(?method1, ?class),
  MethodDeclaredOrInherited(?method2, ?class).

.decl MethodsOfSameNonSDKType(?method1:Method, ?method2:Method, ?class:Type)
MethodsOfSameNonSDKType(?method1, ?method2, ?class) :-
  Method_DeclaringType(?method1, ?class),
  !match("java.*", ?class),
  !match("sun.*", ?class),
  Method_DeclaringType(?method2, ?class).


.decl Superinterface(?k:InterfaceType, ?c:ReferenceType)


   
Superinterface(?k, ?c) :-
    DirectSuperinterface(?c, ?k).


   
Superinterface(?k, ?c) :-
    DirectSuperinterface(?c, ?j),
    Superinterface(?k, ?j).


   
Superinterface(?k, ?c) :-
    DirectSuperclass(?c, ?super),
    Superinterface(?k, ?super).


   
.decl DirectSubclass(?a:ClassType, ?c:ClassType)


   
.decl Subclass(?c:ClassType, ?a:ClassType)


   
.decl Superclass(?c:ClassType, ?a:ClassType)

DirectSubclass(?a, ?c) :-
    DirectSuperclass(?a, ?c).


   
Subclass(?c, ?a) :-
    DirectSubclass(?a, ?c).


   
Subclass(?c, ?a) :-
    Subclass(?b, ?a),
    DirectSubclass(?b, ?c).


   
Superclass(?c, ?a) :-
    Subclass(?a, ?c).


.decl SubtypeOf(?subtype:Type, ?type:Type)
.decl SupertypeOf(?supertype:Type, ?type:Type)
.decl Unsubclassable(?type:ReferenceType)
.decl Subclassable(?type:ReferenceType)
.decl SubtypeOfDifferent(?subtype:Type, ?type:Type)
.decl ClassConstructor(?method:Method, ?type:ClassType)


   
SupertypeOf(?s, ?t) :-
    SubtypeOf(?t, ?s).



   
SubtypeOf(?s, ?s) :-
    isClassType(?s).

SubtypeOf(?s, ?t) :-
    Subclass(?t, ?s).


   
SubtypeOf(?s, ?t) :-
    isClassType(?s),
    Superinterface(?t, ?s).


   
SubtypeOf(?s, ?t) :-
    isInterfaceType(?s),
    isType(?t),
    ?t = "java.lang.Object".


   
SubtypeOf(?s, ?s) :-
    isInterfaceType(?s).

SubtypeOf(?s, ?t) :-
    isInterfaceType(?s),
    Superinterface(?t, ?s).


   
SubtypeOf(?s, ?t) :-
    isArrayType(?s),
    isType(?t),
    ?t = "java.lang.Object".


   
SubtypeOf(?s, ?t) :-
    isArrayType(?s),
    isArrayType(?t),
    ComponentType(?s, ?sc),
    ComponentType(?t, ?sc),
    isPrimitiveType(?sc).



   
SubtypeOf(?s, ?t) :-
    ComponentType(?s, ?sc),
    ComponentType(?t, ?tc),
    isReferenceType(?sc),
    isReferenceType(?tc),
    SubtypeOf(?sc, ?tc).


   
SubtypeOf(?s, ?t) :-
    isArrayType(?s),
    isInterfaceType(?t),
    isType(?t),
    ?t = "java.lang.Cloneable".

SubtypeOf(?s, ?t) :-
    isArrayType(?s),
    isInterfaceType(?t),
    isType(?t),
    ?t = "java.io.Serializable".



   
SubtypeOf(?s, ?t) :-
    Type_null(?s),
    isReferenceType(?t),
    ?t != ?s.

// Disable when performing type inference for Dalvik (Tsatiris)


SubtypeOf(?s, ?t) :-
    Type_float(?s),
    Type_double(?t).

SubtypeOf(?s, ?t) :-
    Type_long(?s),
    Type_float(?t).

SubtypeOf(?s, ?t) :-
    Type_int(?s),
    Type_long(?t).

SubtypeOf(?s, ?t) :-
    Type_char(?s),
    Type_int(?t).

SubtypeOf(?s, ?t) :-
    Type_short(?s),
    Type_int(?t).

SubtypeOf(?s, ?t) :-
    Type_byte(?s),
    Type_short(?t).



   
SubtypeOf(?t, ?t) :-
    isType(?t).


// SubtypeOf minus the identity

SubtypeOfDifferent(?s, ?t) :-
    SubtypeOf(?s, ?t),
    ?s != ?t.


// Extra logic for determining whether it is possible to subclass a type (based on Oracle Souffle)

Unsubclassable("java.lang.ClassLoader").
Unsubclassable("java.lang.SecurityManager").


// Subclassable

Subclassable(?type) :-
    ClassModifier("public", ?type),
    ! ClassModifier("final", ?type),
    ClassConstructor(?method, ?type),
    Method_Modifier("public", ?method),
    ! Unsubclassable(?type).

Subclassable(?type) :-
    ClassModifier("public", ?type),
    ! ClassModifier("final", ?type),
    ClassConstructor(?method, ?type),
    Method_Modifier("protected", ?method),
    ! Unsubclassable(?type).

ClassConstructor(method, type) :-
    isClassType(type),
    MethodLookup(_, _, type, method),
    isMethod(method),
    match(".*<init>.*", method).

// ?class is implemented/extended by ?subClass
.decl Class_InterestingSubtype(?class:ReferenceType, ?subClass:ReferenceType)
.decl _Valid_Type(?type:ReferenceType)

Class_InterestingSubtype(?class, ?subClass) :-
  SubtypeOf(?subClass, ?class),
  _Valid_Type(?class),
  _Valid_Type(?subClass).

_Valid_Type(?type) :-
  isReferenceType(?type),
  (isClassType(?type) ; isInterfaceType(?type)).

isIntegerType(?type) :-
  Type_byte(?type) ; Type_short(?type) ; Type_int(?type) ; Type_long(?type).

// A cross-product of method name candidates and method signature candidates.
.decl PossibleNativeCodeTargetMethod(?method:Method, ?function:symbol, ?file:symbol)

// Pair all strings (or only strings in known functions in precise mode).
PossibleNativeCodeTargetMethod(?method, ?function, ?file) :-
  _NativeMethodTypeCandidate(?file, ?function, ?descriptor, _),
  _NativeNameCandidate(?file, ?function, ?name, _),

  Method_SimpleName(?method, ?name),
  Method_JVMDescriptor(?method, ?descriptor).

// The distance between string xrefs in the code. This should be big
// enough to catch strings used together in major calling conventions.


// If xref information exists, pair strings that are referenced together in code.
PossibleNativeCodeTargetMethod(?method, "<<UNKNOWN>>", ?file) :-
  _NativeMethodTypeCandidate(?file, ?function, ?descriptor, _),
  _NativeNameCandidate(?file, ?function, ?name, _),
  _NativeXRef(?descriptor, ?file, _, ?descriptorRefAddr),
  _NativeXRef(?name, ?file, _, ?nameRefAddr),
  Method_SimpleName(?method, ?name),
  Method_JVMDescriptor(?method, ?descriptor),
  (?nameRefAddr - ?descriptorRefAddr) <= 15,
  (?descriptorRefAddr - ?nameRefAddr) <= 15 .

.decl PossibleNativeCodeTargetMethodLocalized(?method:Method, ?function:symbol, ?file:symbol)

PossibleNativeCodeTargetMethodLocalized(?method, ?function, ?file) :-
  PossibleNativeCodeTargetMethod(?method, ?function, ?file),
  ?function != "-".

.decl OverloadedJNIMethod(?javaMethod:Method, ?type:ReferenceType, ?name:symbol, ?descriptor:symbol)

OverloadedJNIMethod(?javaMethod, ?type, ?name, ?descriptor) :-
  Method_Modifier("native", ?javaMethod),
  Method_SimpleName(?javaMethod, ?name),
  Method_Descriptor(?javaMethod, ?descriptor),
  Method_DeclaringType(?javaMethod, ?type),
  MethodLookup(?name, _, ?type, ?method1),
  MethodLookup(?name, _, ?type, ?method2),
  ?method1 != ?method2.

// A mapping between a native Java method and a JNI function. This
// does not capture the case of using the runtime's RegisterNatives()
// function to register native functions with arbitrary names. For
// example, the "crazy linker" used on Android, registers native
// methods: https://chromium.googlesource.com/chromium/src/+/master/docs/android_native_libraries.md
.decl JNIMethod_NativeId(?javaMethod:Method, ?nativeId:symbol)

// Non-overloaded native method (default, always generated).
JNIMethod_NativeId(?javaMethod, ?nativeId) :-
  _NativeMethodId(?javaMethod, ?nativeId),
  isMethod(?javaMethod).

// Overloaded native method, use computed name as prefix (see JNI spec).
JNIMethod_NativeId(?javaMethod, ?nativeId) :-
  OverloadedJNIMethod(?javaMethod, _, _, ?descriptor),
  _NativeMethodId(?javaMethod, ?nativeIdBase),
  ?nativeId = cat(?nativeIdBase, cat("__", ?descriptor)).




.decl AnyMainMethodDeclaration(?method:Method, ?type:ClassType)
AnyMainMethodDeclaration(?method, ?type) :-
   Method_DeclaringType(?method, ?type),
   Method_SimpleName(?method, "main"),
   Method_Descriptor(?method, "void(java.lang.String[])"),
   Method_Modifier("public", ?method),
   Method_Modifier("static", ?method).

.decl MainMethodDeclaration(?method:Method)

MainMethodDeclaration(?method) :-

  // Use input facts for "main" methods.
  MainClass(?type),

  AnyMainMethodDeclaration(?method, ?type).



}

.init basic = Basic


.decl Method_FirstInstruction(?method:Method, ?insn:Instruction)
.decl OptInstructionFromMethodIndex(?method:Method, ?index:number, ?insn:Instruction)
.decl Instruction_Next(?i:Instruction, ?next:Instruction)
.decl Instruction_Prev(?i:Instruction, ?prev:Instruction)
.decl JumpTarget(?insn:Instruction, ?prev:Instruction)

// Making explicit, so it can be negated.
.decl IsJumpTarget(?insn:Instruction)
.decl ExceptionHandlerFirstInstruction(?insn:Instruction)
.decl FallThrough(?insn:Instruction)
.decl BasicBlockBegin(?insn:Instruction)
.decl BasicBlockHead(?insn:Instruction, ?headInsn:Instruction)
.decl BasicBlockTail(?headInsn:Instruction, ?tailInsn:Instruction)
.decl BasicBlockEnd(?insn:Instruction)
.decl UnconditionalControlTransfer(?insn:Instruction)

// This is almost but not really a "may" relation for successor
// instructions. It does not include the targets of throw
// instructions. Hence the predicate name, meant to remind users that
// they should always check if the instruction is the beginning of
// an exception handler.
.decl MaySuccessorModuloThrow(?next:Instruction, ?prev:Instruction)
.decl MayPredecessorModuloThrow(?prev:Instruction, ?next:Instruction)

// Same concept for basic blocks. Reduces the cost significantly, since
// subsequent computation is quadratic.
.decl MaySuccessorBBModuloThrow(?next:Instruction, ?prev:Instruction)
.decl MayPredecessorBBModuloThrow(?prev:Instruction, ?next:Instruction)

// The Dominates relation is defined on basic blocks,
// represented by their first instruction (head). Defining
// a dense quadratic relation, like Dominates, on individual
// instructions was hugely expensive.

// To get to ?insn, we need to have gone through ?dominator
.decl Dominates(?dominator:Instruction, ?insn:Instruction)

// ?insn dominates its predecessor. Must be head of basic block
// (head of a loop).
.decl DominatesItsPredecessorInstruction(?prevInsn:Instruction, ?insn:Instruction)

// A generally useful concept. Includes the case of both being in the
// same basic block.
.decl DominatesItsSuccessorInstruction(?insn:Instruction, ?prevInsn:Instruction)

// Phi Nodes Definition. If we have SSA input, then any multiple
// assignments to the same var are because of a Phi node. In fact,
// these will also be consecutive.
.decl NextInSamePhiNode(?insn1:Instruction, ?insn2:Instruction)
.decl PhiNodeHead(?insn:Instruction, ?headInsn:Instruction)


// Just inverting for efficiency.
.decl InstructionInPhiNode(?insn:Instruction, ?headInsn:Instruction)

// There may be multiple return instructions. This is a pain,
// since they also represent merges of control- and data-flow.
// We often need to define "forall" behavior over them.
.decl NextReturn(?insn1:Instruction, ?insn2:Instruction)



Method_FirstInstruction(?method, ?insn) :-
   Instruction_Method(?insn, ?method),
   !Instruction_Prev(?insn, _),
   !IsJumpTarget(?insn).

OptInstructionFromMethodIndex(?method, ?index, ?insn) :-
   Instruction_Method(?insn, ?method),
   Instruction_Index(?insn, ?index).

Instruction_Next(?insn, ?next) :-
   Instruction_Method(?insn, ?inMethod),
   Instruction_Index(?insn, ?i),
   OptInstructionFromMethodIndex(?inMethod, ?i + 1, ?next).

Instruction_Prev(?insn, ?prev) :-
   Instruction_Method(?insn, ?inMethod),
   Instruction_Index(?insn, ?i),
   OptInstructionFromMethodIndex(?inMethod, ?i - 1, ?prev).

JumpTarget(?insn, ?goto) :-
   Goto_Target(?goto, ?targetIndex),
   Instruction_Method(?goto, ?gotoMethod),
   OptInstructionFromMethodIndex(?gotoMethod, ?targetIndex, ?insn).
JumpTarget(?insn, ?if) :-
   If_Target(?if, ?targetIndex),
   Instruction_Method(?if, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).
JumpTarget(?insn, ?sw) :-
   (Switch_Target(?sw, _, ?targetIndex) ; Switch_DefaultTarget(?sw, ?targetIndex)),
   Instruction_Method(?sw, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).

IsJumpTarget(?insn) :-
   JumpTarget(?insn, _).

ExceptionHandlerFirstInstruction(?insn) :-
   ExceptionHandler_Index(?handler, ?index),
   ExceptionHandler_Method(?handler, ?method),
   OptInstructionFromMethodIndex(?method, ?index, ?insn).

FallThrough(?insn) :-
   isIf_Insn(?if),
   Instruction_Next(?if, ?insn).
// REVIEW: The next two shouldn't matter much since without a label the
// fallthrough instruction would be dead code OR the beginning of an
// exception handler. The latter is handled specially. For the former, we
// consider such dead code to start a new BB, so that it doesn't accidentally
// get considered a continuation of the previous BB.
FallThrough(?insn) :-
   isReturnInstruction(?ret),
   Instruction_Next(?ret, ?insn).
FallThrough(?insn) :-
   isThrow_Insn(?throw),
   Instruction_Next(?throw, ?insn).


// First instruction of a method is a basic block beginning
BasicBlockBegin(?insn) :-
   OptInstructionFromMethodIndex(_, 1, ?insn).
BasicBlockBegin(?insn) :-
   ExceptionHandlerFirstInstruction(?insn).
BasicBlockBegin(?insn) :-
   JumpTarget(?insn, _).
BasicBlockBegin(?insn) :-
   FallThrough(?insn).

.decl NextInSameBasicBlock(?insn:Instruction, ?next:Instruction)
NextInSameBasicBlock(?insn, ?next) :-
   Instruction_Next(?insn, ?next),
   !BasicBlockBegin(?next).

.decl PrevInSameBasicBlock(?insn:Instruction, ?prev:Instruction)
PrevInSameBasicBlock(?insn, ?prev) :-
   NextInSameBasicBlock(?prev, ?insn).

BasicBlockHead(?insn, ?insn) :-
   BasicBlockBegin(?insn).
BasicBlockHead(?insn, ?headInsn) :-
   BasicBlockHead(?prev, ?headInsn),
   NextInSameBasicBlock(?prev, ?insn).

BasicBlockTail(?headInsn, ?tailInsn) :-
   BasicBlockHead(?tailInsn, ?headInsn),
   !NextInSameBasicBlock(?tailInsn, _).

BasicBlockEnd(?insn) :- BasicBlockTail(_, ?insn).

UnconditionalControlTransfer(?insn) :-
   isGoto_Insn(?insn) ;
   isSwitch_Insn(?insn) ;
   isReturnInstruction(?insn) ;
   isThrow_Insn(?insn).

MaySuccessorModuloThrow(?next, ?prev) :-
   JumpTarget(?next, ?prev).
MaySuccessorModuloThrow(?next, ?insn) :-
   Instruction_Next(?insn, ?next),
   !UnconditionalControlTransfer(?insn).

MayPredecessorModuloThrow(?prev, ?next) :-
   MaySuccessorModuloThrow(?next, ?prev).

MaySuccessorBBModuloThrow(?next, ?prev) :-
   MaySuccessorModuloThrow(?next, ?prevEnd),
   BasicBlockEnd(?prevEnd),
   BasicBlockBegin(?next),
   BasicBlockHead(?prevEnd, ?prev).

MayPredecessorBBModuloThrow(?prev, ?next) :-
   MaySuccessorBBModuloThrow(?next, ?prev).

// The Dominates relation is defined on basic blocks,
// represented by their first instruction (head). Defining
// a dense quadratic relation, like Dominates, on individual
// instructions was hugely expensive.

// Dominates(?dominator, ?insn): To get to ?insn, we need to have gone
// through ?dominator
Dominates(?dominator, ?insn) :-
   SameMethodBBHeads(?dominator, ?insn),
   !DoesNotDominate(?dominator, ?insn).

// Either the first instruction...
.decl CFGRoot(?insn:Instruction, ?method:Method)
CFGRoot(?insn, ?method) :-
   OptInstructionFromMethodIndex(?method, 1, ?insn).
// or... could also be beginning of exception handler
CFGRoot(?insn, ?method) :-
   BBHeadInMethod(?insn, ?method),
   !(MayPredecessorBBModuloThrow(_, ?insn)).

.decl ExistsMayPredecessorBBModuloThrow(?insn:Instruction)
ExistsMayPredecessorBBModuloThrow(?insn) :-
   MayPredecessorBBModuloThrow(_, ?insn).

// DoesNotDominate(?dominatorCandidate, ?insn): ?insn (which is a
// basic block head) is NOT dominated by ?dominatorCandidate
.decl DoesNotDominate(?dominatorCandidate:Instruction, ?insn:Instruction)
DoesNotDominate(?dominatorCandidate, ?insn) :-
   BBHeadInMethod(?dominatorCandidate, ?method),
   CFGRoot(?insn, ?method),
   ?dominatorCandidate != ?insn.

DoesNotDominate(?dominatorCandidate, ?insn) :-
   DoesNotDominate(?dominatorCandidate, ?otherInsn),
   MaySuccessorBBModuloThrow(?insn, ?otherInsn),
   ?insn != ?dominatorCandidate.


// ?insn dominates its predecessor. ?insn must be the head of a basic
// block (head of a loop).
DominatesItsPredecessorInstruction(?prevInsn, ?insn) :-
   JumpTarget(?insn, ?prevInsn),
   BasicBlockHead(?prevInsn, ?prevInsnHead),
   (?insn = ?prevInsnHead;
    Dominates(?insn, ?prevInsnHead)).

// KF: Currently this rules is not being used at all.
// // Includes the case of both being in the same basic block.
// DominatesItsSuccessorInstruction(?insn, ?prevInsn) :-
//    MaySuccessorModuloThrow(?insn, ?prevInsn),
//    BasicBlockHead[?prevInsn] = ?prevInsnHead,
//    BasicBlockHead[?insn] = ?insnHead,
//    (?insnHead = ?prevInsnHead;
//     Dominates(?prevInsnHead, ?insnHead)).


NextInSamePhiNode(?insn, ?nextInsn) :-
   isAssignLocal_Insn(?insn),
   AssignInstruction_To(?insn, ?var),
   Instruction_Next(?insn, ?nextInsn),
   isAssignLocal_Insn(?nextInsn),
   AssignInstruction_To(?nextInsn, ?var).

PhiNodeHead(?nextInsn, ?insn),
PhiNodeHead(?insn, ?insn) :-
   NextInSamePhiNode(?insn, ?nextInsn),
   Instruction_Prev(?insn, ?prevInsn),
   !NextInSamePhiNode(?prevInsn, ?insn).

PhiNodeHead(?nextInsn, ?insn),
PhiNodeHead(?insn, ?insn) :-
   NextInSamePhiNode(?insn, ?nextInsn),
   !Instruction_Prev(?insn, _).

PhiNodeHead(?nextInsn, ?headInsn) :-
   PhiNodeHead(?phiInsn, ?headInsn),
   NextInSamePhiNode(?phiInsn, ?nextInsn).

// Just inverting for efficiency.
InstructionInPhiNode(?insn, ?headInsn) :-
   PhiNodeHead(?insn, ?headInsn).


///// auxiliary quick-and-dirty predicates
.decl OptReturnInsn(?insn:Instruction, ?method:Method)
OptReturnInsn(?insn, ?method) :-
   isReturnInstruction(?insn),
   Instruction_Method(?insn, ?method).

.decl HigherReturnIndex(?insn:Instruction, ?indexHigher:number)
HigherReturnIndex(?insn, ?indexHigher) :-
   OptReturnInsn(?insn, ?method),
   OptReturnInsn(?insnHigher, ?method),
   Instruction_Index(?insnHigher, ?indexHigher),
   Instruction_Index(?insn, ?index),
   ?index < ?indexHigher.

.decl NextReturnIndex(?returnInsn:Instruction, ?nextReturnIndex:number)
NextReturnIndex(?returnInsn, ?nextReturnIndex) :-
   isInstruction(?returnInsn), 
   ?nextReturnIndex = min ?index : HigherReturnIndex(?returnInsn, ?index).

NextReturn(?returnInsn, ?nextReturnInsn) :-
   NextReturnIndex(?returnInsn, ?nextReturnIndex),
   Instruction_Method(?returnInsn, ?meth),
   OptInstructionFromMethodIndex(?meth, ?nextReturnIndex, ?nextReturnInsn).

.decl ExistsPreviousReturn(?insn:Instruction)
ExistsPreviousReturn(?insn) :-
   NextReturn(_, ?insn).

.decl BBHeadInMethod(?insn:Instruction, ?method:Method)
BBHeadInMethod(?insn, ?method) :-
   BasicBlockBegin(?insn),
   Instruction_Method(?insn, ?method).

.decl SameMethodBBHeads(?insn1:Instruction, ?insn2:Instruction)
SameMethodBBHeads(?insn1, ?insn2) :-
   BBHeadInMethod(?insn1, ?method),
   BBHeadInMethod(?insn2, ?method).

// Auxiliaries...

// Quadratic, but doesn't matter, since it's so local and only
// defined on basic blocks.
.decl PredecessorBBsToSameBB(?insn:Instruction, ?prev1:Instruction, ?prev2:Instruction)
PredecessorBBsToSameBB(?insn, ?prev1, ?prev2) :-
   MayPredecessorBBModuloThrow(?prev1, ?insn),
   MayPredecessorBBModuloThrow(?prev2, ?insn),
   ?prev1 != ?prev2.

.decl LargerPredecessorIndexToSameBB(?insn:Instruction, ?indexLarge:number, ?prevSmall:Instruction)
LargerPredecessorIndexToSameBB(?insn, ?indexLarge, ?prevSmall) :-
   PredecessorBBsToSameBB(?insn, ?prevLarge, ?prevSmall),
   Instruction_Index(?prevLarge, ?indexLarge),
   Instruction_Index(?prevSmall, ?indexSmall),
   ?indexLarge > ?indexSmall.

.decl NextPredecessorIndexToSameBB(?insn:Instruction, ?prev:Instruction, ?indexNext:number)
.output NextPredecessorIndexToSameBB
NextPredecessorIndexToSameBB(?insn, ?prev, ?indexNext) :-
   LargerPredecessorIndexToSameBB(?insn, _, ?prev),
   ?indexNext = min ?index : LargerPredecessorIndexToSameBB(?insn, ?index, ?prev).

.decl NextPredecessorToSameBB(?insn:Instruction, ?pred:Instruction, ?nextPred:Instruction)
NextPredecessorToSameBB(?insn, ?pred, ?nextPred) :-
   NextPredecessorIndexToSameBB(?insn, ?pred, ?indexNext),
   Instruction_Method(?insn, ?method),
   OptInstructionFromMethodIndex(?method, ?indexNext, ?nextPred).

.decl PreviousPredecessorToSameB(?insn:Instruction, ?nextPred:Instruction, ?prevPred:Instruction)
PreviousPredecessorToSameB(?insn, ?nextPred, ?prevPred) :-
   NextPredecessorToSameBB(?insn, ?prevPred, ?nextPred).

.decl ExistsPreviousPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)
ExistsPreviousPredecessorToSameBB(?pred, ?insn) :-
   NextPredecessorToSameBB(?insn, _, ?pred).


// Same concepts as above, but for non-dominated (shortened to "NonDom")
// predecessors
.decl NonDomPredecessorBBsToSameBB(?insn:Instruction, ?prev1:Instruction, ?prev2:Instruction) 
NonDomPredecessorBBsToSameBB(?insn, ?prev1, ?prev2) :-   
   MayPredecessorBBModuloThrow(?prev1, ?insn),
   MayPredecessorBBModuloThrow(?prev2, ?insn),
   BasicBlockTail(?prev1, ?prevTail1),
   BasicBlockTail(?prev2, ?prevTail2),
   !DominatesItsPredecessorInstruction(?prevTail1, ?insn),
   !DominatesItsPredecessorInstruction(?prevTail2, ?insn),
   ?prev1 != ?prev2.

.decl LargerNonDomPredecessorIndexToSameBB(?insn:Instruction, ?indexLarge:number, ?prevSmall:Instruction)
LargerNonDomPredecessorIndexToSameBB(?insn, ?indexLarge, ?prevSmall) :-
   NonDomPredecessorBBsToSameBB(?insn, ?prevLarge, ?prevSmall),
   Instruction_Index(?prevLarge, ?indexLarge),
   Instruction_Index(?prevSmall, ?indexSmall),
   ?indexLarge > ?indexSmall.

.decl NextNonDomPredecessorIndexToSameBB(?insn:Instruction, ?prev:Instruction, ?indexNext:number)
.output NextNonDomPredecessorIndexToSameBB
NextNonDomPredecessorIndexToSameBB(?insn, ?prev, ?indexNext) :-
   LargerNonDomPredecessorIndexToSameBB(?insn, _, ?prev),
   ?indexNext = min ?index : LargerNonDomPredecessorIndexToSameBB(?insn, ?index, ?prev).

.decl NextNonDomPredecessorToSameBB(?insn:Instruction, ?pred:Instruction, ?nextPred:Instruction)
NextNonDomPredecessorToSameBB(?insn, ?pred, ?nextPred) :-
   NextNonDomPredecessorIndexToSameBB(?insn, ?pred, ?indexNext),
   Instruction_Method(?insn, ?method),
   OptInstructionFromMethodIndex(?method, ?indexNext, ?nextPred).

.decl PreviousNonDomPredecessorToSameBB(?insn:Instruction, ?nextPred:Instruction, ?prevPred:Instruction) 
PreviousNonDomPredecessorToSameBB(?insn, ?nextPred, ?prevPred) :-
   NextNonDomPredecessorToSameBB(?insn, ?prevPred, ?nextPred).

.decl ExistsPreviousNonDomPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)
ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn) :-
   NextNonDomPredecessorToSameBB(?insn, _, ?pred).


// Context-insensitive pointer analysis with on-the-fly call graph discovery















// Copy of MockValueConsMacro but with proper component qualifers.












// Android-specific macro to qualify unqualified types in layout controls.
// Heuristic: if the name is unqualified, it may come from android.view or
// android.widget ("Android Programming: The Big Nerd Ranch Guide", chapter 32).








.comp AbstractContextSensitivity<Configuration> {


.decl ClassInitializer(?type:Type, ?method:Method)

.decl InitializedClass(?classOrInterface:Type)


.decl ImplicitReachable(?sig:Method)

.decl ApplicationEntryPoint(?meth:Method)


.decl ForcedReachable(?method:Method)

.decl RunningThread(?hctx:configuration.HContext, ?value:Value)

.decl ReachableCurrentThreadInvocation(?callerCtx:configuration.Context, ?local:Var)

.decl FakeInvocation_ThreadGroupInit(?invo: MethodInvocation)

.decl FakeInvocation_MainThreadInit(?invo: MethodInvocation)

.decl FakeInvocation_SystemThreadGroupInit(?invo: MethodInvocation)



// Basic "spec" relation: method returns mock value (of some type).
.decl MockedMethodReturns(?method:Method, ?alloc:HeapAllocation, ?type:ReferenceType)
.output MockedMethodReturns



// Model DriverManager.getConnection().
MockedMethodReturns(?method, ?value, ?type) :-
  ?method = "<java.sql.DriverManager: java.sql.Connection getConnection(java.lang.String,java.util.Properties,java.lang.Class)>",
  basic.SubtypeOf(?type, "java.sql.Connection"),
  isClassType(?type),
  ?value = cat("<mock SQL connection of type ", cat(?type, ">")).











.decl StringFactoryVar(?var:Var)
.decl StringFactoryVarPointsTo(?factoryHctx:configuration.HContext, ?factoryValue:Value, ?ctx:configuration.Context, ?var:Var)



.decl AssignInvokedynamic(?insn:DynamicMethodInvocation_Insn, ?ret:Var, ?value:Value, ?type:Type)
.output AssignInvokedynamic

// Issue #46: Java 9+ string concatenation. If "x = makeConcatWithConstants(...)",
// then make "x" point to a mock string concatenation result.
// TODO: reflection substring analysis can be informed from the method arguments.
AssignInvokedynamic(?insn, ?ret, ?heap, "java.lang.String"),
VarPointsTo(?hctx, ?heap, ?ctx, ?ret),
Value_isMock(?heap), isValue(?heap), Value_Type(?heap,  "java.lang.String"), Value_DeclaringType(?heap, "java.lang.Object") :-
  DynamicMethodInvocation_Bootstrap(?insn, "<java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])>"),
  Instruction_Method(?insn, ?method),
  ReachableContext(?ctx, ?method),
  isImmutableHContext(?hctx),
  AssignReturnValue(?insn, ?ret),
  ?heap = "<mock string concatenation result>".





   

.decl Instruction_Throws(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?insn:Instruction)
.decl ThrowPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?method:Method)

Instruction_Throws(?hctx, ?value, ?ctx, ?insn) :-
  Throw(?insn, ?var),
  VarPointsTo(?hctx, ?value, ?ctx, ?var).

Instruction_Throws(?hctx, ?value, ?callerCtx, ?invocation) :-
  ThrowPointsTo(?hctx, ?value, ?calleeCtx, ?tomethod),
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod).
 .plan 1:(2,1)


   
ThrowPointsTo(?hctx, ?value, ?ctx, ?method) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Instruction_Method(?insn, ?method),
  !basic.ExceptionHandler_InRange(_, ?insn).

ThrowPointsTo(?hctx, ?value, ?ctx, ?method) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Value_Type(?value, ?valueType),
  Instruction_Method(?insn, ?method),
  basic.ExceptionHandler_SameInsn_Repr(?insn, ?repr),
  basic.ExceptionHandler_SameBlock_Repr(?repr, ?block),
  !basic.ExceptionHandler_TypeIsCaught(?valueType, ?block).
//// Certainly Value_Type is now part of the main SCC for much more
//// than info-flow. Still, might this fail for some settings?
//#ifdef minimal
 .plan 1:(2,1,3,4,5)
//#endif

VarPointsTo(?hctx, ?value, ?ctx, ?param) :-
  Instruction_Throws(?hctx, ?value, ?ctx, ?insn),
  Value_Type(?value, ?valueType),
  basic.ExceptionHandler_InRange(?handler, ?insn),
  ExceptionHandler_Type(?handler, ?handlerType),
  basic.SubtypeOf(?valueType, ?handlerType),
  ConcreteClass(?valueType), // filtering null_type
  ExceptionHandler_FormalParam(?handler, ?param),
  !basic.ExceptionHandler_Impossible(?valueType, ?handler, ?insn).
//// See previous rule
//#ifdef minimal
 .plan 1:(2,1,3,4,5,6,7)
//#endif






   
.type MethodType = Value
.type ParamTypes = symbol
.decl MethodType_ParamType(?mt:MethodType, ?index:number, ?pType:Type)
.decl MethodType_ParamTypes(?mt:MethodType, ?paramTypes:ParamTypes)
.decl MethodType_ReturnType(?mt:MethodType, ?retType:Type)
.decl MethodType_Arity(?mt:MethodType, ?arity:number)

// Relation to mark all method types created initially.
.decl isInitialMethodType(?mt:MethodType)

// For every method type constant in the constant pool, create a method type.
MethodType_ParamType(?mt, ?idx, ?type)  :- _MethodTypeConstantParam(?mt, ?idx, ?type).
MethodType_Arity(?mt, ?arity)           :- MethodTypeConstant_Arity(?mt, ?arity).
MethodType_ReturnType(?mt, ?retType)    :- MethodTypeConstant_ReturnType(?mt, ?retType).
MethodType_ParamTypes(?mt, ?paramTypes) :- MethodTypeConstant_ParamTypes(?mt, ?paramTypes).






                                                               

HeapAllocation_ContextInsensitive(?heap) :-
  isMethodHandleConstant(?heap).

.type MethodHandle = Value
.decl MethodHandle_Method(?methodHandle:MethodHandle, ?method:Method)
// Returns a method type for a method handle. This is not a function: a method
// handle may, for example, contain both a method type that only mentions the
// original method arguments and a method type that also includes the receiver.
.decl MethodHandle_MethodType(?mh:MethodHandle, ?mt:MethodType)

// For every method handle constant, create a method type.
Value_isMock(?mt), isValue(?mt), Value_Type(?mt,  "java.lang.invoke.MethodType"), Value_DeclaringType(?mt, "java.lang.Object"),
isInitialMethodType(?mt),
MethodHandle_Method(?methodHandle, ?method),
MethodHandle_MethodType(?methodHandle, ?mt),
MethodType_Arity(?mt, ?arity),
MethodType_ParamTypes(?mt, ?paramTypes),
MethodType_ReturnType(?mt, ?retType) :-
  MethodHandleConstant_Method(?methodHandle, ?method),
  MethodHandleConstant_ParamTypes(?methodHandle, ?paramTypes),
  MethodHandleConstant_ReturnType(?methodHandle, ?retType),
  MethodHandleConstant_Arity(?methodHandle, ?arity),
  ?mt = cat("<method type (", cat(?paramTypes, cat(")", cat( ?retType, ">")))).

// Invocations of a MethodHandle. These can either be explicit calls to
// MethodHandle.invoke()/invokeExact() or implicit calls via invokedynamic.

.decl MethodHandleCallGraphEdge_Candidate(?callerCtx:configuration.Context, ?i:MethodInvocation, ?m:Method, ?mh:MethodHandle, ?name:symbol)
MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name) :-
  // Permit treatment of invoke methods as opaque.
  ReachableContext(?callerCtx, ?containingMethod),
  (_VirtualMethodInvocation(?invo, _, _, ?base, ?containingMethod) ;
   _SpecialMethodInvocation(?invo, _, _, ?base, ?containingMethod)),
  _PolymorphicInvocation(?invo, ?name),
  VarPointsTo(_, ?mh, ?callerCtx, ?base),
  MethodHandle_Method(?mh, ?method).
.plan 1:(4,5,2,1,3), 2:(5,4,2,1,3)

.decl MethodHandleCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?mh:MethodHandle, ?name:symbol)
configuration.StaticContextRequest(?callerCtx, ?invo) :-
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, _, _),
  Method_Modifier("static", ?method).
// Call-graph edges for static method handle invocations.
MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, ?name) :-
  configuration.StaticContextResponse(?callerCtx, ?invo, ?calleeCtx),
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name).
// Call-graph edges for non-static method handle invocations.
MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, ?name) :-
  MethodHandleCallGraphEdge_Candidate(?callerCtx, ?invo, ?method, ?mh, ?name),
  !Method_Modifier("static", ?method),
  // REVIEW: context sensitivity in the callee.
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?method) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?method, _, _).

// A boxing/unboxing conversion of types including the null type.
.decl BoxTypeConversion(?original:Type, ?new:Type)
// Create a new allocation in the case of boxing.
.decl BoxAllocation(?value:Value, ?type:Type)


BoxTypeConversion(?t1, ?t2),
Value_isMock(?mockAlloc), isValue(?mockAlloc), Value_Type(?mockAlloc,  ?t2), Value_DeclaringType(?mockAlloc, "java.lang.Object"),
BoxAllocation(?mockAlloc, ?t2) :-
  PrimitiveType_Boxed(?t1, ?wrapperT),
  basic.SubtypeOf(?wrapperT, ?t2),
  ?mockAlloc = cat("<mock box allocation for type ", cat(?t2, ">")).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(?t1, _), isNullType(?t2).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(_, ?t2), isNullType(?t1).
BoxTypeConversion(?t1, ?t2) :- BoxTypeConversion(?t2, ?t1).

.decl CompatibleTypes(?t:Type, ?tConv:Type)
CompatibleTypes(?t, ?tConv) :- basic.SubtypeOf(?tConv, ?t).
CompatibleTypes(?t, ?tConv) :- BoxTypeConversion(?t, ?tConv).

// Record parameter passing, to be used for conversions (e.g., auto-boxing).
.decl MethodHandleCGE_Arg(?callerCtx:configuration.Context, ?calleeCtx:configuration.Context, ?actual:Var, ?formal:Var, ?actualType:Type, ?formalType:Type, ?name:symbol)
// Pass arguments to instance methods (first argument becomes the receiver).
MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, ?name) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, ?name),
  !Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  ?idx > 0,
  FormalParam(?idx - 1, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType).
// Pass arguments to static methods.
MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, ?name) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, ?name),
  Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType).


// This rule covers exact matching of argument types.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, _),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  basic.SubtypeOf(?actualType, ?formalType).



// Pass receiver to instance methods.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?this) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  !Method_Modifier("static", ?method),
  ActualParam(0, ?invo, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  ThisVar(?method, ?this),
  Var_Type(?actual, ?actualType),
  Var_Type(?this, ?thisType),
  basic.SubtypeOf(?actualType, ?thisType).

// Get return value.
VarPointsTo(?hctx, ?val, ?callerCtx, ?var) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  ReturnVar(?ret, ?method),
  VarPointsTo(?hctx, ?val, ?calleeCtx, ?ret),
  AssignReturnValue(?invo, ?var),
  Var_Type(?ret, ?retType),
  Var_Type(?var, ?varType),
  CompatibleTypes(?retType, ?varType).


// Model MethodHandle.asType().
OpaqueCallGraphEdge(?invo, ?sig),
Value_isMock(?adapterMH), isValue(?adapterMH), Value_Type(?adapterMH,  "java.lang.invoke.MethodHandle"), Value_DeclaringType(?adapterMH, "java.lang.Object"),

VarPointsTo(?hctx, ?adapterMH, ?ctx, ?ret),

MethodHandle_Method(?adapterMH, ?mhMethod),
MethodHandle_MethodType(?adapterMH, ?mt) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  ReachableContext(?ctx, ?method),
  ?sig = "<java.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodType)>",
  VarPointsTo(?hctx, ?mh, ?ctx, ?base),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(_, ?mt, ?ctx, ?arg),
  AssignReturnValue(?invo, ?ret),
  MethodHandle_Method(?mh, ?mhMethod),
  Method_ParamTypes(?mhMethod, _),
  ?adapterMH = cat("<adapter for ", cat(?mh, cat(" as ", ?mt))).


                                                               

.decl MHLookup_Type(?value:Value, ?type:Type)




// Create a receiver object when calling constructors.


VarPointsTo(?hctx, ?value, ?calleeCtx, ?thisVar),
VarPointsTo(?hctx, ?value, ?callerCtx, ?ret),

Value_isMock(?value), isValue(?value), Value_Type(?value,  ?type), Value_DeclaringType(?value, "java.lang.Object") :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, _),
  basic.ClassConstructor(?method, ?type),
  ThisVar(?method, ?thisVar),
  isImmutableHContext(?hctx),
  ?value = cat(?type, cat(" value constructed by method handle ", ?mh)),
  AssignReturnValue(?invo, ?ret),
  Var_Type(?ret, ?retType),
  basic.SubtypeOf(?type, ?retType).


                                                               

.decl ReachableInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  isDynamicMethodInvocation_Insn(?invokedynamic),
  Instruction_Method(?invokedynamic, ?inMethod),
  DynamicMethodInvocation_DynName(?invokedynamic, ?dynName),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  ReachableContext(?ctx, ?inMethod).

// Helper relation to make bootstrap method context configurable.
.decl isBootstrapMethodContext(?ctx:configuration.Context)
isBootstrapMethodContext(?ctx) :- isImmutableContext(?ctx).

// Call-graph edge: invokedynamic instruction -> boot method.
.decl InvokedynamicBootCallGraphEdge(?callerCtx:configuration.Context, ?invokedynamic:DynamicMethodInvocation_Insn, ?calleeCtx:configuration.Context, ?bootMethod:Method)
InvokedynamicBootCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?bootMethod) :-
  ReachableInvokedynamic(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx).

ReachableContext(?calleeCtx, ?bootMethod) :-
  InvokedynamicBootCallGraphEdge(_, _, ?calleeCtx, ?bootMethod).

.decl Invokedynamic_MethodType(?invokedynamic:DynamicMethodInvocation_Insn, ?mt:MethodType)
.decl PopulateMTParamTypes(?mt:Value, ?invokedynamic:DynamicMethodInvocation_Insn)

// For every reachable invokedynamic, create a mock method type.
Value_isMock(?mt), isValue(?mt), Value_Type(?mt,  "java.lang.invoke.MethodType"), Value_DeclaringType(?mt, "java.lang.Object"),
MethodType_ReturnType(?mt, ?dynRetType),
PopulateMTParamTypes(?mt, ?invokedynamic),
Invokedynamic_MethodType(?invokedynamic, ?mt) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, _, _),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  ?mt = cat("<method type (", cat(?dynParamTypes, cat(")", cat( ?dynRetType, ">")))).
MethodType_ParamType(?mt, ?index, ?pType) :-
  PopulateMTParamTypes(?mt, ?invokedynamic),
  _DynamicMethodInvocation_DynParamType(?invokedynamic, ?index, ?pType).

// Pass arguments to bootstrap methods. First three arguments are
// filled in by the JVM, so we fill them with mock objects.

VarPointsTo(?immHctx, ?mockMHLookup, ?calleeCtx, ?caller),
VarPointsTo(?immHctx, ?mt, ?calleeCtx, ?invokedTypeParam),

Value_isMock(?mockMHLookup), isValue(?mockMHLookup), Value_Type(?mockMHLookup,  "java.lang.invoke.MethodHandles$Lookup"), Value_DeclaringType(?mockMHLookup, "java.lang.Object"),
MHLookup_Type(?mockMHLookup, ?callerClass) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  FormalParam(0, ?bootMethod, ?caller),
  FormalParam(2, ?bootMethod, ?invokedTypeParam),
  Invokedynamic_MethodType(?invokedynamic, ?mt),
  isImmutableHContext(?immHctx),
  Instruction_Method(?invokedynamic, ?method),
  Method_DeclaringType(?method, ?callerClass),
  ?mockMHLookup = cat("<mock method handles lookup object for type ", cat(?callerClass, ">")).

// The second-arg rule should only be enabled when strings are not merged.


// Helper method to compute the varargs accumulator formal of a method.
.decl MethodVarArgs(?method:Method, ?idx:number, ?formal:Var, ?type:ArrayType)
MethodVarArgs(?method, ?idx, ?formal, ?type) :-
  Method_Modifier("varargs", ?method),
  Method_Arity(?method, ?arity),
  ?idx = ?arity - 1,
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?formal, ?type),
  isArrayType(?type).

// Use a mock array to fix calls to a bootstrap method accepting varargs.



ArrayIndexPointsTo(?immHctx, ?val, ?immHctx, ?mockArray),
Value_isMock(?mockArray), isValue(?mockArray), Value_Type(?mockArray,  ?varArgsType), Value_DeclaringType(?mockArray, "java.lang.Object"),
VarPointsTo(?immHctx, ?mockArray, ?calleeCtx, ?formalVarArgs) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  MethodVarArgs(?bootMethod, ?bootIdx, ?formalVarArgs, ?varArgsType),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  ?idx > ?bootIdx - 3,
  VarPointsTo(_, ?val, _, ?actual),
  isImmutableHContext(?immHctx),
  ?mockArray = cat("<bootstrap varargs array for ", cat(?invokedynamic, ">")).

// Normal handling for the last three arguments of the bootstrap method, shifted.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  !Method_Modifier("varargs", ?bootMethod),
  FormalParam(?idx + 3, ?bootMethod, ?formal),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(?hctx, ?val, _, ?actual).


.type CallSite = Value
.decl InvokedynamicCallSite(?callsite:CallSite, ?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?K:number, ?ctx:configuration.Context)

// Record CallSite metadata. This rule handles the return values of bootstrap
// methods without checking types: according to the JVM spec, the return type of
// a bootstrap method need not be java.lang.invoke.CallSite.
InvokedynamicCallSite(?callsite, ?invokedynamic, ?dynName, ?K, ?callerCtx) :-
  ReachableInvokedynamic(?invokedynamic, ?dynName, _, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  ReturnVar(?bootRetVar, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx),
  VarPointsTo(_, ?callsite, ?calleeCtx, ?bootRetVar).


// Interpret CallSite contents.
.decl CallSiteContents(?invokedynamic:DynamicMethodInvocation_Insn, ?methodHandle:MethodHandle, ?method:Method, ?mt:MethodType, ?ctx:configuration.Context)
CallSiteContents(?invokedynamic, ?methodHandle, ?method, ?mt, ?ctx) :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, ?ctx),
  Invokedynamic_MethodType(?invokedynamic, ?mt),
  InstanceFieldPointsTo(_, ?methodHandle, "<java.lang.invoke.CallSite: java.lang.invoke.MethodHandle target>", _, ?callsite),
  MethodHandle_Method(?methodHandle, ?method).

// Match call sites against invokedynamic method type signatures. If reflective
// method handles logic is enabled, also match prepended-receiver method types.
.decl CallSiteMatchesMethodHandleType(?invokedynamic:DynamicMethodInvocation_Insn, ?mh:MethodHandle, ?method:Method, ?ctx:configuration.Context)
CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?ctx) :-
  CallSiteContents(?invokedynamic, ?mh, ?method, ?mtDyn, ?ctx),

  MethodHandle_MethodType(?mh, ?mtDyn).


// Method handle for C.<init> has dynamic return type C instead of "void".
CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?ctx) :-
  CallSiteContents(?invokedynamic, ?mh, ?method, ?mt, ?ctx),
  MethodType_ReturnType(?mt, ?dynRetType),
  basic.ClassConstructor(?method, ?dynRetType),
  MethodHandle_Method(?mh, ?method).

// After a method handle is resolved, invokedynamic calls it, as if
// "invokeExact" was invoked on it. This is a call-graph edge from an
// invokedynamic instruction to the method invoked by the call site.

// Rule for static methods resolved by invokedynamic.
.decl StaticMethodHandleCall(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?method:Method, ?mh:MethodHandle)
StaticMethodHandleCall(?callerCtx, ?invokedynamic, ?method, ?mh),
configuration.StaticContextRequest(?callerCtx, ?invokedynamic) :-
  CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?callerCtx),
  Method_Modifier("static", ?method).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  StaticMethodHandleCall(?callerCtx, ?invokedynamic, ?method, ?mh),
  configuration.StaticContextResponse(?callerCtx, ?invokedynamic, ?calleeCtx).

// General rule for non-static methods resolved by invokedynamic. This rule
// does not use the Request/Response schema, since we do not have a "value"
// for the receiver (call site resolution happens at load time).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  CallSiteMatchesMethodHandleType(?invokedynamic, ?mh, ?method, ?callerCtx),
  !Method_Modifier("static", ?method),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?callee, _, _).



                                                               







// Find invocations to the lambda metafactories.
.decl LambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn)
LambdaMetafactoryInvoke(?invokedynamic) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?method),
  (?method = "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>" ; ?method = "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>").

.decl ReachableLambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableLambdaMetafactoryInvoke(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  LambdaMetafactoryInvoke(?invokedynamic),
  ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx).

// Record invokedynamic invocations whose bootstrap methods are not
// handled at all. Used for statistics.
.decl UnhandledInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?bootMethodId:symbol)

UnhandledInvokedynamic(?invokedynamic, ?bootMethodId) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethodId),
  !LambdaMetafactoryInvoke(?invokedynamic).



.type Lambda = Value
// TODO: Field ?ctx is currently unused, should be used in the
// LambdaCallGraphEdge rule for context sensitivity.
.decl LambdaObject(?invokedynamic:DynamicMethodInvocation_Insn, ?lambda:Lambda, ?dynName:symbol, ?K:number, ?implMethod:Method, ?ctx:configuration.Context)



// Record more information about the call site to model the metafactory result
// and return the mock lambda object.
Value_isMock(?lambda), isValue(?lambda), Value_Type(?lambda,  ?dynRetType), Value_DeclaringType(?lambda, "java.lang.Object"),

VarPointsTo(?hctx, ?lambda, ?callerCtx, ?ret),

LambdaObject(?invokedynamic, ?lambda, ?dynName, ?K, ?implMethod, ?callerCtx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, ?dynName, ?dynRetType, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  BootstrapParam(1, ?invokedynamic, ?handleVar),
  VarPointsTo(?hctx, ?handleVal, ?callerCtx, ?handleVar),
  MethodHandleConstant_Method(?handleVal, ?implMethod),
  // Used to generate friendly description for the lambda.
  Method_SimpleName(?implMethod, ?handleMeth),
  Method_DeclaringType(?implMethod, ?handleType),
  ?lambda = cat(?invokedynamic, cat("::: ", cat( ?dynRetType, cat("::: (Mock)::: ", cat("reference ", cat( ?handleType, cat ("::", cat( ?handleMeth, cat(" from ", cat( ?implMethod, cat(" wrapped as ", cat( ?dynRetType, cat(".",  ?dynName))))))))))))),
  // ?lambda = cat(?invokedynamic, cat("::: ", cat( ?dynRetType, cat("::: (Mock)::: ", cat("lambda object of type ",  ?dynRetType))))),
  AssignReturnValue(?invokedynamic, ?ret).



// Capture values of the enclosing environment.
.decl LambdaCaptured(?invokedynamic:DynamicMethodInvocation_Insn, ?val:Value, ?idx:number, ?hctx:configuration.HContext)
LambdaCaptured(?invokedynamic, ?val, ?idx, ?hctx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  ?K > 0,
  ActualParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual).



// When a method is called on a lambda object constructed by a
// constant method handle, the real method is called. This can wrap a
// static method call as an instance method call.

// Call-graph edge: method invocation on lambda object -> implementing method.
.decl LambdaCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?lambda:Lambda)

// Call-graph edge: method call on lambda object -> implementing
// method.  For simplicity, the callee context is trivial. For proper
// context sensitivity, we must model all combinations of calling
// contexts with implementing-method static-ness.
LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda) :-
  LambdaObject(_, ?lambda, ?dynName, _, ?implMethod, _),
  VarPointsTo(_, ?lambda, ?callerCtx, ?var),
  VirtualMethodInvocation_Base(?i, ?var),
  VirtualMethodInvocation_SimpleName(?i, ?dynName),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?callee, _).


// Handle return values for lambda call-graph edges.
VarPointsTo(?hctx, ?retVal, ?callerCtx, ?ret) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?method, _),
  ReturnVar(?realReturnVar, ?method),
  VarPointsTo(?hctx, ?retVal, ?calleeCtx, ?realReturnVar),
  AssignReturnValue(?i, ?ret).


// Helper relation: implementing method is an instance method.
.decl CalledInstanceImplMethod(?invokedynamic:DynamicMethodInvocation_Insn, ?implMethod:Method, ?this:Var, ?thisType:Type, ?calleeCtx:configuration.Context, ?lambda:Lambda)
CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  !Method_Modifier("static", ?implMethod),
  LambdaObject(?invokedynamic, ?lambda, _, _, ?implMethod, _),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType).

// Helper relation: instance methods may implicitly consume one of the
// K or N arguments for the receiver (shifting them by 1), while
// static methods take all K arguments before N ones.
.decl Params_ReceiverShiftRight(?lambda:Lambda, ?implMethod:Method, ?shiftK:number, ?shiftN:number)
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 0) :-
  LambdaObject(_, ?lambda, _, _, ?implMethod, _),
  Method_Modifier("static", ?implMethod).
// No bootstrap arguments = an actual argument will be used for 'this'.
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1) :-
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, _, _, _, ?lambda),
  DynamicMethodInvocation_DynArity(?invokedynamic, 0).
// First bootstrap argument exists, will be used for 'this'.
Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0) :-
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, _, _, _, ?lambda),
  LambdaCaptured(?invokedynamic, _, 0, _).

// Invocation argument to be passed to implementing method.
.decl LambdaArg(?calleeCtx:configuration.Context, ?formal:Var, ?formalType:Type, ?actual:Var, ?invokedynamic:DynamicMethodInvocation_Insn)

// Pass invocation arguments to the implementing method.
LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, ?invokedynamic) :-
  LambdaCallGraphEdge(_, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, ?shiftN),
  LambdaObject(?invokedynamic, ?lambda, _, ?K, ?implMethod, _),
  ActualParam(?idx, ?i, ?actual),
  FormalParam(?K - ?shiftK + ?idx - ?shiftN, ?implMethod, ?formal),
  Var_Type(?formal, ?formalType).


// Argument passing case #1: check type compatibility.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, _),
  VarPointsTo(?hctx, ?val, _, ?actual),
  Value_Type(?val, ?valType),
  basic.SubtypeOf(?valType, ?formalType).


// Argument passing case #2: autoboxing for some function types.
.decl BoxingFunction(?functionType:ReferenceType, ?primType:Type, ?refType:ReferenceType)
BoxingFunction(?intArgLambdaType, "int", "java.lang.Integer") :-
  ?intArgLambdaType = "java.util.function.IntBinaryOperator";
  ?intArgLambdaType = "java.util.function.IntConsumer";
  ?intArgLambdaType = "java.util.function.IntFunction";
  ?intArgLambdaType = "java.util.function.IntPredicate";
  ?intArgLambdaType = "java.util.function.IntToDoubleFunction";
  ?intArgLambdaType = "java.util.function.IntToLongFunction";
  ?intArgLambdaType = "java.util.function.IntUnaryOperator";
  ?intArgLambdaType = "java.util.function.ObjIntConsumer".
BoxingFunction(?longArgLambdaType, "long", "java.lang.Long") :-
  ?longArgLambdaType = "java.util.function.LongBinaryOperator";
  ?longArgLambdaType = "java.util.function.LongConsumer";
  ?longArgLambdaType = "java.util.function.LongFunction";
  ?longArgLambdaType = "java.util.function.LongPredicate";
  ?longArgLambdaType = "java.util.function.LongToDoubleFunction";
  ?longArgLambdaType = "java.util.function.LongToIntFunction";
  ?longArgLambdaType = "java.util.function.LongUnaryOperator";
  ?longArgLambdaType = "java.util.function.ObjLongConsumer".
BoxingFunction(?doubleArgLambdaType, "double", "java.lang.Double") :-
  ?doubleArgLambdaType = "java.util.function.DoubleBinaryOperator";
  ?doubleArgLambdaType = "java.util.function.DoubleConsumer";
  ?doubleArgLambdaType = "java.util.function.DoubleFunction";
  ?doubleArgLambdaType = "java.util.function.DoublePredicate";
  ?doubleArgLambdaType = "java.util.function.DoubleToIntFunction";
  ?doubleArgLambdaType = "java.util.function.DoubleToLongFunction";
  ?doubleArgLambdaType = "java.util.function.DoubleUnaryOperator";
  ?doubleArgLambdaType = "java.util.function.ObjDoubleConsumer".

VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaArg(?calleeCtx, ?formal, ?formalType, ?actual, ?invokedynamic),
  ReachableLambdaMetafactoryInvoke(?invokedynamic, _, ?dynRetType, _),
  Var_Type(?actual, ?primType),
  BoxingFunction(?dynRetType, ?primType, ?formalType),
  BoxAllocation(?val, ?formalType),
  isImmutableHContext(?hctx).

// Pass captured arguments to the implementing method.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, _),
  LambdaObject(?invokedynamic, ?lambda, _, ?K, ?implMethod, _),
  LambdaCaptured(?invokedynamic, ?val, ?idx, ?hctx),
  ?idx + ?shiftK <= ?K,
  FormalParam(?idx - ?shiftK, ?implMethod, ?formal),
  Value_Type(?val, ?valType),
  Var_Type(?formal, ?formalType),
  basic.SubtypeOf(?valType, ?formalType).

// Special handling for captured "this" parameters.
VarPointsTo(?hctx, ?thisValue, ?calleeCtx, ?this) :-
  Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0),
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda),
  LambdaCaptured(?invokedynamic, ?thisValue, 0, ?hctx),
  Value_Type(?thisValue, ?thisValueType),
  basic.SubtypeOf(?thisValueType, ?thisType).

// Special handling for "this" parameters to method references that do
// not capture a receiver.
VarPointsTo(?hctx, ?argValue, ?calleeCtx, ?this) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1),
  ActualParam(0, ?i, ?actual),
  VarPointsTo(?hctx, ?argValue, ?callerCtx, ?actual),
  Value_Type(?argValue, ?argType),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType),
  basic.SubtypeOf(?argType, ?thisType).

// Applications of constructor references construct values. However,
// these values do not come from a 'new' instruction in the code but
// are created here as mock values, one per type/invocation.
VarPointsTo(?hctx, ?mockObj, ?callerCtx, ?var),
VarPointsTo(?hctx, ?mockObj, ?calleeCtx, ?thisVar),
Value_isMock(?mockObj), isValue(?mockObj), Value_Type(?mockObj,  ?type), Value_DeclaringType(?mockObj, "java.lang.Object") :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, _),
  basic.ClassConstructor(?implMethod, ?type),
  AssignReturnValue(?i, ?var),
  ThisVar(?implMethod, ?thisVar),
  ?mockObj = cat("<mock object of type ", cat(?type, cat(" constructed by constructor reference at ", cat(?i, ">")))),
  isImmutableHContext(?hctx).












  .decl FakeInvocation_RegisterFinalize0(?heap:HeapAllocation, ?invo:MethodInvocation)

  .decl FakeInvocation_RegisterFinalize(?value:Value, ?invo:MethodInvocation)

  .decl Value_isHeap(?value:Value)
  .decl Value_isMock(?value:Value)

  // Value_Num maps each numeric constant to a value while
  // also prepending it with *num-constant-* to distinguish it
  // from heap allocations that share the same string value.
  .decl Value_Num(?value:Value, ?const:symbol, ?valueType:Type)

  .decl Value_isNonHeap(?value:Value)

  // Special value objects are just artificial ones that we use to find where the
  // result of a reflective call can flow to. We don't want to track them
  // through the heap.
  .decl NotSpecialObject(?value:Value)

  .decl Value_Type(?value:Value, ?type:Type)
  .decl Value_DeclaringType(?value:Value, ?type:Type)

  // [Miscellaneous]
  .decl Value_Null(?null:Value)




.decl isContext(?ctx:configuration.Context)
.decl isHContext(?hctx:configuration.HContext)

// These are normally unique, but for partitioned analyses there may be
// one per partition.
.decl isImmutableContext(?ctx:configuration.Context)
.decl isInitialContext(?ctx:configuration.Context)
.decl isJVMStartupContext(?ctx:configuration.Context)
.decl isClinitContext(?ctx:configuration.Context)
.decl isImmutableHContext(?hctx:configuration.HContext)
.decl isJVMStartupHContext(?hctx:configuration.HContext)


.decl VarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)

.decl InstanceFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value)

.decl StaticFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?sig:Field)

// array-element insensitive
.decl ArrayIndexPointsTo(?hctx:configuration.HContext, ?value:Value, ?basehctx:configuration.HContext, ?basevalue:Value)


   
.decl CallGraphEdge(?callerCtx:configuration.Context, ?invocation:MethodInvocation, ?calleeCtx:configuration.Context, ?method:Method) overridable
.decl OpaqueCallGraphEdge(?invocation:MethodInvocation, ?method:Method)


   
.decl Reachable(?method:Method)
.decl ReachableClass(?class:ReferenceType)
.decl ReachableContext(?ctx:configuration.Context, ?method:Method)

// .decl OptLoadInstanceField(?to:Var, ?signature:Field, ?base:Var)

// .decl OptLoadStaticField(?ctx:configuration.Context, ?to:Var, ?signature:Field)

// .decl OptStoreStaticField(?signature:Field, ?from:Var)

// .decl OptStoreInstanceField(?from:Var, ?signature:Field, ?base:Var)



   
.decl OptInterproceduralAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)

.decl OptLoadArrayIndex(?to:Var, ?base:Var)

.decl OptStoreArrayIndex(?from:Var, ?base:Var)

.decl OptArgAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var, ?allowedType:Type)
//.decl OptArgAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)


.decl OptArgVarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)

.decl OptRetVarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)

.decl HeapInterproceduralAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)

.decl LoadHeapInstanceField(?ctx:configuration.Context, ?to:Var, ?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value)

.decl StoreHeapInstanceField(?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)

.decl LoadHeapArrayIndex(?ctx:configuration.Context, ?to:Var, ?basehctx:configuration.HContext, ?basevalue:Value)

.decl StoreHeapArrayIndex(?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)


   
.decl SystemThreadGroup(?hctx:configuration.HContext, ?value:Value)

.decl MainThreadGroup(?hctx:configuration.HContext, ?value:Value)

.decl MainThread(?hctx:configuration.HContext, ?value:Value)



   
//.decl SiteToRefine(?invocation:MethodInvocation)

//.decl ValueToRefine(?value:Value)

// Is the SiteToRefine the real list of objects needing
// refinement or its negation?
// .decl NegativeSiteFilter(?v:symbol)

// Is the ValueToRefine the real list of objects needing
// refinement or its negation?
// .decl NegativeObjectFilter(?v:symbol)



Value_DeclaringType(?value, "java.lang.System") :-
   ?value = "<<string-constant>>",
   isValue(?value) ;
   ?value = "<<reflection-string-constant>>",
   isValue(?value) ;
   ?value = "<<string-buffer>>",
   isValue(?value) ;
   ?value = "<<string-builder>>",
   isValue(?value) ;
   ?value = "<<initial-context>>",
   isValue(?value) ;
   ?value = "<<jvm-startup-context>>",
   isValue(?value) ;
   ?value = "<<jvm-startup-hcontext>>",
   isValue(?value) ;
   ?value = "<<clinit-context>>",
   isValue(?value) ;
   ?value = "<<system-thread-group>>",
   isValue(?value) ;
   ?value = "<<main-thread-group>>",
   isValue(?value) ;
   ?value = "<<main-thread>>",
   isValue(?value) ;
   ?value = "<<immutable-context>>",
   isValue(?value) ;
   ?value = "<<immutable-hcontext>>",
   isValue(?value) ;
   ?value = "<<immutable>>",
   isValue(?value).

// JLS 5.1.7 (Java 8).
// TODO Misses null-to-null boxing (is it useful for dynamic proxies?).
.decl PrimitiveType_Boxed(?type:Type, ?boxedType:Type)

PrimitiveType_Boxed("boolean", "java.lang.Boolean"  ).
PrimitiveType_Boxed("byte"   , "java.lang.Byte"     ).
PrimitiveType_Boxed("short"  , "java.lang.Short"    ).
PrimitiveType_Boxed("char"   , "java.lang.Character").
PrimitiveType_Boxed("int"    , "java.lang.Integer"  ).
PrimitiveType_Boxed("long"   , "java.lang.Long"     ).
PrimitiveType_Boxed("float"  , "java.lang.Float"    ).
PrimitiveType_Boxed("double" , "java.lang.Double"   ).


ClassInitializer(?type, ?method) :-
   basic.MethodImplemented("<clinit>", "void()", ?type, ?method).


   


   
InitializedClass(?superclass) :-
   InitializedClass(?class),
   DirectSuperclass(?class, ?superclass).

InitializedClass(?superinterface) :-
   InitializedClass(?classOrInterface),
   DirectSuperinterface(?classOrInterface, ?superinterface).


   
InitializedClass(?class) :-
   basic.MainMethodDeclaration(?method),
   Method_DeclaringType(?method, ?class).


   
InitializedClass(?class) :-
   Reachable(?inmethod),
   AssignHeapAllocation(?heap, _, ?inmethod),
   HeapAllocation_Type(?heap, ?class).


   
InitializedClass(?class) :-
   Reachable(?inmethod),
   Instruction_Method(?invocation, ?inmethod),
   isStaticMethodInvocation_Insn(?invocation),
   MethodInvocation_Method(?invocation, ?signature),
   Method_DeclaringType(?signature, ?class).


   
InitializedClass(?classOrInterface) :-
   Reachable(?inmethod),
   StoreStaticField(_, ?signature, ?inmethod),
   Field_DeclaringType(?signature, ?classOrInterface).


   
InitializedClass(?classOrInterface) :-
   Reachable(?inmethod),
   LoadStaticField(?signature, _, ?inmethod),
   Field_DeclaringType(?signature, ?classOrInterface).


   

.decl FinalizeContextRequest(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?fakeinvo:MethodInvocation, ?heapValue:Value, ?register:Method, ?formal:Var)


   
FinalizeContextRequest(?callerCtx, ?hctx, ?fakeinvo, ?heapValue, ?register, ?formal),
configuration.ContextRequest(?callerCtx, ?hctx, ?fakeinvo, ?heapValue, ?register, 1) :-
  FakeInvocation_RegisterFinalize(?heapValue, ?fakeinvo),
  basic.AllocatedObjectSupportsFinalize(?heapValue, ?inmethod),
  (!(HeapAllocation_Merge(?heapValue, _));
  HeapAllocation_Merge(?heapValue, ?heapValue)),  // the object retains its identity
  ReachableContext(?callerCtx, ?inmethod),
  ?register = "<java.lang.ref.Finalizer: void register(java.lang.Object)>",
  isMethod(?register),
  FormalParam(0, ?register, ?formal),
  isImmutableHContext(?hctx).

// The allocated object becomes the actual parameter to Finalizer.register.
ReachableContext(?calleeCtx, ?register),
VarPointsTo(?hctx, ?heapValue, ?calleeCtx, ?formal) :-
  configuration.ContextResponse(?callerCtx, ?hctx, ?fakeinvo, ?heapValue, ?register, ?calleeCtx),
  FinalizeContextRequest(?callerCtx, ?hctx, ?fakeinvo, ?heapValue, ?register, ?formal).
.plan 1:(2,1)




FakeInvocation_RegisterFinalize0(?val2, cat("<register-finalize ", cat(?val1, cat( "/", cat( ?val2, "  >"))))),
isInstruction(cat("<register-finalize ", cat(?val1, cat( "/", cat( ?val2, "  >"))))), isMethodInvocation(cat("<register-finalize ", cat(?val1, cat( "/", cat( ?val2, "  >"))))) :-
    basic.AllocatedObjectSupportsFinalize(?val2, ?val1),
    isMethod(?val1),
    isHeapAllocation(?val2).




   



ImplicitReachable("<java.lang.System: void initializeSystemClass()>") :- isMethod("<java.lang.System: void initializeSystemClass()>").
ImplicitReachable("<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.Runnable)>") :- isMethod("<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.Runnable)>").
ImplicitReachable("<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.String)>") :- isMethod("<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.String)>").
ImplicitReachable("<java.lang.ThreadGroup: void <init>()>") :- isMethod("<java.lang.ThreadGroup: void <init>()>").
ImplicitReachable("<java.lang.Thread: void exit()>") :- isMethod("<java.lang.Thread: void exit()>").
ImplicitReachable("<java.lang.ThreadGroup: void uncaughtException(java.lang.Thread,java.lang.Throwable)>") :- isMethod("<java.lang.ThreadGroup: void uncaughtException(java.lang.Thread,java.lang.Throwable)>").
ImplicitReachable("<java.lang.ClassLoader: void <init>()>") :- isMethod("<java.lang.ClassLoader: void <init>()>").
ImplicitReachable("<java.lang.ClassLoader: java.lang.Class loadClassInternal(java.lang.String)>") :- isMethod("<java.lang.ClassLoader: java.lang.Class loadClassInternal(java.lang.String)>").
ImplicitReachable("<java.lang.ClassLoader: void checkPackageAccess(java.lang.Class,java.security.ProtectionDomain)>") :- isMethod("<java.lang.ClassLoader: void checkPackageAccess(java.lang.Class,java.security.ProtectionDomain)>").
ImplicitReachable("<java.lang.ClassLoader: void addClass(java.lang.Class)>") :- isMethod("<java.lang.ClassLoader: void addClass(java.lang.Class)>").
ImplicitReachable("<java.lang.ClassLoader: long findNative(java.lang.ClassLoader,java.lang.String)>") :- isMethod("<java.lang.ClassLoader: long findNative(java.lang.ClassLoader,java.lang.String)>").
ImplicitReachable("<java.security.PrivilegedActionException: void <init>(java.lang.Exception)>") :- isMethod("<java.security.PrivilegedActionException: void <init>(java.lang.Exception)>").


  



// Make test entry points implicitly reachable by discovering their
// annotations. This can also discover the entry points of
// XCorpus.


// Contribute to the global summary relation.
ApplicationEntryPoint(?meth) :-
  ForcedReachable(?meth),
  ApplicationMethod(?meth).

.decl ForcedReachableContext(?ctx:configuration.Context, ?meth:Method)

// Forced reachable methods are invoked by unknown callers.
ForcedReachableContext(?ctx, ?method) :-
  ForcedReachable(?method),
  isImmutableContext(?ctx).

// Forced-reachable contexts are reachable contexts.
ReachableContext(?ctx, ?meth) :-
  ForcedReachableContext(?ctx, ?meth).

// Formals of forced-reachable contexts, recorded here for mocking.
.decl FormalOfForcedReachableContext(?ctx:configuration.Context, ?formal:Var, ?formalType:Type)
FormalOfForcedReachableContext(?ctx, ?formal, ?formalType) :-
  ForcedReachableContext(?ctx, ?meth),
  FormalParam(_, ?meth, ?formal),
  Var_Type(?formal, ?formalType).

.decl ApplicationConcreteType(?type:ClassType)

ApplicationConcreteType(?type) :-
    ApplicationClass(?type),
    !isInterfaceType(?type),
    !ClassModifier("abstract", ?type).

//anantoni: For now we want all concrete types that are going to be used as mock object types to be part of the application
// Our fallback is the type itself, but that will only work in case it's not abstract
// We need to monitor the cases where entry points have arguments with no concrete implementations

.decl AllApplicationConcreteImplementations(?class:ClassType, ?type:Type)
.decl TypeHasApplicationConcreteSubtypes(?type:Type)

TypeHasApplicationConcreteSubtypes(?abstractType),
AllApplicationConcreteImplementations(?class, ?abstractType) :-
    ApplicationClass(?class),
    basic.SubtypeOf(?class, ?abstractType),
    ?abstractType != "java.lang.Object",
    !ClassModifier("abstract", ?class).

AllApplicationConcreteImplementations(?class, ?class) :- ConcreteClass(?class).

.decl ServletParamType(?paramType:ReferenceType)
ServletParamType(?paramType) :-
  basic.SubtypeOf(?paramType, "javax.servlet.ServletRequest");
  basic.SubtypeOf(?paramType, "javax.servlet.ServletResponse");
  basic.SubtypeOf(?paramType, "org.springframework.http.HttpMethod");
  basic.SubtypeOf(?paramType, "org.apache.commons.httpclient.HttpMethod");
  basic.SubtypeOf(?paramType, "org.springframework.extensions.webscripts.WebScriptRequest");
  basic.SubtypeOf(?paramType, "org.springframework.extensions.webscripts.WebScriptResponse");
  basic.SubtypeOf(?paramType, "javax.servlet.http.HttpServletRequest");
  basic.SubtypeOf(?paramType, "javax.servlet.http.HttpServletResponse");
  basic.SubtypeOf(?paramType, "javax.servlet.http.HttpSessionEvent");
  basic.SubtypeOf(?paramType, "javax.servlet.ServletContextEvent").

// Special types implemented in the library also participate in mocking.
.decl SpecialConcreteImplementations(?class:ClassType, ?type:ReferenceType)
SpecialConcreteImplementations(?class, ?type) :-
  isClassType(?class),
  basic.SubtypeOf(?class, ?type),
  ServletParamType(?type).

.decl TypeToConcreteImplementation(?type:ReferenceType, ?class:ClassType)
TypeToConcreteImplementation(?type, ?class) :-
  AllApplicationConcreteImplementations(?class, ?type) ;
  SpecialConcreteImplementations(?class, ?type).


    
// REVIEW: this is imprecise, it assigns one or more mock arguments
// for each parameter in a forced-reachable method.
Value_isMock(?mockObj), isValue(?mockObj), Value_Type(?mockObj,  ?class), Value_DeclaringType(?mockObj, "java.lang.Object"),
MockObjFromOpenProgramEntryPointArg(?mockObj),
VarPointsTo(?hctx, ?mockObj, ?ctx, ?formal) :-
  FormalOfForcedReachableContext(?ctx, ?formal, ?formalType),
  TypeToConcreteImplementation(?formalType, ?class),
  isImmutableHContext(?hctx),
  ?mockObj = cat("<mock value for forced-reachable parameter ", cat(?class, ">")).

// Helper/statistics relation.
UnmockableFormalOfForcedReachableContext(?formal, ?formalType) :-
  FormalOfForcedReachableContext(_, ?formal, ?formalType),
  !TypeToConcreteImplementation(?formalType, _).


    
Value_isMock(?value), isValue(?value), Value_Type(?value,  ?class), Value_DeclaringType(?value, "java.lang.Object"),
VarPointsTo(?hctx, ?value, ?ctx, ?receiver),
MockObjFromOpenProgramEntryPointReceiver(?value),
MockObject(?value, ?class) :-
  ( ExercisedEntryPointMethod(?class, ?method)
  ; (ForcedReachable(?method), Method_DeclaringType(?method, ?class))),
  ThisVar(?method, ?receiver),
  ?value = cat(?class, "::MockObject"),
  mainAnalysis.isImmutableContext(?ctx),
  mainAnalysis.isImmutableHContext(?hctx).



   

// 'keep'/'root' = make method reachable.
ForcedReachable(?meth) :-
  (KeepMethod(?meth) ; RootCodeElement(?meth)),
  isMethod(?meth).

// Not clear what ProGuard does with "keep" annotations for classes, but certainly
// I've seen documented behavior in industrial code that expects it to keep no-arg
// constructors.
ForcedReachable(?meth) :-
  KeepClass(?class),
  basic.ClassConstructor(?meth, ?class),
  !FormalParam(_, ?meth, _).

// 'keep class members' / 'keep classes with members' = keep all class
// methods if the class has a reachable method. We assume that 'keep
// classes with members' has already been resolved and the tuples only
// concern the types that apply.
ForcedReachableContext(?ctx, ?method) :-
  ( KeepClassMembers(?method) ; KeepClassesWithMembers(?method) ),
  Method_DeclaringType(?method, ?type),
  Method_DeclaringType(?someMethod, ?type),
  Reachable(?someMethod),
  isImmutableContext(?ctx).






VarPointsTo(?hctx, ?argArray, ?ctx, ?args),
ArrayIndexPointsTo(?hctx, ?argArrayContent, ?hctx, ?argArray) :-
   isImmutableHContext(?hctx),
   basic.MainMethodDeclaration(?mainMethod),
   ReachableContext(?ctx, ?mainMethod),
   FormalParam(0, ?mainMethod, ?args),
   MainMethodArgArray(?argArray),
   MainMethodArgArrayContent(?argArrayContent).



    





// Populating this relation generates simulated native values.
.decl SimulateNativeAllocation(?strMethod: Method, ?strHeap: HeapAllocation, ?strConstructor: Method)

// Generate value.
AssignHeapAllocation(?strHeap, ?return, ?strMethod),
Value_DeclaringType(?strHeap, ?strType) :-
  SimulateNativeAllocation(?strMethod, ?strHeap, _),
  Method_DeclaringType(?strMethod, ?strType),
  NativeReturnVar(?return, ?strMethod),
  isHeapAllocation(?strHeap).

// Generate construction site.
SpecialMethodInvocation_Base(?newInstrId, ?return),
Instruction_Method(?newInstrId, ?strMethod),
MethodInvocation_Method(?newInstrId, strConstructor),
isInstruction(?newInstrId), isMethodInvocation(?newInstrId), isSpecialMethodInvocation_Insn(?newInstrId),
Instruction_Index(?newInstrId, ?index) :-
  SimulateNativeAllocation(?strMethod, _, strConstructor),
  isMethod(?strMethod),
  NativeReturnVar(?return, ?strMethod),
  isMethod(strConstructor),
  ?index = 1,
  ?newInstrId = cat(?strMethod, cat("/native ", strConstructor)).

.decl SimulatedNativeAllocation(?heap:HeapAllocation, ?method:Method)
.output SimulatedNativeAllocation






                                                                                    


   
AssignLocal(?this, ?ret, ?method) :-
  ?method = "<java.lang.Object: java.lang.Object clone()>",
  isMethod(?method),
  ThisVar(?method, ?this),
  ReturnVar(?ret, ?method).



                                                     


   
StoreStaticField(
  
"<java.lang.System: void setIn0(java.io.InputStream)>/@parameter0", 
  
"<java.lang.System: java.io.InputStream in>", 
  
"<java.lang.System: void setIn0(java.io.InputStream)>") :- isMethod(
  
"<java.lang.System: void setIn0(java.io.InputStream)>"), isVar(
  
"<java.lang.System: void setIn0(java.io.InputStream)>/@parameter0"), isField(
  
"<java.lang.System: java.io.InputStream in>").



// For Wala:
StoreStaticField(
  
"<java.lang.System: void setIn0(java.io.InputStream)>/v1", 
  
"<java.lang.System: java.io.InputStream in>", 
  
"<java.lang.System: void setIn0(java.io.InputStream)>") :- isMethod(
  
"<java.lang.System: void setIn0(java.io.InputStream)>"), isVar(
  
"<java.lang.System: void setIn0(java.io.InputStream)>/v1"), isField(
  
"<java.lang.System: java.io.InputStream in>").



StoreStaticField(
  
"<java.lang.System: void setOut0(java.io.PrintStream)>/@parameter0", 
  
"<java.lang.System: java.io.PrintStream out>", 
  
"<java.lang.System: void setOut0(java.io.PrintStream)>") :- isMethod(
  
"<java.lang.System: void setOut0(java.io.PrintStream)>"), isVar(
  
"<java.lang.System: void setOut0(java.io.PrintStream)>/@parameter0"), isField(
  
"<java.lang.System: java.io.PrintStream out>").


// For Wala:
StoreStaticField(
  
"<java.lang.System: void setOut0(java.io.PrintStream)>/v1", 
  
"<java.lang.System: java.io.PrintStream out>", 
  
"<java.lang.System: void setOut0(java.io.PrintStream)>") :- isMethod(
  
"<java.lang.System: void setOut0(java.io.PrintStream)>"), isVar(
  
"<java.lang.System: void setOut0(java.io.PrintStream)>/v1"), isField(
  
"<java.lang.System: java.io.PrintStream out>").



StoreStaticField(
  
"<java.lang.System: void setErr0(java.io.PrintStream)>/@parameter0", 
  
"<java.lang.System: java.io.PrintStream err>", 
  
"<java.lang.System: void setErr0(java.io.PrintStream)>") :- isMethod(
  
"<java.lang.System: void setErr0(java.io.PrintStream)>"), isVar(
  
"<java.lang.System: void setErr0(java.io.PrintStream)>/@parameter0"), isField(
  
"<java.lang.System: java.io.PrintStream err>").


StoreStaticField(
  
"<java.lang.System: void setErr0(java.io.PrintStream)>/v1", 
  
"<java.lang.System: java.io.PrintStream err>", 
  
"<java.lang.System: void setErr0(java.io.PrintStream)>") :- isMethod(
  
"<java.lang.System: void setErr0(java.io.PrintStream)>"), isVar(
  
"<java.lang.System: void setErr0(java.io.PrintStream)>/v1"), isField(
  
"<java.lang.System: java.io.PrintStream err>").



isVar(cat(?invocation, "/@tmp-arraycopy")), Var_Type(cat(?invocation, "/@tmp-arraycopy"),  ?tmpType), Var_DeclaringMethod(cat(?invocation, "/@tmp-arraycopy"),  ?inmethod),
LoadArrayIndex(?src, cat(?invocation, "/@tmp-arraycopy"), ?inmethod),
StoreArrayIndex(cat(?invocation, "/@tmp-arraycopy"), ?dest, ?inmethod) :-
   ?arraycopy = "<java.lang.System: void arraycopy(java.lang.Object,int,java.lang.Object,int,int)>",
   isMethod(?arraycopy),
   StaticMethodInvocation(?invocation, ?arraycopy, ?inmethod),
   ActualParam(0, ?invocation, ?src),
   ActualParam(2, ?invocation, ?dest),
   isMethodInvocation(?invocation),
   ?tmpType = "java.lang.Object",
   isType(?tmpType).


                                                                                    
// For now handle these as array operations, not as field operations
StoreArrayIndex(?from, ?base, ?inmethod) :-
  ?casObject = "<sun.misc.Unsafe: boolean compareAndSwapObject(java.lang.Object,long,java.lang.Object,java.lang.Object)>",
  isMethod(?casObject),
  VirtualMethodInvocation(?invocation, ?casObject, ?inmethod),
  ActualParam(0, ?invocation, ?base),
  ActualParam(3, ?invocation, ?from).

StoreArrayIndex(?from, ?base, ?inmethod) :-
  (?putObj = "<sun.misc.Unsafe: void putObject(java.lang.Object,long,java.lang.Object)>";
   ?putObj = "<sun.misc.Unsafe: void putObject(java.lang.Object,int,java.lang.Object)>";
   ?putObj = "<sun.misc.Unsafe: void putObjectVolatile(java.lang.Object,long,java.lang.Object)>";
   ?putObj = "<sun.misc.Unsafe: void putOrderedObject(java.lang.Object,long,java.lang.Object)>"),
  isMethod(?putObj),
  VirtualMethodInvocation(?invocation, ?putObj, ?inmethod),
  ActualParam(0, ?invocation, ?base),
  ActualParam(2, ?invocation, ?from).

LoadArrayIndex(?base, ?to, ?inmethod) :-
  (?getObj = "<sun.misc.Unsafe: java.lang.Object getObjectVolatile(java.lang.Object,long)>";
   ?getObj = "<sun.misc.Unsafe: java.lang.Object getObject(java.lang.Object,long)>";
   ?getObj = "<sun.misc.Unsafe: java.lang.Object getObject(java.lang.Object,int)>"),
  isMethod(?getObj),
  VirtualMethodInvocation(?invocation, ?getObj, ?inmethod),
  ActualParam(0, ?invocation, ?base),
  AssignReturnValue(?invocation, ?to).


                                                                                    




// Native OpenJDK method.
SimulatedNativeAllocation(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0", 
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"). SimulatedNativeAllocation(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0", 
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"). AssignHeapAllocation(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0", ?return, 
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>") :- isMethod(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), NativeReturnVar(?return, 
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), isHeapAllocation(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0"). isVar(cat(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element")), Var_Type(cat(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element"), 
  
"java.lang.String"), Var_DeclaringMethod(cat(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element"), 
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), AssignHeapAllocation(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0", cat(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element"), 
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), StoreArrayIndex(cat(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>", "/@native-array-element"), ?base, 
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>") :- isMethod(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), NativeReturnVar(?base, 
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>"), isType(
  
"java.lang.String"), isHeapAllocation(
  
"<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0").



                                                                                    


   
isInstruction(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>"))), isMethodInvocation(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>"))), isVirtualMethodInvocation_Insn(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>"))), VirtualMethodInvocation(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>")), 
  
"<java.lang.Object: void finalize()>", 
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>"), VirtualMethodInvocation_Base(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>")), ?base), Instruction_Method(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>")), 
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>"), MethodInvocation_Method(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>")), 
  
"<java.lang.Object: void finalize()>"), Instruction_Index(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>")), ?index) :- isMethod(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>"), FormalParam(0, 
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", ?base), isMethod(
  
"<java.lang.Object: void finalize()>"), ?index = 1. isInstruction(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>"))), isMethodInvocation(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>"))), AssignReturnValue(cat(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>", cat("/native ", 
  
"<java.lang.Object: void finalize()>")), ?return) :- isMethod(
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>"), NativeReturnVar(?return, 
  
"<java.lang.ref.Finalizer: void invokeFinalizeMethod(java.lang.Object)>").




                                                                                    


   
isInstruction(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), isMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), isVirtualMethodInvocation_Insn(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), VirtualMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), 
  
"<java.security.PrivilegedAction: java.lang.Object run()>", 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>"), VirtualMethodInvocation_Base(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), ?base), Instruction_Method(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>"), MethodInvocation_Method(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"), Instruction_Index(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), ?index) :- isMethod(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>"), FormalParam(0, 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", ?base), isMethod(
  
"<java.security.PrivilegedAction: java.lang.Object run()>"), ?index = 1. isInstruction(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), isMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), AssignReturnValue(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), ?return) :- isMethod(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>"), NativeReturnVar(?return, 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>").


isInstruction(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), isMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), isVirtualMethodInvocation_Insn(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), VirtualMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), 
  
"<java.security.PrivilegedAction: java.lang.Object run()>", 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>"), VirtualMethodInvocation_Base(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), ?base), Instruction_Method(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>"), MethodInvocation_Method(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"), Instruction_Index(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), ?index) :- isMethod(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>"), FormalParam(0, 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", ?base), isMethod(
  
"<java.security.PrivilegedAction: java.lang.Object run()>"), ?index = 1. isInstruction(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), isMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>"))), AssignReturnValue(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedAction: java.lang.Object run()>")), ?return) :- isMethod(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>"), NativeReturnVar(?return, 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>").


isInstruction(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isVirtualMethodInvocation_Insn(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), VirtualMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>", 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>"), VirtualMethodInvocation_Base(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?base), Instruction_Method(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>"), MethodInvocation_Method(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"), Instruction_Index(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?index) :- isMethod(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>"), FormalParam(0, 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", ?base), isMethod(
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"), ?index = 1. isInstruction(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), AssignReturnValue(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?return) :- isMethod(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>"), NativeReturnVar(?return, 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction)>").


isInstruction(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isVirtualMethodInvocation_Insn(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), VirtualMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>", 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>"), VirtualMethodInvocation_Base(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?base), Instruction_Method(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>"), MethodInvocation_Method(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"), Instruction_Index(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?index) :- isMethod(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>"), FormalParam(0, 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", ?base), isMethod(
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"), ?index = 1. isInstruction(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), isMethodInvocation(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>"))), AssignReturnValue(cat(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>", cat("/native ", 
  
"<java.security.PrivilegedExceptionAction: java.lang.Object run()>")), ?return) :- isMethod(
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>"), NativeReturnVar(?return, 
  
"<java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>").



SimulateNativeAllocation(
  "<sun.misc.Perf: java.nio.ByteBuffer createLong(java.lang.String,int,int,long)>",
  "<sun.misc.Perf: java.nio.ByteBuffer createLong(java.lang.String,int,int,long)>/new java.nio.DirectByteBuffer/0",
  "<java.nio.DirectByteBuffer: void <init>()>").




                                                                                    

// REVIEW: does this need more handling, e.g., ReferenceQueue?

.decl StoreIntoWeakReference(?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)
.decl LoadFromReference(?ctx:configuration.Context, ?to:Var, ?basehctx:configuration.HContext, ?basevalue:Value)

.decl StoreIntoWeakReferenceArgs(?from:Var, ?base:Var)
StoreIntoWeakReferenceArgs(?from, ?base) :-
  ?weakRefCtor = "<java.lang.ref.WeakReference: void <init>(java.lang.Object)>",
  MethodInvocation_Method(?invo, ?weakRefCtor),
  OptSpecialMethodInvocationBase(?invo, ?base),
  ActualParam(0, ?invo, ?from).

StoreIntoWeakReference(?basehctx, ?basevalue, ?ctx, ?from) :-
  StoreIntoWeakReferenceArgs(?from, ?base),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

.decl LoadFromReferenceArgs(?base:Var, ?to:Var)
LoadFromReferenceArgs(?base, ?to) :-
  ?refGet = "<java.lang.ref.Reference: java.lang.Object getReferent()>",
  MethodInvocation_Method(?invo, ?refGet),
  OptSpecialMethodInvocationBase(?invo, ?base),
  AssignReturnValue(?invo, ?to).

LoadFromReference(?ctx, ?to, ?basehctx, ?basevalue) :-
  LoadFromReferenceArgs(?base, ?to),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

HeapInterproceduralAssign(?ctxTo, ?to, ?ctxFrom, ?from) :-
  LoadFromReference(?ctxTo, ?to, ?basehctx, ?basevalue),
  StoreIntoWeakReference(?basehctx, ?basevalue, ?ctxFrom, ?from),
  !Value_Null(?basevalue).
  .plan 1:(2,1)




// Native contexts are currently another name for immutable contexts.
.decl isNativeContext(?ctx:configuration.Context)
isNativeContext(?ctx) :- isImmutableContext(?ctx).




StaticFieldPointsTo(?hctx, ?value, ?pending) :-
   ?pending = "<java.lang.ref.Reference: java.lang.ref.Reference pending>",
   ( ?this = "<java.lang.ref.Reference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>/@this" ;
   ?this = "<java.lang.ref.Reference: void <init>(java.lang.Object,java.lang.ref.ReferenceQueue)>/v1"),
   isField(?pending),
   isVar(?this),
   VarPointsTo(?hctx, ?value, _, ?this).



   
.decl HeapAllocation_ContextInsensitive(?heap:HeapAllocation)

// Merged objects are currently always context-insensitive
HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Merge(?heap, _).


   
.decl HeapAllocation_Merge(?heap:HeapAllocation, ?mergeHeap:HeapAllocation)

// The ones that absolutely have to be kept distinct
.decl HeapAllocation_Keep(?heap:HeapAllocation)


   

.decl AssignNormalHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inmethod:Method)
.decl AssignContextInsensitiveHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inmethod:Method)

AssignNormalHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  !HeapAllocation_ContextInsensitive(?heap).

AssignContextInsensitiveHeapAllocation(?mergeHeap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_Merge(?heap, ?mergeHeap).

AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inmethod) :-
  AssignHeapAllocation(?heap, ?var, ?inmethod),
  HeapAllocation_ContextInsensitive(?heap),
  !(HeapAllocation_Merge(?heap, _)). // should be mostly unnecessary, but has bitten us many times



                                                               

.decl HeapRepresentative(?heap:HeapAllocation, ?heapRepr:symbol)
.decl HeapIsMergedString(?heap:HeapAllocation)

// If the object is a string that should be merged, ignore other
// representatives and merge with that.
HeapIsMergedString(?heap) :-
  HeapRepresentative("<<string-constant>>", ?heap).
// Rule split in two since it needs to be stratified differently
.decl HeapIsMergedStringFactory(?heap:HeapAllocation)


HeapAllocation_Merge(?heap, ?heapRepr) :-
  ?heapRepr = "<<string-constant>>",
  HeapRepresentative(?heapRepr, ?heap).

HeapIsMergedStringFactory(?heap) :-
  HeapRepresentative("<<string-buffer>>", ?heap);
  HeapRepresentative("<<string-builder>>", ?heap).

HeapAllocation_Merge(?heap, ?heapRepr) :-
  (?heapRepr = "<<string-buffer>>",
   HeapRepresentative(?heapRepr, ?heap));
  (?heapRepr = "<<string-builder>>",
   HeapRepresentative(?heapRepr, ?heap));
  // (?heapRepr = "<<class-metaobject>>",
  //  HeapRepresentative(?heapRepr, ?heap));
  (?heapRepr = "<<pystring-object>>",
   HeapRepresentative(?heapRepr, ?heap)).

.decl RepresentativesToPickFrom(?heapRepr:HeapAllocation, ?heap:HeapAllocation)

RepresentativesToPickFrom(?heapRepr, ?heap) :-
  HeapRepresentative(?heapRepr, ?heap),
  !HeapIsMergedString(?heap),
  !HeapIsMergedStringFactory(?heap),
  !HeapAllocation_Keep(?heap).

.decl MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd:number, ?heap:HeapAllocation)

MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap) :-
  RepresentativesToPickFrom(_, ?heap),
  ?minHeapReprOrd = min ord(?heapRepr): RepresentativesToPickFrom(?heapRepr, ?heap).

HeapAllocation_Merge(?heap, ?mergeHeap) :-
  isHeapAllocation(?mergeHeap),
  ord(?mergeHeap) = ?minHeapReprOrd,
  MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd, ?heap).



                                                               


HeapRepresentative(?constant, ?heap) :-
  isStringConstant(?heap),
  ?constant = "<<string-constant>>",
  isHeapAllocation(?constant),
  !HeapAllocation_Keep(?heap).

// HeapRepresentative("<<class-metaobject>>", ?heap) :-
//   HeapAllocation_Type(?heap, "java.lang.Class"),
//   !HeapAllocation_Keep(?heap).





.decl ReflectionStringConstant(?heap:HeapAllocation)
.decl ReflectionSubstringObject(?heap:HeapAllocation)



HeapAllocation_ContextInsensitive(?heap) :-
  isStringConstant(?heap),
  !HeapRepresentative(_, ?heap).

.decl NonTrivialStringConstant(?heap:StringConstant)

NonTrivialStringConstant(?heap) :-
  isStringConstant(?heap),
  strlen(?heap) >= 7.


   
.decl ClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)
.decl MethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)
.decl FieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)

.decl PreClassNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstantExact_Type(?type:Type, ?heap:HeapAllocation)
.decl PreClassNameMatchingStringConstantInexact_Type(?type:Type, ?heap:HeapAllocation)

// These are the predicates that the outside world will use. The Pre-
// versions are so that they can be stratified earlier and strings can
// possibly be merged based on them.
ClassNameMatchingStringConstant_Type(?type, ?heap) :-
  PreClassNameMatchingStringConstant_Type(?type, ?heap).
MethodNameMatchingStringConstant_Signature(?sig, ?heap) :-
  PreMethodNameMatchingStringConstant_Signature(?sig, ?heap).
FieldNameMatchingStringConstant_Signature(?sig, ?heap) :-
  PreFieldNameMatchingStringConstant_Signature(?sig, ?heap).

// We distinguish between an exact match and a
// substring match.

PreClassNameMatchingStringConstant(?string),
PreClassNameMatchingStringConstant_Type(?type, ?string),
PreClassNameMatchingStringConstantExact_Type(?type, ?string) :-
  isStringConstant(?string),
  isReferenceType(?type),

  ApplicationClass(?type),
     // library classes are known and in known packages. Makes no sense
     // to access them via .getClass

// #ifndef REFLECTION_HIGH_SOUNDNESS_MODE
// #ifndef INFORMATION_FLOW_HIGH_SOUNDNESS
//   NonTrivialStringConstant(?string),
// #endif // INFORMATION_FLOW_HIGH_SOUNDNESS
// #endif // REFLECTION_HIGH_SOUNDNESS_MODE
  ord(?type) = ord(?string).

.decl PreMethodNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstantExact_Signature(?sig:Method, ?heap:HeapAllocation)
.decl PreMethodNameMatchingStringConstantInexact_Signature(?sig:Method, ?heap:HeapAllocation)

PreMethodNameMatchingStringConstant(?string),
PreMethodNameMatchingStringConstant_Signature(?sig, ?string),
PreMethodNameMatchingStringConstantExact_Signature(?sig, ?string) :-
  isStringConstant(?string),
  //  Method_DeclaringType(?sig, ?type),
  //  ApplicationClass(?type),
     // there is some possibility of accessing methods and fields
     // reflectively, even in system classes. Maybe one needs to
     // circumvent access control, or maybe one wants to treat all
     // fields uniformly and some are inherited from a system superclass.
  Method_SimpleName(?sig, ?string),
  ?string != "<init>",
  ?string != "<clinit>". // common, yet not methods callable via reflection

.decl PreFieldNameMatchingStringConstant(?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstantExact_Signature(?sig:Field, ?heap:HeapAllocation)
.decl PreFieldNameMatchingStringConstantInexact_Signature(?sig:Field, ?heap:HeapAllocation)

PreFieldNameMatchingStringConstant(?string),
PreFieldNameMatchingStringConstant_Signature(?sig, ?string),
PreFieldNameMatchingStringConstantExact_Signature(?sig, ?string) :-
  isStringConstant(?string),
  // Field_DeclaringType(?sig, ?declaringClass),
  // ApplicationClass(?declaringClass);
  // #ifndef REFLECTION_HIGH_SOUNDNESS_MODE
  // #ifndef INFORMATION_FLOW_HIGH_SOUNDNESS
  //   NonTrivialStringConstant(?string),
  // #endif
  // #endif
  Field_SimpleName(?sig, ?string).





                                                               

HeapAllocation_ContextInsensitive(?heap) :-
  isClassHeap(?heap).


                                                               

// Per-method merging: auto-merge allocation sites for method that
// allocates many objects of same type. Also, enable other rules to
// explicitly ask for per-method merging, beyond the above heuristic
// (by setting "...ShouldBeMerged...").

.decl MethodAllocationMergeThreshold(?t:number)

MethodAllocationMergeThreshold(50).

.decl ExceptionType(?type:Type)

ExceptionType(?type) :-
  ?throw = "java.lang.Throwable",
  isType(?throw),
  basic.SubtypeOf(?type, ?throw).

.decl OptAssignHeapAllocation(?inmethod:Method, ?heap:HeapAllocation)

OptAssignHeapAllocation(?inmethod, ?heap) :-
  AssignHeapAllocation(?heap, _, ?inmethod).

// There are objects, like strings, null, and class objects, that
// don't have a unique allocation site.
.decl ObjectMultipleAllocated(?heap:HeapAllocation)

ObjectMultipleAllocated(?heap) :-
  OptAssignHeapAllocation(?inmethod1, ?heap),
  OptAssignHeapAllocation(?inmethod2, ?heap),
  ?inmethod1 != ?inmethod2.

.decl MethodAndTypeToHeap(?heap:HeapAllocation, ?heapType:Type, ?method:Method)

MethodAndTypeToHeap(?heap, ?heaptype, ?meth) :-
  AssignHeapAllocation(?heap, _, ?meth),
  HeapAllocation_Type(?heap, ?heaptype),
  !isStringConstant(?heap),
  !StringFactoryHeap(?heap),
  !HeapAllocation_EmptyArray(?heap),
  !ObjectMultipleAllocated(?heap),
  !HeapAllocation_Keep(?heap).

.decl AllocationsPerMethodAndType(?type:Type, ?meth:Method, ?n:number)

AllocationsPerMethodAndType(?type, ?meth, ?n) :-
  MethodAndTypeToHeap(_, ?type, ?meth),
  ?n = count : MethodAndTypeToHeap(_, ?type, ?meth).

.decl AllocationShouldBeMergedPerMethod(?heaptype:Type, ?meth:Method)

AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
  AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
  MethodAllocationMergeThreshold(?t),
  ?n > ?t.

.decl MethodAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?meth:Method)

MethodAndTypeToMergedHeap(?heap, ?heaptype, ?meth) :-
  AllocationShouldBeMergedPerMethod(?heaptype, ?meth),
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth).

.decl MinHeapOrdinalPerMethodAndType(?ord:number, ?type:Type, ?meth:Method)
.decl MethodAndTypeToRepresentative(?type:Type, ?meth:Method, ?reprHeap:HeapAllocation)

MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth) :-
  MethodAndTypeToMergedHeap(_, ?type, ?meth),
  ?minHeapOrd = min ord(?heap): MethodAndTypeToMergedHeap(?heap, ?type, ?meth).

MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerMethodAndType(?minHeapOrd, ?type, ?meth),
  ord(?representativeHeap) = ?minHeapOrd.


HeapRepresentative(?representativeHeap, ?heap) :-
  MethodAndTypeToRepresentative(?type, ?meth, ?representativeHeap),
  MethodAndTypeToMergedHeap(?heap, ?type, ?meth).

// Now, per-class merging. This is more rare and should be requested
// explicitly for a given type. Again, does not apply to types with
// special merging policies.
.decl ClassAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:ReferenceType)
.decl AllocationsPerClassAndType(?type:Type, ?class:ReferenceType, ?n:number)

ClassAndTypeToHeap(?heap, ?heaptype, ?class) :-
  MethodAndTypeToHeap(?heap, ?heaptype, ?meth),
  Method_DeclaringType(?meth, ?class).

AllocationsPerClassAndType(?type, ?class, ?n) :-
  ClassAndTypeToHeap(_, ?type, ?class),
  ?n = count : ClassAndTypeToHeap(_, ?type, ?class).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedPerClass(?heaptype:Type, ?class:Type)

.decl ClassAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:Type)

ClassAndTypeToMergedHeap(?heap, ?heaptype, ?class) :-
  AllocationShouldBeMergedPerClass(?heaptype, ?class),
  ClassAndTypeToHeap(?heap, ?heaptype, ?class).

.decl MinHeapOrdinalPerClassAndType(?minHeapOrd:number, ?type:Type, ?class:Type)
.decl ClassAndTypeToRepresentative(?type:Type, ?class:Type, ?reprHeap:HeapAllocation)

MinHeapOrdinalPerClassAndType(?minHeapOrd, ?type, ?class) :-
  ClassAndTypeToMergedHeap(_, ?type, ?class),
  ?minHeapOrd = min ord(?heap): ClassAndTypeToMergedHeap(?heap, ?type, ?class).

ClassAndTypeToRepresentative(?type, ?class, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerClassAndType(?minHeapOrd, ?type, ?class),
  ord(?representativeHeap) = ?minHeapOrd.


HeapRepresentative(?representativeHeap, ?heap) :-
  ClassAndTypeToRepresentative(?type, ?class, ?representativeHeap),
  ClassAndTypeToMergedHeap(?heap, ?type, ?class).

// Same for per-package merging.

.decl ClassNameIndexes(?pos:number, ?type:ClassType)

ClassNameIndexes(0, ?type) :-
  isClassType(?type).

ClassNameIndexes(?pos+1, ?t) :-
  ClassNameIndexes(?pos, ?t),
  ?pos+1 < strlen(?t).

// Recognize packages
.decl DotsInClassName(?type:ClassType, ?pos:number)
.decl NotLastDot(?pos:number, ?type:ClassType)
.decl NotSecondLastDot(?pos:number, ?type:ClassType)
.decl LastDot(?type:ClassType, ?pos:number)
.decl SecondLastDot(?type:ClassType, ?pos:number)

.decl Class_PackageHack(?type:ClassType, ?packageName:symbol)

DotsInClassName(?type, ?pos) :-
  ClassNameIndexes(?pos, ?type),
  substr(?type, ?pos, 1) = ".".

NotLastDot(?pos, ?type) :-
  DotsInClassName(?type, ?pos),
  DotsInClassName(?type, ?pos2),
  ?pos2 > ?pos.

NotSecondLastDot(?pos, ?type) :-
  DotsInClassName(?type, ?pos),
  DotsInClassName(?type, ?pos2),
  ?pos2 > ?pos,
  NotLastDot(?pos2, ?type).

NotSecondLastDot(?pos, ?type) :-
  LastDot(?type, ?pos).

LastDot(?type, ?pos) :-
  DotsInClassName(?type, ?pos),
  !NotLastDot(?pos, ?type).

SecondLastDot(?type, ?pos) :-
  DotsInClassName(?type, ?pos),
  !NotSecondLastDot(?pos, ?type).

// Heuristically assign a class to a package
Class_PackageHack(?type, substr(?type, 0, ?secondLastPos)) :-
  SecondLastDot(?type, ?secondLastPos),
  isClassType(?type).

Class_PackageHack(?type, substr(?type, 0, ?lastPos)) :-
  !(SecondLastDot(?type, _)),  // there are fewer than two dots
  isClassType(?type),
  LastDot(?type, ?lastPos).

Class_PackageHack(?type, ?type) :-
  !(LastDot(?type, _)),  // there are no dots
  isClassType(?type).


.decl PackageAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)
.decl AllocationsPerPackageAndType(?type:Type, ?packageName:symbol, ?n:number)

PackageAndTypeToHeap(?heap, ?heaptype, ?packageName) :-
  ClassAndTypeToHeap(?heap, ?heaptype, ?class),
  Class_PackageHack(?class, ?packageName).

AllocationsPerPackageAndType(?type, ?packageName, ?n) :-
  PackageAndTypeToHeap(_, ?type, ?packageName),
  ?n = count : PackageAndTypeToHeap(_, ?type, ?packageName).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedPerPackage(?heaptype:Type, ?packageName:symbol)

.decl PackageAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)

PackageAndTypeToMergedHeap(?heap, ?heaptype, ?packageName) :-
  AllocationShouldBeMergedPerPackage(?heaptype, ?packageName),
  PackageAndTypeToHeap(?heap, ?heaptype, ?packageName).

.decl MinHeapOrdinalPerPackageAndType(?minHeapOrd:number, ?type:Type, ?packageName:symbol)
.decl PackageAndTypeToRepresentative(?type:Type, ?packageName:symbol, ?representativeHeap:HeapAllocation)

MinHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName) :-
  PackageAndTypeToMergedHeap(_, ?type, ?packageName),
  ?minHeapOrd = min ord(?heap): PackageAndTypeToMergedHeap(?heap, ?type, ?packageName).

PackageAndTypeToRepresentative(?type, ?packageName, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerPackageAndType(?minHeapOrd, ?type, ?packageName),
  ord(?representativeHeap) = ?minHeapOrd.


HeapRepresentative(?representativeHeap, ?heap) :-
  PackageAndTypeToRepresentative(?type, ?packageName, ?representativeHeap),
  PackageAndTypeToMergedHeap(?heap, ?type, ?packageName).

// And the ultimate: universal per-type merging
.decl TypeToHeap(?heap:HeapAllocation, ?heaptype:Type)
.decl AllocationsPerType(?type:Type, ?n:number)

TypeToHeap(?heap, ?heaptype) :-
  ClassAndTypeToHeap(?heap, ?heaptype, _).

AllocationsPerType(?type, ?n) :-
  TypeToHeap(_, ?type),
  ?n = count : TypeToHeap(_, ?type).

// This is explicitly set for types that want it.
.decl AllocationShouldBeMergedGlobally(?heaptype:Type)

.decl TypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type)

TypeToMergedHeap(?heap, ?heaptype) :-
  AllocationShouldBeMergedGlobally(?heaptype),
  TypeToHeap(?heap, ?heaptype).

.decl MinHeapOrdinalPerType(?minHeapOrd:number, ?type:Type)
.decl TypeToRepresentative(?type:Type, ?representativeHeap:HeapAllocation)

MinHeapOrdinalPerType(?minHeapOrd, ?type) :-
  TypeToMergedHeap(_, ?type),
  ?minHeapOrd = min ord(?heap): TypeToMergedHeap(?heap, ?type).

TypeToRepresentative(?type, ?representativeHeap) :-
  isHeapAllocation(?representativeHeap),
  MinHeapOrdinalPerType(?minHeapOrd, ?type),
  ord(?representativeHeap) = ?minHeapOrd.


HeapRepresentative(?representativeHeap, ?heap) :-
  TypeToRepresentative(?type, ?representativeHeap),
  TypeToMergedHeap(?heap, ?type).







                                                               


.decl SpecialLibraryObject(?heap:HeapAllocation)

SpecialLibraryObject(?heap) :-
  AssignHeapAllocation_Heap(?insn, ?heap),
  Instruction_Method(?insn, ?method),
  SpecialLibraryMethod(?method).

.decl SpecialLibraryMethod(?method:Method)
SpecialLibraryMethod(?method) :-
  Method_DeclaringType(?method, ?class),
  SpecialLibraryClass(?class).

.decl SpecialLibraryClass(?class:Type)
SpecialLibraryClass(?class) :-
  isClassType(?class),
  !ApplicationClass(?class),
  !CollectionClass(?class).

.decl CollectionClass(?class:Type)

  
CollectionClass(?class) :-
  isClassType(?class),
  !ApplicationClass(?class),
  basic.SubtypeOf(?class, ?superclass),
  (?superclass = "java.util.Map";
   ?superclass = "java.util.Collection";
   ?superclass = "java.util.Iterable";
   ?superclass = "java.util.Iterator";
   ?superclass = "java.util.Comparator";
   ?superclass = "java.util.Dictionary";
   ?superclass = "java.util.TimSort";
   ?superclass = "java.util.ComparableTimSort";
   ?superclass = "java.util.Arrays";
   ?superclass = "java.util.Objects";
   ?superclass = "java.util.Collections").

.decl CollectionInnerClass(?class:ClassType)

CollectionInnerClass(?innerClass),
CollectionClass(?innerClass) :-
  CollectionInnerClassPrefix(?innerClassPrefix),
  isClassType(?innerClass),
  substr(?innerClass, 0, strlen(?innerClassPrefix)) = ?innerClassPrefix.

.decl CollectionInnerClassPrefix(?innerClassPrefix:symbol)

CollectionInnerClassPrefix(?innerClassPrefix) :-
  CollectionClass(?class),
  ?innerClassPrefix = cat(?class, "$").

.output CollectionClass

  HeapAllocation_ContextInsensitive(?heap) :-
    SpecialLibraryObject(?heap),
    !HeapRepresentative(_, ?heap).


    AllocationShouldBeMergedPerMethod(?heaptype, ?meth) :-
      AllocationsPerMethodAndType(?heaptype, ?meth, ?n),
      ?n > 1,

      Method_DeclaringType(?meth, ?class),
      SpecialLibraryClass(?class).




                                                               

// Internal concept. DO NOT ADD TO IT!
.decl _StringFactoryType(?type:Type)
_StringFactoryType(?type) :-
  ?type = "java.lang.StringBuffer" ;
  ?type = "java.lang.StringBuilder".

.decl StringFactoryHeap(?heap:HeapAllocation)
StringFactoryHeap(?heap) :-
  HeapAllocation_Type(?heap, ?heaptype),
  _StringFactoryType(?heaptype).

// Other modules add to this. Don't know why! (REVIEW)
.decl StringFactoryType(?type:Type)
StringFactoryType(?type) :-
  _StringFactoryType(?type).


HeapRepresentative("<<string-buffer>>", ?heap) :-
  HeapAllocation_Type(?heap, "java.lang.StringBuffer"),
  !HeapAllocation_Keep(?heap).

HeapRepresentative("<<string-builder>>", ?heap) :-
  HeapAllocation_Type(?heap, "java.lang.StringBuilder"),
  !HeapAllocation_Keep(?heap).

HeapRepresentative("<<pystring-object>>", ?heap) :-
  HeapAllocation_Type(?heap, "org.python.core.PyString"),
  !HeapAllocation_Keep(?heap).



                                                               


   


// The optimized treatment represents every exception (i.e., throwable)
// object by a unique representative of the same type. All exception
// objects of the same type are therefore merged. This means that points-to
// results for throwables are not accurate! Only the type will be right.

//.decl ExceptionTypeToHeap2(?heap:HeapAllocation, ?type:Type)
//
//ExceptionTypeToHeap2(?heap, ?heaptype) :-
//  HeapAllocation_Type(?heap, ?heaptype),
//  basic.SubtypeOf(?heaptype, "java.lang.Throwable"),
//  ExceptionHandler_Type(_, ?handlertype),
//  basic.SubtypeOf(?heaptype, ?handlertype).

.decl ExceptionTypeToHeap(?heap:HeapAllocation, ?type:Type)

ExceptionTypeToHeap(?heap, ?heaptype) :-
  AssignHeapAllocation(?heap, _, _),
  HeapAllocation_Type(?heap, ?heaptype),
  ExceptionType(?heaptype).

.decl ExceptionHeapTypeRepresentativeOrdinal(?type:Type, ?reprHeapOrd:number)

ExceptionHeapTypeRepresentativeOrdinal(?type, ?representativeHeapOrd) :-
  ExceptionTypeToHeap(_, ?type),
  ?representativeHeapOrd = min ord(?heap) : ExceptionTypeToHeap(?heap, ?type).


HeapRepresentative(?representativeHeap, ?heap) :-
  ExceptionHeapTypeRepresentativeOrdinal(?heaptype, ?representativeHeapOrd),
  ExceptionTypeToHeap(?heap, ?heaptype),
  ord(?representativeHeap) = ?representativeHeapOrd,
  isHeapAllocation(?representativeHeap).




                                                               

HeapAllocation_ContextInsensitive(?heap) :-
  HeapAllocation_Type(?heap, ?type),
  isArrayType(?type),
  ComponentType(?type, ?componentType),
  isPrimitiveType(?componentType).


                                                               


  



                                                               

ReflectionStringConstant("int").
ReflectionStringConstant("float").
ReflectionStringConstant("double").
ReflectionStringConstant("byte").
ReflectionStringConstant("boolean").
ReflectionStringConstant("char").
ReflectionStringConstant("long").
ReflectionStringConstant("short").
ReflectionStringConstant("void").



                                                               

// Very silly we have to do this.
.decl _StringIterationTrick(?pos:number)
_StringIterationTrick(0).
_StringIterationTrick(?pos + 1) :- _StringIterationTrick(?pos), ?pos < 256.

.decl RelevantSuffixPosition(?typeName: Type, ?pos:number)
RelevantSuffixPosition(?typeName, ?pos) :-
  isType(?typeName),
  _StringIterationTrick(?pos), ?pos < strlen(?typeName).

.decl Suffix(?type:Type, ?suffix:symbol, ?suffixLen:number)

Suffix(?type, ?suffix, ?suffixLen) :-
  RelevantSuffixPosition(?type, ?pos),
  substr(?type, ?pos, 1) = ".",
  ?suffixLen = strlen(?type) - ?pos - 1,
  ?suffix = substr(?type, ?pos + 1, ?suffixLen).

Suffix(?type, ?type, ?suffixLen) :-
  isType(?type),
  ?suffixLen = strlen(?type).

.decl MinimalSuffixLen(?type:Type, ?suffixLen:number)

MinimalSuffixLen(?type, ?suffixLen) :-
  isType(?type),
  ?suffixLen = min ?len : Suffix(?type, _, ?len).

// Computes the suffix after the last dot of a type name.
.decl MinimalSuffix(?type:Type, ?suffix:symbol)

MinimalSuffix(?type, ?suffix) :-
  MinimalSuffixLen(?type, ?suffixLen),
  Suffix(?type, ?suffix, ?suffixLen).




   
RunningThread(?hctx, ?value) :-
    MainThread(?hctx, ?value).


   
ReachableContext(?calleeCtx, ?run),
VarPointsTo(?hctx, ?value, ?calleeCtx, ?runThis),
RunningThread(?hctx, ?value) 
:-

    ?start = "<java.lang.Thread: void start0()>",

    ThisVar(?start, ?startThis),
    CallGraphEdge(_, _, ?calleeCtx, ?start),
    VarPointsTo(?hctx, ?value, ?calleeCtx, ?startThis),
    Value_Type(?value, ?valuetype),
    basic.MethodLookup("run", "void()", ?valuetype, ?run),
    ThisVar(?run, ?runThis).

// The following is ridiculously imprecise but probably needed for some
// semblance of soundness. Therefore, only enable for non-points-to analyses.





VarPointsTo(?hctx, ?value, ?callerCtx, ?local) :-
   ReachableCurrentThreadInvocation(?callerCtx, ?local),
   RunningThread(?hctx, ?value).


ReachableCurrentThreadInvocation(?callerCtx, ?local) :-
   ?signature = "<java.lang.Thread: java.lang.Thread currentThread()>",
   StaticMethodInvocation(?invocation, ?signature, ?inmethod),
   ReachableContext(?callerCtx, ?inmethod),
   AssignReturnValue(?invocation, ?local).


   

configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1) :-
    SystemThreadGroup(?hctx, ?value),
    isImmutableContext(?callerCtx),
    FakeInvocation_ThreadGroupInit(?invo),
    ?signature = "<java.lang.ThreadGroup: void <init>()>".



VarPointsTo(?hctx, ?value, ?calleeCtx, ?this),

isContext(?calleeCtx),
ReachableContext(?calleeCtx, ?signature) :-
    ?signature = "<java.lang.ThreadGroup: void <init>()>",
    ThisVar(?signature, ?this),
    SystemThreadGroup(?hctx, ?value),
    configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1),
    configuration.ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?signature, ?calleeCtx).



   

configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1) :-
    MainThreadGroup(?hctx, ?value),
    isImmutableContext(?callerCtx),
    FakeInvocation_ThreadGroupInit(?invo),
    ?signature = "<java.lang.ThreadGroup: void <init>(java.lang.ThreadGroup,java.lang.String)>".


VarPointsTo(?hctx, ?value, ?calleeCtx, ?this),
VarPointsTo(?groupHCtx, ?group, ?calleeCtx, ?groupParam),

isContext(?calleeCtx),
ReachableContext(?calleeCtx, ?signature) :-
    ?signature = "<java.lang.ThreadGroup: void <init>(java.lang.ThreadGroup,java.lang.String)>",
    ThisVar(?signature, ?this),
    MainThreadGroup(?hctx, ?value),
    FormalParam(0, ?signature, ?groupParam),
    SystemThreadGroup(?groupHCtx, ?group),
    configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1),
    configuration.ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?signature, ?calleeCtx).


   

configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1) :-
    MainThread(?hctx, ?value),
    isImmutableContext(?callerCtx),
    FakeInvocation_MainThreadInit(?invo),
    ?signature = "<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.String)>".


VarPointsTo(?hctx, ?value, ?calleeCtx, ?this),
VarPointsTo(?groupHCtx, ?group, ?calleeCtx, ?groupParam),

isContext(?calleeCtx),
ReachableContext(?calleeCtx, ?signature) :-
    ?signature = "<java.lang.Thread: void <init>(java.lang.ThreadGroup,java.lang.String)>",
    ThisVar(?signature, ?this),
    MainThread(?hctx, ?value),
    FormalParam(0, ?signature, ?groupParam),
    MainThreadGroup(?groupHCtx, ?group),
    configuration.ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?signature, 1),
    configuration.ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?signature, ?calleeCtx).



FakeInvocation_ThreadGroupInit(?invo),
isInstruction(?invo), isMethodInvocation(?invo) :-
  ?invo = "<thread-group-init>/0".

FakeInvocation_MainThreadInit(?invo),
isInstruction(?invo), isMethodInvocation(?invo) :-
  ?invo = "<main-thread-init>/0".

FakeInvocation_SystemThreadGroupInit(?invo),
isInstruction(?invo), isMethodInvocation(?invo) :-
  ?invo = "<system-thread-group-init>/0".




FakeInvocation_RegisterFinalize(?heapValue, ?invo) :-
  FakeInvocation_RegisterFinalize0(?heapValue, ?invo).

Value_isHeap(?heapValue),
isValue(?heapValue),
Value_Type(?heapValue, ?type) :-
  isHeapAllocation(?heapValue),
  HeapAllocation_Type(?heapValue, ?type).




Value_isNonHeap(?value) :-
  Value_isMock(?value) ;
  Value_Num(?value, _, _).

Value_Null(?nullheap) :-
  HeapAllocation_Null(?nullheap).


Value_DeclaringType(?heapValue, ?type) :-
  AssignHeapAllocation(?heapValue, _, ?inmethod),
  Method_DeclaringType(?inmethod, ?type),
  isNormalHeap(?heapValue).

Value_DeclaringType(?heapValue, "java.lang.System") :-
  isClassHeap(?heapValue).

Value_DeclaringType(?heapValue, "java.lang.String") :-
  isStringConstant(?heapValue).

Value_DeclaringType(?value, "java.lang.Object") :-
  Value_Null(?value);
  MainMethodArgArray(?value);
  MainMethodArgArrayContent(?value).

Value_DeclaringType(?heapValue, "java.lang.invoke.MethodHandle") :-
  isMethodHandleConstant(?heapValue).

Value_DeclaringType(?heapValue, "java.lang.invoke.MethodType") :-
  isMethodTypeConstant(?heapValue).

Value_DeclaringType(?heapValue, ?type) :-
  SimulatedNativeAllocation(?heapValue, ?method),
  Method_DeclaringType(?method, ?type).

// Mark objects that are normal, i.e., not special
NotSpecialObject(?value) :-
  Value_isHeap(?value) ;
  Value_isMock(?value) ;
  Value_Num(?value, _, _).

configuration.InitContextRequest("<<immutable-context>>").
//configuration.InitContextRequest("<<initial-context>>").
//configuration.InitContextRequest("<<jvm-startup-context>>").
//configuration.InitContextRequest("<<clinit-context>>").

isImmutableContext(?ctx),
isContext(?ctx) :-
  ?s = "<<immutable-context>>",
  configuration.InitContextRequest(?s),
  configuration.InitContextResponse(?s, ?ctx).


  
// The main method is reachable
ApplicationEntryPoint(?method),
ReachableContext(?initialContext, ?method) :-
  isImmutableContext(?initialContext),
  basic.MainMethodDeclaration(?method).

// Implicitly reachable methods are invoked by the JVM on startup.
ReachableContext(?ctx, ?method) :-
  isImmutableContext(?ctx),
  ImplicitReachable(?method).

// If a class needs to be initialized, then its class initializer is invoked
// Note: InitializedClass already deals with superclasses that need initialization
ReachableContext(?clinitContext, ?clinit) :-
  isImmutableContext(?clinitContext),
  InitializedClass(?class),
  ClassInitializer(?class, ?clinit).

configuration.InitHContextRequest("<<immutable-hcontext>>").
//configuration.InitHContextRequest("<<jvm-startup-hcontext>>").

isImmutableHContext(?hctx),
isHContext(?hctx) :-
  ?s = "<<immutable-hcontext>>",
  configuration.InitHContextRequest(?s),
  configuration.InitHContextResponse(?s, ?hctx).


                                                  

// Create initial objects with their heap contexts
SystemThreadGroup(?hctx, ?alloc) :-
  isImmutableHContext(?hctx),
  ?alloc = "<<system-thread-group>>",
  isValue(?alloc).

MainThreadGroup(?hctx, ?alloc) :-
  isImmutableHContext(?hctx),
  ?alloc = "<<main-thread-group>>",
  isValue(?alloc).

MainThread(?hctx, ?alloc) :-
  isImmutableHContext(?hctx),
  ?alloc = "<<main-thread>>",
  isValue(?alloc).



   



   

.decl ReachableValue(?hctx:configuration.HContext, ?value: Value)

ReachableValue(?hctx, ?heapValue) :-
  AssignContextInsensitiveHeapAllocation(?heapValue, _, ?inmethod),
  ReachableContext(_, ?inmethod),
  isImmutableHContext(?hctx).

isHContext(?newHCtx),
ReachableValue(?newHCtx, ?heapValue) :-
  configuration.RecordContextRequest(?ctx, ?heapValue, ?var),
  configuration.RecordContextResponse(?ctx, ?heapValue, ?var, ?newHCtx).

// REVIEW: a catch-all hack: there are still corners where the logic is centered
// around VarPointsTo. Cover them as best as one can, by inferring ReachableValue.
// Ideally, this rule will be deprecated in the long term, by carefully going over
// all current logic and adding counterparts to the VarPointsTo-inferring rules
// to also produce useful information (e.g., ReachableValue) when points-to
// analysis is disabled.
ReachableValue(?hctx, ?value) :-
  VarPointsTo(?hctx, ?value, _, _).

.decl TypeHasReachableValue(?valueType: Type)
TypeHasReachableValue(?valueType) :-
  ReachableValue(_, ?value),
  Value_Type(?value, ?valueType).



   

configuration.RecordContextRequest(?ctx, ?heapValue, ?var) :-
  AssignNormalHeapAllocation(?heapValue, ?var, ?inmethod),
  ReachableContext(?ctx, ?inmethod).



VarPointsTo(?newHCtx, ?heapValue, ?ctx, ?var) :-
  configuration.RecordContextRequest(?ctx, ?heapValue, ?var),
  configuration.RecordContextResponse(?ctx, ?heapValue, ?var, ?newHCtx).

VarPointsTo(?hctx, ?heapValue, ?ctx, ?var) :-
  Reachable(?inmethod),  // optimization purposes
  AssignContextInsensitiveHeapAllocation(?heapValue, ?var, ?inmethod),
  ReachableContext(?ctx, ?inmethod),
  isImmutableHContext(?hctx).
  .plan 1:(4,3,2,1)


   

VarPointsTo(?hctx, ?null, ?toCtx, ?to) :-
   Reachable(?inmethod),  // optimization purposes
   AssignNull(?to, ?inmethod),
   Value_Null(?null),
   ReachableContext(?toCtx, ?inmethod),
   isImmutableHContext(?hctx).





// No need to check if type compatible: check is done at original
// inputs to VarPointsTo

VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  VarPointsTo(?hctx, ?value, ?ctx, ?from),
  AssignLocal(?from, ?to, _).


   

VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  OptAssignCast(?type, ?to, ?from),
  VarPointsTo(?hctx, ?value, ?ctx, ?from),
  Value_Type(?value, ?valuetype),
  basic.SupertypeOf(?type, ?valuetype).
 .plan 2:(3,2,1,4)

.decl OptAssignCast(?type:Type, ?to:Var, ?from:Var)
OptAssignCast(?type, ?to, ?from) :-
  Reachable(?inmethod),
  AssignCast(?type, ?from, ?to, ?inmethod).


   

LoadHeapInstanceField(?ctx, ?to, ?sig, ?basehctx, ?basevalue) :-
  LoadInstanceField(?base, ?sig, ?to, _),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

StoreHeapInstanceField(?signature, ?basehctx, ?basevalue, ?ctx, ?from) :-
  StoreInstanceField(?from, ?base, ?signature, _),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).


//// Much slower in Souffle, for large analyses
// VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
//   LoadHeapInstanceField(?ctx, ?to, ?signature, ?basehctx, ?basevalue),
//   InstanceFieldPointsTo(?hctx, ?value, ?signature, ?basehctx, ?basevalue).
//    .plan 1:(2,1)

HeapInterproceduralAssign(?ctxTo, ?to, ?ctxFrom, ?from) :-
  LoadHeapInstanceField(?ctxTo, ?to, ?signature, ?basehctx, ?basevalue),
  StoreHeapInstanceField(?signature, ?basehctx, ?basevalue, ?ctxFrom, ?from),
  !Value_Null(?basevalue).
 .plan 1:(2,1)

VarPointsTo(?hctx, ?value, ?toCtx, ?to) :-
  HeapInterproceduralAssign(?toCtx, ?to, ?fromCtx, ?from),
  VarPointsTo(?hctx, ?value, ?fromCtx, ?from),
  NotSpecialObject(?value).
 .plan 1:(2,1,3), 2:(3,2,1)

VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  LoadHeapInstanceField(?ctx, ?to, ?signature, ?basehctx, ?basevalue),
  InstanceFieldPointsTo(?hctx, ?value, ?signature, ?basehctx, ?basevalue).

InstanceFieldPointsTo(?hctx, ?value, ?signature, ?basehctx, ?basevalue) :-
  StoreHeapInstanceField(?signature, ?basehctx, ?basevalue, ?ctx, ?from),
  VarPointsTo(?hctx, ?value, ?ctx, ?from),
  NotSpecialObject(?value),
  !Value_Null(?basevalue).
 .plan 1:(2,1,3), 2:(3,2,1)










   

VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  StaticFieldPointsTo(?hctx, ?value, ?sig),
  LoadStaticField(?sig, ?to, ?inmethod),
  ReachableContext(?ctx, ?inmethod).

  .plan 1:(3,2,1)



   

StaticFieldPointsTo(?hctx, ?value, ?signature) :-
  ReachableStoreStaticFieldFrom(?from),
  StoreStaticField(?from, ?signature, _),
  VarPointsTo(?hctx, ?value, _, ?from).


.decl ReachableStoreStaticFieldFrom(?from:Var)

ReachableStoreStaticFieldFrom(?from) :-
  Reachable(?inmethod),
  StoreStaticField(?from, _, ?inmethod).




   

// Intermediate relations used for optimization purposes
.decl OptLoadHeapArrayIndex(?var:Var, ?value:Value)
.decl Temp1(?value:Value, ?var:Var)
.decl Temp2(?ctx:configuration.Context, ?var:Var, ?hctx:configuration.HContext, ?value:Value)

OptLoadHeapArrayIndex(?to, ?basevalue) :-
  LoadHeapArrayIndex(_, ?to, _, ?basevalue).

Temp1(?basevalue, ?to) :-
  NotEmptyArrayValue(?basevalue),
  OptLoadHeapArrayIndex(?to, ?basevalue),
  Value_Type(?basevalue, ?basevaluetype),
  ComponentType(?basevaluetype, ?basecomponenttype),
  Var_Type(?to, ?type),
  basic.SupertypeOf(?type, ?basecomponenttype).

Temp2(?ctx, ?to, ?basehctx, ?basevalue) :-
  Temp1(?basevalue, ?to),
  LoadHeapArrayIndex(?ctx, ?to, ?basehctx, ?basevalue).

VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
  Temp2(?ctx, ?to, ?basehctx, ?basevalue),
  ArrayIndexPointsTo(?hctx, ?value, ?basehctx, ?basevalue).

// The above logic aims to optimize the following rule:
//
// VarPointsTo(?hctx, ?value, ?ctx, ?to) :-
//   NotEmptyArrayValue(?basevalue),
//   LoadHeapArrayIndex(?ctx, ?to, ?basehctx, ?basevalue),
//   ArrayIndexPointsTo(?hctx, ?value, ?basehctx, ?basevalue).
//   // this is necessary to handle untyped array operations, e.g., the
//   // simulation of arrayCopy calls as Load/Stores
//   Value_Type(?basevalue, ?basevaluetype),
//   Var_Type(?to, ?type),
//   ComponentType(?basevaluetype, ?basecomponenttype),
//   basic.SupertypeOf(?type, ?basecomponenttype).

.decl NotEmptyArrayValue(?value:Value)

NotEmptyArrayValue(?heapValue) :-
  Value_isHeap(?heapValue),
  isHeapAllocation(?heapValue),
  !HeapAllocation_EmptyArray(?heapValue).
NotEmptyArrayValue(?value) :-
  Value_isNonHeap(?value).

LoadHeapArrayIndex(?ctx, ?to, ?basehctx, ?basevalue) :-
  ReachableLoadArrayIndexBase(?base),
  OptLoadArrayIndex(?to, ?base),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

OptLoadArrayIndex(?to, ?base) :-
  LoadArrayIndex(?base, ?to, _).

.decl ReachableLoadArrayIndexBase(?base:Var)

ReachableLoadArrayIndexBase(?base) :-
  Reachable(?inmethod),
  LoadArrayIndex(?base, _, ?inmethod).


   

.decl OptStoreIntoArray(?hctx:configuration.HContext, ?value:Value, ?basehctx:configuration.HContext, ?basevalue:Value)


OptStoreIntoArray(?hctx, ?value, ?basehctx, ?basevalue) :-
  StoreHeapArrayIndex(?basehctx, ?basevalue, ?ctx, ?from),
  VarPointsTo(?hctx, ?value, ?ctx, ?from).


ArrayIndexPointsTo(?hctx, ?value, ?basehctx, ?basevalue) :-
  OptStoreIntoArray(?hctx, ?value, ?basehctx, ?basevalue),
  NotSpecialObject(?value),
  NotEmptyArrayValue(?basevalue),
  Value_Type(?value, ?valuetype),
  Value_Type(?basevalue, ?basevaluetype),
  ComponentType(?basevaluetype, ?componenttype),
  basic.SupertypeOf(?componenttype, ?valuetype).
 .plan 1:(2,1,3,4,5,6,7),
       2:(3,1,2,4,5,6,7),
       3:(4,1,2,3,5,6,7),
       4:(5,1,2,3,4,6,7)

StoreHeapArrayIndex(?basehctx, ?basevalue, ?ctx, ?from) :-
  ReachableStoreArrayIndexBase(?base),
  OptStoreArrayIndex(?from, ?base),
  VarPointsTo(?basehctx, ?basevalue, ?ctx, ?base).

.decl ReachableStoreArrayIndexBase(?base:Var)

ReachableStoreArrayIndexBase(?base) :-
  Reachable(?inmethod),
  StoreArrayIndex(_, ?base, ?inmethod).

OptStoreArrayIndex(?from, ?base) :-
  StoreArrayIndex(?from, ?base, _).



   

// This logic replaces (optimizes) general-purpose inter-procedural
// assignments for args and returns. It should be unnecessary, but
// Souffle appreciates smaller deltas, since plans cannot change
// per-rule-evaluation, only per-rule-structure.

  

OptArgAssign(?calleeCtx, ?formal, ?callerCtx, ?actual, ?allowedType) :-
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?method),

  ActualParam(?index, ?invocation, ?actual),
  FormalParam(?index, ?method, ?formal),
  Var_Type(?formal, ?allowedType).





VarPointsTo(?hctx, ?value, ?callerCtx, ?local) :-
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?method),
  AssignReturnValue(?invocation, ?local),
  ReturnVar(?return, ?method),
  !SanitizationMethod(?method),
  OptRetVarPointsTo(?hctx, ?value, ?calleeCtx, ?return).
  .plan 1:(4,3,1,2)

VarPointsTo(?hctx, ?value, ?callerCtx, ?local) :-
  CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?method),
  AssignReturnValue(?invocation, ?local),
  ReturnVar(?return, ?method),
  OptRetVarPointsTo(?hctx, ?value, ?calleeCtx, ?return),
  isHeapAllocation(?value).
  .plan 1:(4,5,3,1,2)



OptArgVarPointsTo(?hctx, ?value, ?actualCtx, ?actual) :-
  VarPointsTo(?hctx, ?value, ?actualCtx, ?actual),
  ActualParam(_, _, ?actual).

OptRetVarPointsTo(?hctx, ?value, ?returnCtx, ?return) :-
  VarPointsTo(?hctx, ?value, ?returnCtx, ?return),
  ReturnVar(?return, _).



VarPointsTo(?hctx, ?value, ?toCtx, ?to) :-
  OptArgVarPointsTo(?hctx, ?value, ?fromCtx, ?from),
  OptArgAssign(?toCtx, ?to, ?fromCtx, ?from, ?allowedType),
  Value_Type(?value, ?type),
  basic.SubtypeOf(?type, ?allowedType),
  isHeapAllocation(?value).
  .plan 1:(2,1,3,4,5), 2:(3,1,2,4,5)

VarPointsTo(?hctx, ?value, ?toCtx, ?to) :-
  OptArgVarPointsTo(?hctx, ?value, ?fromCtx, ?from),
  OptArgAssign(?toCtx, ?to, ?fromCtx, ?from, ?allowedType),
  Value_Type(?value, ?type),
  basic.SubtypeOf(?type, ?allowedType),
  Var_DeclaringMethod(?to, ?meth),
  !SanitizationMethod(?meth).
  .plan 1:(2,1,3,4,5), 2:(3,1,2,4,5)





   

// No longer using general-purpose inter-procedural assignments for lots
// of different flows. Souffle cannot optimize well. Best to break up
// key cases (like arg-return flow, above) into separate, well-optimized rules.
VarPointsTo(?hctx, ?value, ?toCtx, ?to) :-
  OptInterproceduralAssign(?toCtx, ?to, ?fromCtx, ?from),
  VarPointsTo(?hctx, ?value, ?fromCtx, ?from).
//  .plan 1:(2,1)
//// no plan for now. These kinds of inter-proc assignments should be very few!



   

.decl OptVirtualMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)

OptVirtualMethodInvocationBase(?invocation, ?base) :-
  Reachable(?inmethod),
  Instruction_Method(?invocation, ?inmethod),
  VirtualMethodInvocation_Base(?invocation, ?base).

// The optimization/advanced merge treatment is as follows: the main
// analysis (this file) first creates all the possible bindings that
// the Merge logic might need to create a new context. (It uses
// ContextRequest to communicate these bindings to the individual
// context-sensitive analysis.) Then each individual analysis creates
// new context objects by employing arbitrary logic, and communicates
// back to the main analysis the results of context creation using
// ContextResponse.
configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, 1) :-
  OptVirtualMethodInvocationBase(?invocation, ?base),
  VarPointsTo(?hctx, ?value, ?callerCtx, ?base),
  Value_Type(?value, ?valuetype),
  basic.ResolveInvocation(?valuetype, ?invocation, ?tomethod).

// The main analysis is merely looking up the previously created
// context objects.


VarPointsTo(?hctx, ?value, ?calleeCtx, ?this) :-
  configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, _),
  configuration.ContextResponse(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, ?calleeCtx),
  ThisVar(?tomethod, ?this),
  !Value_Null(?value).

 .plan 1:(2,1,3)





   

.decl OptSuperMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)

OptSuperMethodInvocationBase(?invocation, ?base) :-
  Reachable(?inmethod),
  Instruction_Method(?invocation, ?inmethod),
  SuperMethodInvocation_Base(?invocation, ?base).

configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, 1) :-
  OptSuperMethodInvocationBase(?invocation, ?base),
  VarPointsTo(?hctx, ?value, ?callerCtx, ?base),
  MethodInvocation_Method(?invocation, ?tomethod).


   

.decl OptSpecialMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)

OptSpecialMethodInvocationBase(?invocation, ?base) :-
  Reachable(?inmethod),
  Instruction_Method(?invocation, ?inmethod),
  SpecialMethodInvocation_Base(?invocation, ?base).

configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, 1) :-
  OptSpecialMethodInvocationBase(?invocation, ?base),
  VarPointsTo(?hctx, ?value, ?callerCtx, ?base),
  MethodInvocation_Method(?invocation, ?tomethod).


   
ReachableContext(?ctx, ?method) :-
  CallGraphEdge(_, _, ?ctx, ?method).

Reachable(?method) :-
  ReachableContext(_, ?method).

ReachableClass(?class) :-
  mainAnalysis.Reachable(?method),
  Method_DeclaringType(?method, ?class).

.decl AppReachable(?method:Method)

AppReachable(?method) :-
  Reachable(?method),
  ApplicationMethod(?method).



// Reachable methods should make their annotations reachable.

.decl ReachableAnnotationMethod(?method:Method, ?annotation:Annotation)

ReachableAnnotationMethod(?annotMethod, ?annotation) :-
  ReachableContext(_, ?method),
  Method_Annotation(?method, ?annotation),
  Method_DeclaringType(?annotMethod, ?annotation).
// Annotation methods are abstract, so we don't mock the receiver or the parameters.
ReachableContext(?ctx0, ?annotMethod) :-
  ReachableAnnotationMethod(?annotMethod, _),
  isImmutableContext(?ctx0).






// Core mocking rule.
Value_isMock(?value), isValue(?value), Value_Type(?value,  ?type), Value_DeclaringType(?value, "java.lang.Object"),
VarPointsTo(?hctx, ?value, ?ctx, ?return) :-
  Instruction_Method(?invocation, ?inmethod),
  ReachableContext(?ctx, ?inmethod),
  MethodInvocation_Method(?invocation, ?method),
  MockedMethodReturns(?method, ?value, ?type),
  AssignReturnValue(?invocation, ?return),
  isImmutableHContext(?hctx).

// A relation that gathers all call-graph information.

.decl AnyCallGraphEdge(?instr:Instruction, ?method:Method)

AnyCallGraphEdge(?i, ?m) :- CallGraphEdge(_, ?i, _, ?m).
AnyCallGraphEdge(?i, ?m) :- InvokedynamicBootCallGraphEdge(_, ?i, _, ?m).
AnyCallGraphEdge(?i, ?m) :- LambdaCallGraphEdge(_, ?i, _, ?m, _).
AnyCallGraphEdge(?i, ?m) :- MethodHandleCallGraphEdge(_, ?i, _, ?m, _, _).







AnyCallGraphEdge(?i, ?m) :- OpaqueCallGraphEdge(?i, ?m).




// Metrics are always written, even when the other standard outputs are skipped.
.output Stats_Metrics(IO="file",filename="Stats_Metrics.csv",delimiter="\t")




// It is possible to have multiple relations in an .output statement
// e.g. .output CallGraphEdge, VarPointsTo

.output CallGraphEdge(IO="file",filename="CallGraphEdge.csv",delimiter="\t")
.output AnyCallGraphEdge(IO="file",filename="AnyCallGraphEdge.csv",delimiter="\t")

.output VarPointsTo(IO="file",filename="VarPointsTo.csv",delimiter="\t")
.output ReachableContext(IO="file",filename="ReachableContext.csv",delimiter="\t")
.output InstanceFieldPointsTo(IO="file",filename="InstanceFieldPointsTo.csv",delimiter="\t")
.output StaticFieldPointsTo(IO="file",filename="StaticFieldPointsTo.csv",delimiter="\t")
//.output ArrayIndexPointsTo(IO="file",filename="ArrayIndexPointsTo.csv",delimiter="\t")


.output Reachable(IO="file",filename="Reachable.csv",delimiter="\t")

// It is possible to output facts in an sqlite3 db.
// .output CallGraphEdge(IO=sqlite, dbname="test.db", name=CallGraphEdge)
// .output VarPointsTo(IO=sqlite, dbname="test.db", name=VarPointsTo)





// Dynamic proxies supports two kinds of reflection: standard reflection and
// light reflection (just Class object handling or light-reflection-glue).







// // First make all methods be opaque if not app!
// isOpaqueMethod(?signature) :-
//   isMethod(?signature),
//   !ApplicationMethod(?signature).

.decl isMethodSuperOfApplicationMethod(?signature: Method)

// Avoid this issue:
// [Negations with relatively grounded variables · Issue #730 · souffle-lang/souffle (github.com)]
// (https://github.com/souffle-lang/souffle/issues/730)
isMethodSuperOfApplicationMethod(?signature) :-
  basic.MethodOverridesOther(?methodSub, ?signature),
  ApplicationMethod(?methodSub).

// Fixed code:
// ?signature maybe is the methodSuper of ApplicationMethod(?methodSub)
isOpaqueMethod(?signature) :-
  isMethod(?signature), 
  !isMethodSuperOfApplicationMethod(?signature),
  !ApplicationMethod(?signature).

// Next, treat opaque methods as stores/loads
.decl OpaqueMethodInvocation(?instruction:MethodInvocation, ?base:Var, ?sigCallee:Method)
OpaqueMethodInvocation(?instruction, ?base, ?sigCallee) :-
  (SpecialMethodInvocation_Base(?instruction, ?base);
   VirtualMethodInvocation_Base(?instruction, ?base)),
  MethodInvocation_Method(?instruction, ?sigCallee),
  isOpaqueMethod(?sigCallee). 

.decl OpaqueMethodInvocationParam(?instruction:MethodInvocation, ?base:Var, ?param:Var)
OpaqueMethodInvocationParam(?instruction, ?base, ?param) :-
  OpaqueMethodInvocation(?instruction, ?base, _),
  ActualParam(_, ?instruction, ?param).

.decl OpaqueMethodInvocationReturn(?instruction:MethodInvocation, ?base:Var, ?ret:Var)
OpaqueMethodInvocationReturn(?instruction, ?base, ?ret) :-
  OpaqueMethodInvocation(?instruction, ?base, _),
  AssignReturnValue(?instruction, ?ret).

.decl FakeStoreInstanceField(?basehctx:configuration.HContext, ?baseVal:Value, ?ctx:configuration.Context, ?from:Var)
FakeStoreInstanceField(?basehctx, ?baseVal, ?ctx, ?from) :-
  OpaqueMethodInvocationParam(_, ?base, ?from),
  VarPointsTo(?basehctx, ?baseVal, ?ctx, ?base).

.decl FakeLoadInstanceField(?basehctx:configuration.HContext, ?baseVal:Value, ?ctx:configuration.Context, ?to:Var, ?toType:Type)
FakeLoadInstanceField(?basehctx, ?baseVal, ?ctx, ?ret, ?type) :-
  OpaqueMethodInvocationReturn(_, ?base, ?ret),
  VarPointsTo(?basehctx, ?baseVal, ?ctx, ?base),
  Var_Type(?ret, ?type).

.decl FakeInstanceFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?valType:Type, ?basehctx:configuration.HContext, ?basevalue:Value)
FakeInstanceFieldPointsTo(?hctx, ?val, ?valType, ?basehctx, ?baseVal) :-
  FakeStoreInstanceField(?basehctx, ?baseVal, ?ctx, ?from),
  VarPointsTo(?hctx, ?val, ?ctx, ?from),
  Value_Type(?val, ?valType).
 .plan 1:(2,1,3)

VarPointsTo(?hctx, ?val, ?ctx, ?ret) :-
  FakeLoadInstanceField(?basehctx, ?baseVal, ?ctx, ?ret, ?retType),
  FakeInstanceFieldPointsTo(?hctx, ?val, ?valType, ?basehctx, ?baseVal),
  basic.SubtypeOf(?valType, ?retType).
 .plan 1:(2,1,3)




// Consider phantom types to be indications of dead code. The
// following rules compute possible dead methods/types.

// PhantomInvoke records invocations to methods of phantom types or to
// just phantom methods (methods missing from existing types).

.decl PhantomInvoke(?instruction:Instruction)

PhantomInvoke(?instruction),
isUnsupportedInstruction(?instruction) :-
  MethodInvocation_Method(?instruction, ?method),
  Method_DeclaringType(?method, ?pt),
  PhantomType(?pt).

PhantomInvoke(?instruction),
isUnsupportedInstruction(?instruction) :-
  MethodInvocation_Method(?instruction, ?method),
  PhantomMethod(?method).

.decl DeadInstruction(?i:Instruction)

// An instruction is dead if it involves a phantom type.

DeadInstruction(?instruction) :-
  AssignHeapAllocation_Heap(?instruction, ?heap),
  HeapAllocation_Type(?heap, ?pt),
  PhantomType(?pt).

DeadInstruction(?instruction) :-
  (AssignCast_Type(?instruction, ?pt);
   AssignInstanceOf_Type(?instruction, ?pt)),
  PhantomType(?pt).

DeadInstruction(?instruction) :-
  PhantomInvoke(?instruction).

// Recursively, an invocation instruction is dead if it calls a dead method.

DeadInstruction(?instruction) :-
  MethodInvocation_Method(?instruction, ?method),
  DeadMethod(?method).

.decl DeadMethod(?m:Method)

// A method is dead if it contains a dead instruction or is
// phantom-based (i.e. the method signature contains a phantom type).
DeadMethod(?m) :- Instruction_Method(?i, ?m), DeadInstruction(?i).
DeadMethod(?m) :- PhantomBasedMethod(?m).

.decl DeadType(?type:Type)

// Dead types (a) contain field or method signatures involving phantom
// types, or (b) contain dead methods.

DeadType(?type) :-
  Field_DeclaringType(?sig, ?type),
  Field_Type(?sig, ?pt),
  PhantomType(?pt).

DeadType(?type) :-
  PhantomBasedMethod(?m),
  Method_DeclaringType(?m, ?type).

DeadType(?type) :-
  DeadMethod(?m),
  Method_DeclaringType(?m, ?type).

// Removed methods are phantom methods belonging to non-phantom
// types. Examples of this: (a) removing methods from a class via bytecode
// engineering, (b) a piece of code using a wrong version of a library.

.decl RemovedMethod(?method:Method)

RemovedMethod(?method) :-
  PhantomMethod(?method),
  Method_DeclaringType(?method, ?type),
  !PhantomType(?type).


  .init configuration = Configuration
}
















.comp BasicContextSensitivity<Configuration> : AbstractContextSensitivity<Configuration> {

configuration.StaticContextRequest(?callerCtx, ?invocation) :-
  ReachableContext(?callerCtx, ?inmethod),
  StaticMethodInvocation(?invocation, _, ?inmethod).

// The main analysis is merely looking up the previously created
// context objects.


// Original rules

isContext(?calleeCtx),
CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod) :-
  configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, 1),
  configuration.ContextResponse(?callerCtx, ?hctx, ?invocation, ?value, ?tomethod, ?calleeCtx).

 .plan 1:(2,1)


isContext(?calleeCtx),
CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?tomethod) :-
  configuration.StaticContextResponse(?callerCtx, ?invocation, ?calleeCtx),
  MethodInvocation_Method(?invocation, ?tomethod).


}


.init mainAnalysis = BasicContextSensitivity<ContextInsensitiveConfiguration>

.comp AbstractConfiguration {

  .decl ContextRequest(?ctx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?value:Value, ?method:Method, ?createCGE:number)
  .decl StaticContextRequest(?ctx:configuration.Context, ?invo:MethodInvocation)

  .decl ContextResponse(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?value:Value, ?method:Method, ?calleeCtx:Context)
  .decl StaticContextResponse(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?calleeCtx:Context)

  .decl RecordContextRequest(?callerCtx:configuration.Context, ?value:Value, ?var:Var)
  .decl RecordContextResponse(?callerCtx:configuration.Context, ?value:Value, ?var:Var, ?hctx:configuration.HContext)

  .decl InitContextRequest(?symbol:symbol)
  .decl InitContextResponse(?symbol:symbol, ?context:Context)

  .decl InitHContextRequest(?symbol:symbol)  
  .decl InitHContextResponse(?symbol:symbol, ?hcontext:HContext)
}

 
// This analysis has no context for either method calls or heap objects.
// This is emulated by creating a single Context object and a single HContext
// object, which are used everywhere.


.comp ContextInsensitiveConfiguration : AbstractConfiguration {

  .type Context = symbol
  .type HContext = symbol

  ContextResponse(?callerCtx, ?hctx, ?invo, ?value, ?tomethod, ?calleeCtx) :-
    ContextRequest(?callerCtx, ?hctx, ?invo, ?value, ?tomethod, _),
    ?calleeCtx = ?callerCtx.

  StaticContextResponse(?callerCtx, ?invo, ?calleeCtx) :-
    StaticContextRequest(?callerCtx, ?invo),
    ?calleeCtx = ?callerCtx.
      
   
      
  RecordContextResponse(?ctx, ?value, ?var, ?hctx) :-
    RecordContextRequest(?ctx, ?value, ?var),
    isImmutableHContext(?hctx).

  InitContextResponse(?s, ?ctx) :-
    ?ctx = "<<immutable-context>>",
    InitContextRequest(?s).

  InitHContextResponse(?s, ?hctx) :-
    ?hctx = "<<immutable-hcontext>>",
    InitHContextRequest(?s).


}




















// Copy of MockValueConsMacro but with proper component qualifers.












// Android-specific macro to qualify unqualified types in layout controls.
// Heuristic: if the name is unqualified, it may come from android.view or
// android.widget ("Android Programming: The Big Nerd Ranch Guide", chapter 32).








// id 为 invocation instruction







.type InformationLabel = symbol
.decl isInformationLabel(?id:symbol)


.decl TaintSpec(?type:symbol, ?tag:symbol, ?id:symbol)
.input TaintSpec(filename="TaintSpec.facts")

// Use macro to substitute to handle context types when points-to reasoning is disabled.


// Declaration of a taint source method.
.decl TaintSourceMethod(?label:InformationLabel, ?method:Method)
// Declaration of a taint source method, including all methods that override it.
.decl TaintSourceMethodWithOverrides(?label:InformationLabel, ?method:Method)

.decl LeakingSinkMethod(?lable:InformationLabel, ?method:Method)
.decl LeakingSinkMethodArg(?label:InformationLabel, ?index:number, ?method:Method)
.decl LeakingSinkVariable(?label:InformationLabel, ?tomethod:MethodInvocation, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
.decl SanitizationMethod(?method:Method)
.decl BaseToRetTaintTransferMethod(?method:Method)
.decl BaseToParamTaintTransferMethod(?method:Method)
.decl ParamToBaseTaintTransferMethod(?index:number, ?method:Method)
.decl ParamIndexToBaseTaintTransferMethod(?index:number, ?method:Method)
.decl ParamToRetTaintTransferMethod(?method:Method)
.decl MockBaseToRetTaintTransferMethod(?meth:Method)
.decl MockParamToRetTaintTransferMethod(?meth:Method)
.decl VarIsCast(?var:Var)
.decl VarUse(?var:Var, ?inst:Instruction)
.decl LabelFromSource(?source:symbol, ?label:InformationLabel)
.decl AnyMethodInvocation(?invocation:MethodInvocation, ?tomethod:Method)
.decl MethodInvocationInfo(?invocation:MethodInvocation, ?type:Type, ?var:Var)
.decl TypeForReturnValue(?type:Type, ?ret:Var, ?invocation:MethodInvocation)

.decl MethodInvocationInContext(?ctx:mainAnalysis.configuration.Context, ?invocation:MethodInvocation, ?tomethod:Method)
.decl MethodInvocationInContextInApplication(?ctx:mainAnalysis.configuration.Context, ?invocation:MethodInvocation, ?method:Method)
.decl CallTaintingMethod(?label:InformationLabel, ?ctx:mainAnalysis.configuration.Context, ?invocation:MethodInvocation)
.decl ParamTaintTransferredToBase(?param:Var, ?ctx:mainAnalysis.configuration.Context, ?base:Var)
.decl ParamTaintTransferredToRet(?type:Type, ?ret:Var, ?ctx:mainAnalysis.configuration.Context, ?param:Var)
.decl VarIsTaintedFromVar(?type:Type, ?ctx1:mainAnalysis.configuration.Context, ?var1:Var, ?ctx2:mainAnalysis.configuration.Context, ?var2:Var)
.decl VarIsTaintedFromVarIndex(?base:Var, ?ctx1:mainAnalysis.configuration.Context, ?param:Var)
.decl TaintTransferMethodInvocationInContext(?ctx:mainAnalysis.configuration.Context, ?index:number, ?invocation:MethodInvocation)
.decl LeakingTaintedInformation(?fromLabel:InformationLabel, ?toLabel:InformationLabel, ?ctx:mainAnalysis.configuration.Context,
                                ?invocation:MethodInvocation, ?value:symbol)
.output LeakingTaintedInformation                                
.decl LeakingTaintedInformationVars(?fromCtx:mainAnalysis.configuration.Context, ?from:Var, ?toCtx:mainAnalysis.configuration.Context, ?to:Var)
.output LeakingTaintedInformationVars



.decl TaintedValue(?value:Value)

.decl SourceFromTaintedValue(?value:Value, ?id:symbol)
.decl TaintedValueTransferred(?declaringType:Type, ?id:symbol, ?type:Type, ?value:Value)

.decl TaintedObjectSerialized(?declaringType:Type, ?source:symbol, ?type:Type, ?hctx:mainAnalysis.configuration.HContext, ?val:Value, ?ctx:mainAnalysis.configuration.Context, ?base:Var)
.decl VarIsTaintedFromValue(?type:Type, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
.decl TaintedVarTaintedFromVar(?toCtx:mainAnalysis.configuration.Context, ?to:Var, ?value:Value, ?type:Type)
.decl MethodReturningStringFactory(?tomethod:Method)
.decl StringFactoryReturnInvocation(?invocation:MethodInvocation)

.decl TaintedVarPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
.decl VarIsTaintedFromValueIndex(?ctx:mainAnalysis.configuration.Context, ?base:Var, ?hctx:mainAnalysis.configuration.HContext, ?value:Value)

.decl TaintObjTransfer(fromCtx:mainAnalysis.configuration.Context, from:Var, toCtx:mainAnalysis.configuration.Context, to:Var)




isInformationLabel("default").
isInformationLabel("Location").
isInformationLabel("Telephony").
isInformationLabel("Bundle").
isInformationLabel("OS").
isInformationLabel("Personal").
isInformationLabel("IPC").
isInformationLabel("Persistence").
isInformationLabel("IO").
isInformationLabel("Net").
isInformationLabel("PASSWORD").
isInformationLabel("SENSITIVE_CONTROL").




AnyMethodInvocation(?invocation, ?tomethod) :-
  StaticMethodInvocation(?invocation, ?tomethod, _).

AnyMethodInvocation(?invocation, ?tomethod) :-
  VirtualMethodInvocation(?invocation, ?tomethod, _).

AnyMethodInvocation(?invocation, ?tomethod) :-
  MethodInvocation_Method(?invocation, ?tomethod),
  isSpecialMethodInvocation_Insn(?invocation).

VarUse(?from, ?insn) :-
  AssignOper_From(?insn, _, ?from).

LeakingSinkMethodArg(?label, ?index, ?method) :-
  LeakingSinkMethod(?label, ?method),
  FormalParam(?index, ?method, _).

MethodInvocationInfo(?invocation, ?type, ?ret) :-
  Method_ReturnType(?method, ?type),
  AnyMethodInvocation(?invocation, ?method),
  AssignReturnValue(?invocation, ?ret).

VarIsCast(?var) :-
  AssignCast(_, ?var, _, _).

TypeForReturnValue(?type, ?ret, ?invocation) :-
  MethodInvocationInfo(?invocation, ?type, ?ret),
  !VarIsCast(?ret).

CallTaintingMethod(?label, ?ctx, ?invocation) :-
  TaintSourceMethod(?label, ?tomethod),
  MethodInvocationInContext(?ctx, ?invocation, ?tomethod),
  Instruction_Method(?invocation, ?inmethod),
  ApplicationMethod(?inmethod).


   
TaintTransferMethodInvocationInContext(?ctx, ?index, ?invocation) :-
  MethodInvocationInContext(?ctx, ?invocation, ?taintTransferMethod),
  ParamToBaseTaintTransferMethod(?index, ?taintTransferMethod).

ParamTaintTransferredToBase(?param, ?ctx, ?base) :-
  TaintTransferMethodInvocationInContext(?ctx, ?index, ?invocation),
  ActualParam(?index, ?invocation, ?param),
  MethodInvocation_Base(?invocation, ?base),
  !AssignReturnValue(?invocation, _).

MethodInvocationInContextInApplication(?ctx, ?invocation, ?method) :-
  ApplicationMethod(?fromMethod),
  Instruction_Method(?invocation, ?fromMethod),
  MethodInvocationInContext(?ctx, ?invocation, ?method).

ParamTaintTransferredToRet(?type, ?ret, ?ctx, ?param) :-
  ParamToRetTaintTransferMethod(?taintTransferMethod),
  MethodInvocationInContextInApplication(?ctx, ?invocation, ?taintTransferMethod),
  ActualParam(_, ?invocation, ?param),
  TypeForReturnValue(?type, ?ret, ?invocation).


   
VarIsTaintedFromVar(?type, ?ctx, ?param, ?ctx, ?base) :-
   MethodInvocationInContextInApplication(?ctx, ?invocation, ?method),
   BaseToParamTaintTransferMethod(?method),
   MethodInvocation_Base(?invocation, ?base),
   ActualParam(_, ?invocation, ?param),
   Var_Type(?param, ?type).

VarIsTaintedFromVar(?type, ?ctx, ?ret, ?ctx, ?base) :-
  BaseToRetTaintTransferMethod(?method),
  MethodInvocationInContext(?ctx, ?invocation, ?method),
  MethodInvocation_Base(?invocation, ?base),
  TypeForReturnValue(?type, ?ret, ?invocation).

VarIsTaintedFromVarIndex(?base, ?ctx, ?param) :-
   MethodInvocationInContext(?ctx, ?invocation, ?method),
   ParamIndexToBaseTaintTransferMethod(?index, ?method),
   MethodInvocation_Base(?invocation, ?base),
   ActualParam(?index, ?invocation, ?param).


   
LeakingSinkVariable(?label, ?invocation, ?ctx, ?var) :-
  LeakingSinkMethodArg(?label, ?index, ?tomethod),
  MethodInvocationInContextInApplication(?ctx, ?invocation, ?tomethod),
  ActualParam(?index, ?invocation, ?var).

// In case method has no arguments, assume base variable.
LeakingSinkVariable(?label, ?invocation, ?ctx, ?var) :-
   LeakingSinkMethod(?label, ?tomethod),
   !FormalParam(_, ?tomethod, _),
   MethodInvocationInContextInApplication(?ctx, ?invocation, ?tomethod),
   MethodInvocation_Base(?invocation, ?var).

TaintSourceMethod(?label, ?method) :-
  TaintSourceMethodWithOverrides(?label, ?method).
TaintSourceMethod(?label, ?overrideMethod) :-
  TaintSourceMethodWithOverrides(?label, ?method),
  basic.MethodOverridesOther(?overrideMethod, ?method).

// User-provided taint sources (methods).
TaintSourceMethod(?label, ?method) :-
  TaintSpec("TAINT_SOURCE", ?label, ?method),
  isMethod(?method).
// User-provided taint sinks (methods).
LeakingSinkMethod(?label, ?method) :-
  TaintSpec("TAINT_SINK", ?label, ?method),
  isMethod(?method).



TaintObjTransfer(?fromCtx, ?from, ?toCtx, ?to),
TaintedVarTaintedFromVar(?toCtx, ?to, ?value, ?type) :-
  VarIsTaintedFromVar(?type, ?toCtx, ?to, ?fromCtx, ?from),
  TaintedVarPointsTo(?value, ?fromCtx, ?from).
  .plan 1:(2,1)

mainAnalysis.Value_isMock(?value), isValue(?value), mainAnalysis.Value_Type(?value,  ?type), mainAnalysis.Value_DeclaringType(?value, "java.lang.Object"),
TaintedValue(?value),
SourceFromTaintedValue(?value, ?source),
mainAnalysis.Value_DeclaringType(?value, ?declaringType) :-
  TaintedValueTransferred(?declaringType, ?source, ?type, ?value).

TaintedValueTransferred(?declaringType, ?source, ?type, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN")),
mainAnalysis.VarPointsTo(?hctx, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN"), ?toCtx, ?to) :-
  TaintedVarTaintedFromVar(?toCtx, ?to, ?value, ?type),
  SourceFromTaintedValue(?value, ?source),
  mainAnalysis.Value_DeclaringType(?value, ?declaringType),
  mainAnalysis.isImmutableHContext(?hctx).
  .plan 2:(3,1,2,4)

TaintedValueTransferred(?declaringType, ?source, ?type, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN")),
mainAnalysis.VarPointsTo(?hctx, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN"), ?toCtx, ?to) :-
  SourceFromTaintedValue(?value, ?source),
  mainAnalysis.Value_DeclaringType(?value, ?declaringType),
  VarIsTaintedFromValue(?type, ?value, ?toCtx, ?to),
  mainAnalysis.isImmutableHContext(?hctx).

// I expect the first rel to be very small, smaller than
// the deltas of VPT or AIPT
VarIsTaintedFromValueIndex(?ctx, ?base, ?hctx, ?value) :-
   VarIsTaintedFromVarIndex(?base, ?ctx, ?param),
   mainAnalysis.VarPointsTo(?hctx, ?value, ?ctx, ?param).

VarIsTaintedFromValue(?type, ?valueIndex, ?ctx, ?base) :-
  VarIsTaintedFromValueIndex(?ctx, ?base, ?hctx, ?value),
  mainAnalysis.ArrayIndexPointsTo(_, ?valueIndex, ?hctx, ?value),
  Var_Type(?base, ?type).




   
.decl AppendableType(?type:Type)

AppendableType("java.lang.Appendable").

AppendableType(?type) :-
   basic.SubtypeOf(?type, ?sft),
   AppendableType(?sft).

mainAnalysis.StringFactoryType("java.lang.String").

mainAnalysis.StringFactoryType(?type) :-
   AppendableType(?type).



mainAnalysis.StringFactoryVar(?var) :-
  mainAnalysis.StringFactoryType(?type),
  Var_Type(?var, ?type).

mainAnalysis.StringFactoryVarPointsTo(?factoryHctx, ?factoryValue, ?ctx, ?var) :-
  mainAnalysis.StringFactoryVar(?var),
  mainAnalysis.VarPointsTo(?factoryHctx, ?factoryValue, ?ctx, ?var).

.decl AppendInvocation_Base(?invocation:MethodInvocation, ?base:Var)

AppendInvocation_Base(?invocation, ?base) :-
  VirtualMethodInvocation_SimpleName(?invocation, "append"),
  VirtualMethodInvocation_Base(?invocation, ?base).

VarIsTaintedFromVar(?type, ?ctx, ?ret, ?ctx, ?base),
VarIsTaintedFromVar(?type, ?ctx, ?ret, ?ctx, ?param) :-
  AppendInvocation_Base(?invocation, ?base),
  mainAnalysis.StringFactoryVarPointsTo(_, _, ?ctx, ?base),
  AssignReturnValue(?invocation, ?ret),
  Var_Type(?ret, ?type),
  ActualParam(0, ?invocation, ?param).

VarIsTaintedFromVar(?type, ?ctx, ?base, ?ctx, ?param) :-
  AppendInvocation_Base(?invocation, ?base),
  mainAnalysis.StringFactoryVarPointsTo(_, _, ?ctx, ?base),
  Var_Type(?base, ?type),
  ActualParam(0, ?invocation, ?param).



MethodReturningStringFactory(?tomethod) :-
  mainAnalysis.StringFactoryType(?stringFactoryType),
  Method_ReturnType(?tomethod, ?stringFactoryType).

StringFactoryReturnInvocation(?invocation) :-
  MethodReturningStringFactory(?tomethod),
  VirtualMethodInvocation(?invocation, ?tomethod, _).


VarIsTaintedFromVar(?type, ?ctx, ?ret, ?ctx, ?base) :-
  mainAnalysis.StringFactoryVarPointsTo(_, _, ?ctx, ?base),
  VirtualMethodInvocation_Base(?invocation, ?base),
  StringFactoryReturnInvocation(?invocation),
  AssignReturnValue(?invocation, ?ret),
  Var_Type(?ret, ?type).

VarIsTaintedFromValue(?componentType, ?basevalue, ?ctx, ?to) :-
  TaintedValue(?basevalue),
  mainAnalysis.Value_Type(?basevalue, ?arrayType),
  ComponentType(?arrayType, ?componentType),
  mainAnalysis.LoadHeapArrayIndex(?ctx, ?to, _, ?basevalue).

TypeForReturnValue(?type, ?ret, ?invocation) :-
  mainAnalysis.OptAssignCast(?type, _, ?ret),
  MethodInvocationInfo(?invocation, _, ?ret).

TaintObjTransfer(?ctx, ?from, ?ctx, ?to),
TaintedValueTransferred(?declaringType, ?source, ?type, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN")),
mainAnalysis.VarPointsTo(?hctx, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN"), ?ctx, ?to) :-
  SourceFromTaintedValue(?value, ?source),
  mainAnalysis.Value_DeclaringType(?value, ?declaringType),
  TaintedVarPointsTo(?value, ?ctx, ?from),
  ParamTaintTransferredToRet(?type, ?to, ?ctx, ?from),
  mainAnalysis.isImmutableHContext(?hctx).

// Rules for taint propagation through mock taint objects (without a concrete type)
TaintObjTransfer(?ctx, ?param, ?ctx, ?to),
TaintedValueTransferred(?declaringType, ?source, ?type, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN")),
mainAnalysis.VarPointsTo(?hctx, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN"), ?ctx, ?to) :-
  TaintedVarPointsTo(?value, ?ctx, ?param),
  ActualParam(_, ?invo, ?param),
  MethodInvocation_Method(?invo, ?meth),
  MockParamToRetTaintTransferMethod(?meth),
  AssignReturnValue(?invo, ?to),
  Var_Type(?to, ?type),
  mainAnalysis.Value_DeclaringType(?value, ?declaringType),
  SourceFromTaintedValue(?value, ?source),
  mainAnalysis.isImmutableHContext(?hctx).
.plan 1:(7,1,2,3,4,5,6,8,9),2:(8,1,2,3,4,5,6,7,9)

TaintedValueTransferred(?declaringType, ?source, ?type, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN")),
mainAnalysis.VarPointsTo(?hctx, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN"), ?ctx, ?to) :-
  TaintedVarPointsTo(?value, ?ctx, ?from),
  AssignCast(_, ?from, ?to, _),
  mainAnalysis.Value_DeclaringType(?value, ?declaringType),
  SourceFromTaintedValue(?value, ?source),
  Var_Type(?to, ?type),
  mainAnalysis.isImmutableHContext(?hctx).
.plan 1:(3,1,2,4,5,6),2:(4,1,2,3,5,6)

TaintObjTransfer(?ctx, ?base, ?ctx, ?to),
TaintedValueTransferred(?declaringType, ?source, ?type, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN")),
mainAnalysis.VarPointsTo(?hctx, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN"), ?ctx, ?to) :-
  TaintedVarPointsTo(?value, ?ctx, ?base),
  VirtualMethodInvocation_Base(?invo, ?base),
  MethodInvocation_Method(?invo, ?meth),
  MockBaseToRetTaintTransferMethod(?meth),
  AssignReturnValue(?invo, ?to),
  Var_Type(?to, ?type),
  mainAnalysis.Value_DeclaringType(?value, ?declaringType),
  SourceFromTaintedValue(?value, ?source),
  mainAnalysis.isImmutableHContext(?hctx).
.plan 1:(7,1,2,3,4,5,6,8,9),2:(8,1,2,3,4,5,6,7,9)


.decl XYZ2(?type:Type, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?param:Var)

XYZ2(?type, ?value, ?ctx, ?param) :-
  ParamTaintTransferredToBase(?param, ?ctx, ?base),
  mainAnalysis.VarPointsTo(_, ?value, ?ctx, ?base),
  mainAnalysis.Value_isHeap(?value),
  mainAnalysis.Value_Type(?value, ?type).

TaintObjTransfer(?ctx, ?from, ?ctx, ?var),
TaintedValueTransferred(?declaringType, ?source, ?type, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN")),
mainAnalysis.VarPointsTo(?hctx, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN"), ?ctx, ?var) :-
  XYZ2(?type, ?oldvalue, ?ctx, ?from),
  TaintedVarPointsTo(?value, ?ctx, ?from),
  mainAnalysis.AssignNormalHeapAllocation(?oldvalue, ?var, _),
  SourceFromTaintedValue(?value, ?source),
  mainAnalysis.Value_DeclaringType(?value, ?declaringType),
  mainAnalysis.isImmutableHContext(?hctx).



// Option 2
MethodInvocationInContext(?ctx, ?invocation, ?tomethod) :-
  mainAnalysis.CallGraphEdge(?ctx, ?invocation, _, ?tomethod).


// This captures the pattern x = invokedynamic(y) and transfers taint from
// y to x, when such an instruction is marked with AssignInvokedynamic.
VarIsTaintedFromVar(?type, ?ctx, ?ret, ?ctx, ?arg) :-
  mainAnalysis.AssignInvokedynamic(?insn, ?ret, _, ?type),
  ActualParam(_, ?insn, ?arg),
  TaintedVarPointsTo(_, ?ctx, ?arg).


   
LeakingTaintedInformation(?sourceLabel, ?destLabel, ?ctx, ?invocation, ?source) :-
  SourceFromTaintedValue(?value, ?source),
  LabelFromSource(?source, ?sourceLabel),
  TaintedVarPointsTo(?value, ?ctx, ?var),
  LeakingSinkVariable(?destLabel, ?invocation, ?ctx, ?var).

LeakingTaintedInformationVars(?fromCtx, ?from, ?toCtx, ?to) :-
  TaintedVarPointsTo(?value, ?toCtx, ?to),
  LeakingSinkVariable(_, _, ?toCtx, ?to),
  SourceFromTaintedValue(?value, ?from),
  Var_DeclaringMethod(?from, ?meth),
  mainAnalysis.ReachableContext(?fromCtx, ?meth).

LeakingTaintedInformationVars(?fromCtx, ?from, ?toCtx, ?to) :-
  TaintedVarPointsTo(?value, ?toCtx, ?to),
  LeakingSinkVariable(_, _, ?toCtx, ?to),
  SourceFromTaintedValue(?value, ?source),
  AssignReturnValue(?source, ?from),
  TaintedVarPointsTo(?fromVal, ?fromCtx, ?from),
  SourceFromTaintedValue(?fromVal, ?source).


   
mainAnalysis.Value_isMock( cat(cat(cat(cat(?invo, "::: "),  ?type), "::: "),  "ASSIGN")), isValue( cat(cat(cat(cat(?invo, "::: "),  ?type), "::: "),  "ASSIGN")), mainAnalysis.Value_Type( cat(cat(cat(cat(?invo, "::: "),  ?type), "::: "),  "ASSIGN"),  ?type), mainAnalysis.Value_DeclaringType( cat(cat(cat(cat(?invo, "::: "),  ?type), "::: "),  "ASSIGN"), "java.lang.Object"), TaintedValue( cat(cat(cat(cat(?invo, "::: "),  ?type), "::: "),  "ASSIGN")), SourceFromTaintedValue( cat(cat(cat(cat(?invo, "::: "),  ?type), "::: "),  "ASSIGN"),  ?invo), LabelFromSource( ?invo,  ?label), mainAnalysis.Value_DeclaringType( cat(cat(cat(cat(?invo, "::: "),  ?type), "::: "),  "ASSIGN"), ?declaringType),
mainAnalysis.VarPointsTo(?hctx, cat(cat(cat(cat(?invo, "::: "),  ?type), "::: "),  "ASSIGN"), ?ctx, ?to) :-
  CallTaintingMethod(?label, ?ctx, ?invo),
  mainAnalysis.isImmutableHContext(?hctx),
  TypeForReturnValue(?type, ?to, ?invo),
  Instruction_Method(?invo, ?method),
  Method_DeclaringType(?method, ?declaringType).

TaintedVarPointsTo(?value, ?ctx, ?var) :-
  TaintedValue(?value),
  mainAnalysis.VarPointsTo(_, ?value, ?ctx, ?var).


// Generic string internal tainting


// Serialization
.decl SerializeObjectInvocation(?base:Var, ?ctx:mainAnalysis.configuration.Context, ?var:Var)

SerializeObjectInvocation(?base, ?ctx, ?var) :-
  MethodInvocationInContextInApplication(?ctx, ?invocation, "<java.io.ObjectOutputStream: void writeObject(java.lang.Object)>"),
  MethodInvocation_Base(?invocation, ?base),
  ActualParam(_, ?invocation, ?var).

.decl ObjectSerializedToBase(?ctx:mainAnalysis.configuration.Context, ?base:Var, ?obj:Value)

ObjectSerializedToBase(?ctx, ?base, ?obj) :-
  SerializeObjectInvocation(?base, ?ctx, ?var),
  mainAnalysis.VarPointsTo(_, ?obj, ?ctx, ?var),
  SerializableValue(?obj).

.decl SerializableValue(?obj:Value)

SerializableValue(?obj) :-
   mainAnalysis.Value_Type(?obj, ?type),
   basic.SupertypeOf("java.io.Serializable", ?type).

.decl SerializableVar(?var:Var)

SerializableVar(?var) :-
   Var_Type(?var, ?type),
   basic.SupertypeOf("java.io.Serializable", ?type).

TaintedObjectSerialized(?declaringType, ?source, ?type, ?hctx, cat(cat(cat(cat(?source, "::: "),  ?type), "::: "),  "ASSIGN"), ?ctx, ?base) :-
  ObjectSerializedToBase(?ctx, ?base, ?baseobj),
  (mainAnalysis.InstanceFieldPointsTo(_, ?obj, ?field, _, ?baseobj),
  !Field_Modifier("transient", ?field)),
  TaintedValue(?obj),
  Var_Type(?base, ?type),
  mainAnalysis.Value_DeclaringType(?obj, ?declaringType),
  SourceFromTaintedValue(?obj, ?source),
  mainAnalysis.isImmutableHContext(?hctx).
  .plan 2: (3,2,1,4,5,6,7)

TaintedValueTransferred(?declaringType, ?source, ?type, ?val),
mainAnalysis.VarPointsTo(?hctx, ?val, ?ctx, ?base) :-
    TaintedObjectSerialized(?declaringType, ?source, ?type, ?hctx, ?val, ?ctx, ?base).

VarIsTaintedFromValue(?type, ?basevalue, ?ctx, ?to) :-
   MaybeDeserializedValue(?basevalue),
   TaintedVarPointsTo(?basevalue, ?ctx, ?base),
   LoadInstanceField(?base, ?sig, ?to, _),
   !Field_Modifier("transient", ?sig),
   Var_Type(?to, ?type).

BaseToRetTaintTransferMethod("<java.io.ObjectInputStream: java.lang.Object readObject()>").

.decl OptDeserializeInvoke(?ret:Var)

OptDeserializeInvoke(?ret) :-
   MethodInvocationInContextInApplication(_, ?invocation, "<java.io.ObjectInputStream: java.lang.Object readObject()>"),
   AssignReturnValue(?invocation, ?ret).

.decl MaybeDeserializedValue(?value:Value)

MaybeDeserializedValue(?value) :-
   OptDeserializeInvoke(?ret),
   TaintedVarPointsTo(?value, _, ?ret),
   SerializableValue(?value).

.decl AppTaintedVarPointsTo(?value:Value, ?var:Var)
AppTaintedVarPointsTo(?value, ?var) :-
  TaintedVarPointsTo(?value, _, ?var), ApplicationVar(?var).

.decl AppTaintedVar(?var:Var)
.output AppTaintedVar
AppTaintedVar(?var) :- AppTaintedVarPointsTo(_, ?var).

// Rules for tracking taint object flow (from/to var and context)
TaintObjTransfer(?callerCtx, ?actual, ?calleeCtx, ?formal) :-
    mainAnalysis.OptArgAssign(?calleeCtx, ?formal, ?callerCtx, ?actual, ?allowedType),
    TaintedVarPointsTo(?taintedValue, ?callerCtx, ?actual),
    mainAnalysis.Value_Type(?taintedValue, ?tType),
    basic.SubtypeOf(?tType, ?allowedType).

TaintObjTransfer(?callerCtx, ?return, ?calleeCtx, ?local) :-
    mainAnalysis.CallGraphEdge(?callerCtx, ?invocation, ?calleeCtx, ?method),
    AssignReturnValue(?invocation, ?local),
    ReturnVar(?return, ?method),
    TaintedVarPointsTo(_, ?calleeCtx, ?return).

TaintObjTransfer(?ctx, ?base, ?calleeCtx, ?this) :-
    TaintedVarPointsTo(_, ?ctx, ?base),
    MethodInvocation_Base(?invo, ?base),
    mainAnalysis.CallGraphEdge(?ctx, ?invo, ?calleeCtx, ?meth),
    ThisVar(?meth, ?this).
.plan 1:(3,2,1,4)

TaintObjTransfer(?ctx, ?param, ?ctx, ?base) :-
    ParamTaintTransferredToBase(?param, ?ctx, ?base),
    TaintedVarPointsTo(_, ?ctx, ?param).

TaintObjTransfer(?fromCtx, ?from, ?toCtx, ?to) :-
    TaintedVarPointsTo(_, ?fromCtx, ?from),
    mainAnalysis.StoreHeapInstanceField(?sig, ?hctx, ?baseval, ?fromCtx, ?from),
    mainAnalysis.LoadHeapInstanceField(?toCtx, ?to, ?sig, ?hctx, ?baseval).
.plan 1:(2,1,3),2:(3,2,1)

TaintObjTransfer(?fromCtx, ?from, ?toCtx, ?to) :-
    TaintedVarPointsTo(_, ?fromCtx, ?from),
    mainAnalysis.StoreHeapArrayIndex(?basehctx, ?basevalue, ?fromCtx, ?from),
    mainAnalysis.LoadHeapArrayIndex(?toCtx, ?to, ?basehctx, ?basevalue).
.plan 1:(2,1,3),2:(3,2,1)

TaintObjTransfer(?fromCtx, ?from, ?toCtx, ?to) :-
    TaintedVarPointsTo(?val, ?toCtx, ?to),
    LoadStaticField(?sig, ?to, _),
    StoreStaticField(?from, ?sig, _),
    TaintedVarPointsTo(?val, ?fromCtx, ?from).
.plan 1:(4,3,2,1)

TaintObjTransfer(?ctx, ?from, ?ctx, ?to) :-
    TaintedVarPointsTo(_, ?ctx, ?from),
    AssignCast(_, ?from, ?to, _).

TaintObjTransfer(?ctx, ?from, ?ctx, ?to) :-
    TaintedVarPointsTo(_, ?ctx, ?from),
    AssignLocal(?from, ?to, _).





















// Copy of MockValueConsMacro but with proper component qualifers.












// Android-specific macro to qualify unqualified types in layout controls.
// Heuristic: if the name is unqualified, it may come from android.view or
// android.widget ("Android Programming: The Big Nerd Ranch Guide", chapter 32).








// id 为 invocation instruction








ParamToBaseTaintTransferMethod(0, "<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.Object)>").
ParamToBaseTaintTransferMethod(0, "<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.String)>").
ParamToBaseTaintTransferMethod(0, "<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.StringBuffer)>").
ParamToBaseTaintTransferMethod(0, "<java.lang.StringBuffer: java.lang.StringBuffer append(java.lang.CharSequence)>").
ParamToBaseTaintTransferMethod(0, "<java.lang.StringBuffer: java.lang.StringBuffer append(char[])>").
ParamToBaseTaintTransferMethod(0, "<java.lang.StringBuffer: java.lang.StringBuffer append(char)>").

BaseToRetTaintTransferMethod("<java.lang.Float: float floatValue()>").
BaseToRetTaintTransferMethod("<java.lang.String: byte[] getBytes(java.lang.String)>").
BaseToRetTaintTransferMethod("<java.lang.String: char charAt(int)>").
BaseToRetTaintTransferMethod("<java.util.Enumeration: java.lang.Object nextElement()>").
BaseToRetTaintTransferMethod("<java.util.Iterator: java.lang.Object next()>").
BaseToRetTaintTransferMethod("<java.util.LinkedList: java.lang.Object clone()>").
BaseToRetTaintTransferMethod("<java.util.LinkedList: java.lang.Object get(int)>").
BaseToRetTaintTransferMethod("<java.util.Map: java.util.Set entrySet()>").
BaseToRetTaintTransferMethod("<java.util.Map$Entry: java.lang.Object getValue()>").
BaseToRetTaintTransferMethod("<java.util.Set: java.util.Iterator iterator()>").


  

BaseToRetTaintTransferMethod("<java.lang.String: char[] toCharArray()>").
BaseToRetTaintTransferMethod("<java.lang.String: java.lang.String intern()>").


  

// TODO: System.arrayCopy


//InformationLabel("default").

TaintSourceMethod("default", "<java.io.BufferedReader: java.lang.String readLine()>").
TaintSourceMethod("default", "<java.io.BufferedReader: int read(char[],int,int)>").
// The latter is not a great taint source (since it returns ints) but it's good for minimal testing

LeakingSinkMethodArg("default", 0, "<java.io.PrintWriter: void println(java.lang.String)>").














// Copy of MockValueConsMacro but with proper component qualifers.












// Android-specific macro to qualify unqualified types in layout controls.
// Heuristic: if the name is unqualified, it may come from android.view or
// android.widget ("Android Programming: The Big Nerd Ranch Guide", chapter 32).



.decl OpenProgramEntryPoint(?method:Method)
.decl PossibleOpenProgramEntryPoint(?method:Method)
.decl ClassHasPossibleOpenProgramEntryPoint(?class:ReferenceType)

ClassHasPossibleOpenProgramEntryPoint(?class),
PossibleOpenProgramEntryPoint(?method) :-
  Method_DeclaringType(?method, ?class),
  Method_Modifier("public", ?method),
  // 修改
  ApplicationClass(?class),
  !Method_Modifier("abstract", ?method),
//// Remove comment for original behavior
//   !Method_Modifier("static", ?method),
  !ClassModifier("private", ?class).

// Find highest level in the naming hierarchy that contains public
// methods.
.decl PrefixAbove(class:ReferenceType, str:symbol, ?len:number)
.decl PrefixBelow(class:ReferenceType, str:symbol)

PrefixAbove(?classAbove, substr(?classAbove, 0, ?lastDotPos+1), ?lastDotPos+1) :-
  ClassHasPossibleOpenProgramEntryPoint(?classAbove),
  mainAnalysis.LastDot(?classAbove, ?lastDotPos).

PrefixBelow(?classBelow, substr(?classBelow, 0, ?lastDotPos)) :-
  ClassHasPossibleOpenProgramEntryPoint(?classBelow),
  mainAnalysis.LastDot(?classBelow, ?lastDotPos).

.decl ClassIsAboveOtherInNamingHierarchy(?classAbove:ReferenceType, ?classBelow:ReferenceType)

ClassIsAboveOtherInNamingHierarchy(?classAbove, ?classBelow) :-
  // One's prefix before "." is a proper prefix of the other's prefix before "."
  PrefixAbove(?classAbove, ?prefixAbove, ?prefixLen),
  PrefixBelow(?classBelow, ?prefixBelow),
  substr(?prefixBelow, 0, ?prefixLen) = ?prefixAbove.

.decl ClassWithTopLevelOpenProgramEntryPoint(?class:ReferenceType)
.decl TopLevelApplicationClass(?class:ReferenceType)
.decl ClassToConsider(?class:ReferenceType)
.decl TopLevelOpenProgramEntryPoint(?method:Method)

ClassWithTopLevelOpenProgramEntryPoint(?class) :-
  ClassHasPossibleOpenProgramEntryPoint(?class),
  !ClassIsAboveOtherInNamingHierarchy(_, ?class).

TopLevelApplicationClass(?class) :-
  ClassWithTopLevelOpenProgramEntryPoint(?class),
  ApplicationClass(?class).

ClassToConsider(?class) :-
  TopLevelApplicationClass(?class).

ClassToConsider(?class) :-
  ApplicationClass(?class),
  !TopLevelApplicationClass(_).

TopLevelOpenProgramEntryPoint(?method) :-
  PossibleOpenProgramEntryPoint(?method),
  Method_DeclaringType(?method, ?class),
  ClassToConsider(?class).


// The definition we currently want as default
OpenProgramEntryPoint(?method) :-
  PossibleOpenProgramEntryPoint(?method).
//  TopLevelOpenProgramEntryPoint(?method).


// Contribute to the global summary relation
mainAnalysis.ApplicationEntryPoint(?meth) :-
  OpenProgramEntryPoint(?meth),
  ApplicationMethod(?meth).



.decl AllConcreteImplementations(?class:ReferenceType, ?type:ReferenceType)
.decl ConcreteType(?class:ReferenceType)

AllConcreteImplementations(?class, ?staticType) :-
  isClassType(?class),
  basic.SubtypeOf(?class, ?staticType),
  isReferenceType(?staticType),
  !ClassModifier("abstract", ?class).

AllConcreteImplementations(?class, ?class) :-
  isClassType(?class),
  !ClassModifier("abstract", ?class).

AllConcreteImplementations(?type, ?type) :-
  isArrayType(?type).

ConcreteType(?type) :-
  AllConcreteImplementations(?type, _).

// Set flag to enable statistics print logic.

.decl ObjToMock(?class:ReferenceType)
.decl MockObjFromOpenProgramEntryPoint(?class:ReferenceType)
.decl MockObjFromArray(?class:ReferenceType)

MockObjFromOpenProgramEntryPoint(?class),
ObjToMock(?class) :-
  OpenProgramEntryPoint(?method),
  Method_DeclaringType(?method, ?class),
  isReferenceType(?class),
  !ClassModifier("abstract", ?class).

MockObjFromArray(?class),
ObjToMock(?class) :-
  ObjToMock(?type),
  isArrayType(?type),
  ComponentType(?type, ?componentType),
  StaticToActualType(?class, ?componentType).

.decl MockObjFromField(?fieldType:ReferenceType)



// Arrays
.decl MockObjectForType(?value:Value, ?staticType:ReferenceType)

MockObjectForType(?value, ?staticType) :-
  MockObject(?value, ?class),
  StaticToActualType(?class, ?staticType).

.decl MockObjectForComponentType(?value:Value, ?arrayType:ArrayType)

MockObjectForComponentType(?value, ?arrayType) :-
  ComponentType(?arrayType, ?componentType),
  MockObjectForType(?value, ?componentType).

mainAnalysis.ArrayIndexPointsTo(?hctx, ?componentValue, ?hctx, ?arrayValue) :-
  MockObjectContext(?hctx, ?arrayValue, ?arrayType),
  isArrayType(?arrayType),
  MockObjectForComponentType(?componentValue, ?arrayType).

// *****************
// Formal parameters
// *****************
.decl FormalsForOpenProgramEntryPoints(?method:Method, ?formal:Var)

FormalsForOpenProgramEntryPoints(?method, ?formal) :-
  OpenProgramEntryPoint(?method),
  FormalParam(_, ?method, ?formal).

.decl MockObjFromFormal(?type:ReferenceType)
.decl TypeForFormals(?formal:Var, ?method:Method, ?type:ReferenceType)

ObjToMock(?subtype),
MockObjFromFormal(?subtype),
TypeForFormals(?formal, ?method, ?subtype) :-
  FormalsForOpenProgramEntryPoints(?method, ?formal),
  Var_Type(?formal, ?staticType),
  StaticToActualType(?subtype, ?staticType).

.decl MockForFormal(?value:Value, ?formal:Var, ?type:ReferenceType, ?method:Method)

MockForFormal(?value, ?formal, ?type, ?method) :-
  TypeForFormals(?formal, ?method, ?type),
  MockObject(?value, ?type).

.decl MockObjectContext(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?class:ReferenceType)

.decl ContextForOpenProgramEntryPoint(?ctx:mainAnalysis.configuration.Context, ?method:Method)
.decl HContextForOpenProgramEntryPoint(?hctx:mainAnalysis.configuration.HContext, ?method:Method)

// bind mock objects to formals
MockObjectContext(?hctx, ?value, ?class),
mainAnalysis.VarPointsTo(?hctx, ?value, ?ctx, ?formal) :-
  ContextForOpenProgramEntryPoint(?ctx, ?method),
  HContextForOpenProgramEntryPoint(?hctx, ?method),
  MockForFormal(?value, ?formal, ?class, ?method).

// TODO: do we need all these options?
// feel free to remove/collapse some

// receivers for entry points
.decl ReceiverPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?receiver:Var, ?class:ReferenceType, ?method:Method)

mainAnalysis.configuration.RecordContextRequest(?calleeCtx, ?value, ?receiver) :-
  ReceiverPointsTo(?value, ?calleeCtx, ?receiver, _, _).

HContextForOpenProgramEntryPoint(?hctx, ?method),
MockObjectContext(?hctx, ?value, ?class),
mainAnalysis.VarPointsTo(?hctx, ?value, ?calleeCtx, ?receiver) :-

  mainAnalysis.configuration.RecordContextResponse(?calleeCtx, ?value, ?receiver, ?hctx),
  mainAnalysis.configuration.RecordContextRequest(?calleeCtx, ?value, ?receiver),

  ReceiverPointsTo(?value, ?calleeCtx, ?receiver, ?class, ?method).

// Important: The MergeOpenProgramEntryPointMacro can be defined
// in such a way as to retrieve some of the precision lost
// due to having mock objects flowing everywhere,
// see implementation in 2objH
// see scalable (but less sound) implementation in partioned-2objH
mainAnalysis.configuration.ContextRequest(?callerCtx, ?immutablehctx, ?invo, ?value, ?method, 1) :-
  MockObjectForType(?value, ?class),
  Method_DeclaringType(?method, ?class),
  MockInvocationForEntryPoint(?value, ?method, ?invo),
  mainAnalysis.isImmutableHContext(?immutablehctx),
  mainAnalysis.isImmutableContext(?callerCtx).

.decl MockInvocationForEntryPoint(?value:Value, ?method:Method, ?invo:MethodInvocation)

MockInvocationForEntryPoint(?value, ?method, cat(cat(cat("<mock-invo ", ?value), ?method), ">")),
isInstruction(cat(cat(cat("<mock-invo ", ?value), ?method), ">")), isMethodInvocation(cat(cat(cat("<mock-invo ", ?value), ?method), ">")) :-
  Method_DeclaringType(?method, ?class),
  MockObjectForType(?value, ?class).


// TODO: feel free to simplify options here
ReceiverPointsTo(?value, ?calleeCtx, ?receiver, ?class, ?method),
ContextForOpenProgramEntryPoint(?calleeCtx, ?method) :-
  ThisVar(?method, ?receiver),
  Method_DeclaringType(?method, ?class),
  MockObjectForType(?value, ?class),

  mainAnalysis.isImmutableHContext(?immutablehctx),

  mainAnalysis.isImmutableContext(?callerCtx),
  mainAnalysis.configuration.ContextResponse(?callerCtx, ?immutablehctx, ?invo, ?value, ?method, ?calleeCtx),
  mainAnalysis.configuration.ContextRequest(?callerCtx, ?immutablehctx, ?invo, ?value, ?method, 1),

  OpenProgramEntryPoint(?method).

// TODO: requires major tweaking for context sensitive analyses
// Consider a recency abstraction for context in static methods
HContextForOpenProgramEntryPoint(?hctx, ?method),
ContextForOpenProgramEntryPoint(?calleeCtx, ?method) :-
  mainAnalysis.isImmutableHContext(?hctx),
  mainAnalysis.isImmutableContext(?calleeCtx),
  Method_Modifier("static", ?method),
  !Method_Modifier("abstract", ?method),
  OpenProgramEntryPoint(?method).

.decl TypeToConcreteImplementationOrd(?staticType:ReferenceType, ?classOrd:number)
.decl ConcreteImplementations(?staticType:ReferenceType, ?class:ClassType)

// Here we "randomly" select a concrete implementation for each type.
// In a partitioned analysis we try to select one from the same partition.

TypeToConcreteImplementationOrd(?staticType, ?classOrd) :-
  AllConcreteImplementations(_, ?staticType),
  ?classOrd = min ord(?allClasses) : {
     AllConcreteImplementations(?allClasses, ?staticType)
   }.

.printsize TypeToConcreteImplementationOrd

ConcreteImplementations(?staticType, ?class) :-
  TypeToConcreteImplementationOrd(?staticType, ?classOrd),
  isClassType(?class),
  ord(?class) = ?classOrd.

// gives us a concrete implementation of a type, preferably itself
.decl StaticToActualType(?class:ReferenceType, ?staticType:ReferenceType)

StaticToActualType(?class, ?staticType) :-
  ConcreteImplementations(?staticType, ?class),
  !ConcreteType(?staticType).

StaticToActualType(?type, ?type) :-
  ConcreteType(?type).

// The key point where all the mock objects are created. Triggers all the rest.
MockObject(?mockObj, ?class),
mainAnalysis.Value_isMock(?mockObj), isValue(?mockObj), mainAnalysis.Value_Type(?mockObj,  ?class), mainAnalysis.Value_DeclaringType(?mockObj, "java.lang.Object"),
mainAnalysis.Value_DeclaringType(?mockObj, ?class) :-

  ObjToMock(?class),
  ?mockObj = cat(?class, "::MockObject").

// Similar for mainAnalysis.ReachableContext. If not in open program mode, add extra conditions.
mainAnalysis.ReachableContext(?ctx, ?method) :-

  ContextForOpenProgramEntryPoint(?ctx, ?method).

// "Arbitrary" methods might be made reachable. Initialize the corresponding
// classes as well.
mainAnalysis.InitializedClass(?class) :-
  mainAnalysis.ReachableContext(_, ?method),
  Method_DeclaringType(?method, ?class).

// 加载 计算函数摘要 谓词

// 一期计划:
// 计算函数的 return parameter base(this) 三者关系
// 计算 parameters 之间的关系

// 主要依托 points-to 分析

// index-th 可以传递到 return
.decl ParamToRetSummarizeMethod(?method: Method, ?index: number)

// index-th 参数 可以传递到 base(this)
.decl ParamToBaseSummarizeMethod(?method: Method, ?index: number)

// original_index-th 参数是 alias_index 参数的别名对象
.decl ParamToOtherParamSummarizeMethod(?method: Method, ?original_index: number, ?alias_index: number)

// base(this) 可以 传递到 index-th 参数
.decl BaseToParamSummarizeMethod(?method: Method, ?index: number)

// base(this) 可以传递到 return
.decl BaseToRetSummarizeMethod(?method: Method)

// 需要注意的是，对于原框架中，只要能得到这些函数名
// 目前的想法是，先计算出上述信息，再根据这些信息直接推出 MethodName.

.decl ParamToRetSummarizeMethodName(?method: Method)
.decl ParamToBaseSummarizeMethodName(?method: Method)
.decl ParamToOtherParamSummarizeMethodName(?method: Method)

.decl BaseToParamSummarizeMethodName(?method: Method)
.decl BaseToRetSummarizeMethodName(?method: Method)


// 很不精确，只是默认认为函数参数必然会影响函数return
// ParamToRet 最合理的判断条件:
// ?return_var 与 ?param 之前存在依赖关系，?param 控制 ?return_var
// 但这个基本无法在 doop 上实现
ParamToRetSummarizeMethod(?method, ?index):-
    // 函数内分析，确保函数在CG中。
    // 不在CG就不分析了
    mainAnalysis.Reachable(?method),
    // parmam 是函数的形式参数
    FormalParam(?index, ?method, _),
    // return 是函数的返回值
    Instruction_Method(_, ?method).


ParamToRetTaintTransferMethod(?method),
ParamToRetSummarizeMethodName(?method) :-
    ParamToRetSummarizeMethod(?method, _).

// 😡
// 什么情况下，ParamToBase
// 
// ParamToBaseSummarizeMethod(?method) :-




// ParamToBaseSummarizeMethodName(?method) :-
//     ParamToBaseSummarizeMethod(?method).

// ParamToOtherParamSummarizeMethodName(?method) :-
//     ParamToOtherParamSummarizeMethod(?method).

// BaseToParamSummarizeMethodName(?method) :-
//     BaseToParamSummarizeMethod(?method).

// BaseToRetSummarizeMethodName(?method) :-
//     BaseToRetSummarizeMethod(?method).

// 二期计划:
// 计算mock- 的关系


// 输出
.output ParamToRetSummarizeMethod

// 确定 污点分析信息



// 设置 source 和 sink 函数名

.decl DefineSourceMethodName(simpleNmae: symbol)

DefineSourceMethodName("source").


.decl DefineSinkMethodName(simpleNmae: symbol)


DefineSinkMethodName("maybeEvil").

TaintSourceMethod(?lable, ?method) :-
	?lable = "UnSafeSerCheck",
	DefineSourceMethodName(simpleMethodName),
	Method_Modifier("public", ?method),
	Method_SimpleName(?method, simpleMethodName),
	!Method_Modifier("abstract", ?method).

LeakingSinkMethod(?lable, ?method) :-
	?lable = "UnSafeSerCheck",
	DefineSinkMethodName(simpleMethodName),
	Method_Modifier("public", ?method),
	Method_SimpleName(?method, simpleMethodName),
	!Method_Modifier("abstract", ?method).

// 设置 : 
// ParamToRetTaintTransferMethod
// ParamToBaseTaintTransferMethod
// BaseToParamTaintTransferMethod
// BaseToRetTaintTransferMethod
// 这里提供一种轻量且尽可能不需要设置的构造器
// 不然需要设置的东西太多了
// 可以参考 souffle-logic/addons/information-flow/android-taint-wrappers.dl


.output LeakingSinkMethod
.output TaintSourceMethod
.output LeakingSinkVariable
.output TaintedVarPointsTo
.output TaintedValue

.output mainAnalysis.Reachable
// An output statement like ".output A" is just a shorthand for
// ".output AB(IO="file",filename="A.csv",delimiter="\t")".





.decl Stats_Simple_JavaUtilInsensVarPointsTo(?value:Value, ?var:Var)
.output Stats_Simple_JavaUtilInsensVarPointsTo

.decl Stats_Simple_JavaUtilVarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
.output Stats_Simple_JavaUtilVarPointsTo

.decl Stats_Simple_InsensVarPointsTo(?value:Value, ?var:Var)
.output Stats_Simple_InsensVarPointsTo

.decl Stats_Simple_AssignedVariable(?var:Var)


.decl Stats_Simple_Application_InsensVarPointsTo(?value:Value, ?var:Var)


.decl Stats_Simple_Application_VarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)


.decl Stats_Simple_InsensReachableVar(?var:Var)


.decl Stats_Simple_ReachableVar(?ctx:mainAnalysis.configuration.Context, ?var:Var)



                                                     

.decl Stats_Simple_InsensArrayIndexPointsTo(?value:Value, ?basevalue:Value)


.decl Stats_Simple_Application_InsensArrayIndexPointsTo(?value:Value, ?basevalue:Value)


.decl Stats_Simple_Application_ArrayIndexPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)





                                                     

.decl Stats_Simple_InsensInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basevalue:Value)


.decl Stats_Simple_InsensStaticFieldPointsTo(?value:Value, ?sig:Field)


.decl Stats_Simple_Application_InsensInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basevalue:Value)


.decl Stats_Simple_Application_InstanceFieldPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)





                                                     

.decl Stats_Simple_InsensCallGraphEdge(?from:MethodInvocation, ?to:Method)
.output Stats_Simple_InsensCallGraphEdge

.decl Stats_Simple_VirtualCallGraphEdge(?from:MethodInvocation, ?to:Method)



                                                     

.decl Stats_Simple_InsensReachableApplicationMethod(?method:Method)


.decl Stats_Simple_ReachableApplicationMethod(?ctx:mainAnalysis.configuration.Context, ?method:Method)


.decl Stats_Simple_ApplicationConcreteMethod(?method:Method)


.decl Stats_Simple_NonReachableApplicationConcreteMethod(?method:Method)
.output Stats_Simple_NonReachableApplicationConcreteMethod




                                                     

.decl Stats_Simple_ReachableVirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation:MethodInvocation)


// Intermediate predicate
.decl Stats_Simple_VirtualTargets(?invocation:MethodInvocation, ?c:number)

.decl Stats_Simple_PolymorphicCallSite(?invocation:MethodInvocation)


.decl Stats_Simple_NullVirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_EmptyVirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_Application_VirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_Application_PolymorphicCallSite(?invocation:MethodInvocation)


.decl Stats_Simple_Application_NullVirtualMethodInvocation(?invocation:MethodInvocation)


.decl Stats_Simple_Application_EmptyReachableVirtualMethodInvocation(?invocation:MethodInvocation)



                                                     

.decl Stats_Simple_ReachableCast(?inmethod:Method, ?type:Type, ?to:Var, ?from:Var)


.decl Stats_Simple_PotentiallyFailingCast(?type:Type, ?from:Var, ?to:Var)


.decl Stats_Simple_Application_Cast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)


.decl Stats_Simple_Application_ReachableCast(?inmethod:Method, ?type:Type, ?to:Var, ?from:Var)


.decl Stats_Simple_Application_ReachableMethod(?method:Method)
.output Stats_Simple_Application_ReachableMethod

.decl Stats_Simple_Application_PotentiallyFailingCast(?type:Type, ?from:Var, ?to:Var)



                                                     




                                                     


.decl Stats_Simple_InsensTaintedVarPointsTo(?value:Value, ?var:Var)


.decl Stats_Simple_Application_InsensTaintedVarPointsTo(?value:Value, ?var:Var)


.decl Stats_Simple_Application_TaintedVarPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)


.decl Stats_Simple_LeakingTaintedInformation(?invocation:MethodInvocation, ?objStr:symbol)


.decl Stats_Simple_OriginalTaintedValue(?id:symbol)




                                                     


//.decl Stats_Simple_ReachableFromEntryPoint(?method:Method)
//





                                                     




                                                     
Stats_Simple_JavaUtilInsensVarPointsTo(?value, ?var) :-
  Stats_Simple_JavaUtilVarPointsTo(_, ?value, _, ?var).

Stats_Simple_JavaUtilVarPointsTo(?hctx, ?value, ?ctx, ?var) :-
  Method_DeclaringType(?method, ?type),
  match("java[.]util[.].*", ?type),
  Var_DeclaringMethod(?var, ?method),
  mainAnalysis.VarPointsTo(?hctx, ?value, ?ctx, ?var).

Stats_Simple_InsensVarPointsTo(?value, ?var) :-
  mainAnalysis.VarPointsTo(_, ?value, _, ?var).

Stats_Simple_AssignedVariable(?var) :-
  Stats_Simple_InsensVarPointsTo(_, ?var).

Stats_Simple_Application_InsensVarPointsTo(?value, ?var),
Stats_Simple_Application_VarPointsTo(?hctx, ?value, ?ctx, ?var) :-
  ApplicationVar(?var),
  mainAnalysis.VarPointsTo(?hctx, ?value, ?ctx, ?var).

Stats_Simple_InsensReachableVar(?var),
Stats_Simple_ReachableVar(?ctx, ?var) :-
  Stats_Simple_AssignedVariable(?var),
  Var_DeclaringMethod(?var, ?method),
  mainAnalysis.ReachableContext(?ctx, ?method).




                                                     

Stats_Simple_InsensArrayIndexPointsTo(?value, ?basevalue) :-
   mainAnalysis.ArrayIndexPointsTo(_, ?value, _, ?basevalue).

Stats_Simple_Application_InsensArrayIndexPointsTo(?value, ?basevalue),
Stats_Simple_Application_ArrayIndexPointsTo(?hctx, ?value, ?baseHCtx, ?basevalue) :-
  ApplicationMethod(?meth),
  mainAnalysis.AssignNormalHeapAllocation(?basevalue, _, ?meth),
  mainAnalysis.ArrayIndexPointsTo(?hctx, ?value, ?baseHCtx, ?basevalue).




                                                     

Stats_Simple_InsensInstanceFieldPointsTo(?value, ?sig, ?basevalue) :-
  mainAnalysis.InstanceFieldPointsTo(_, ?value, ?sig, _, ?basevalue).

Stats_Simple_InsensStaticFieldPointsTo(?value, ?sig) :-
  mainAnalysis.StaticFieldPointsTo(_, ?value, ?sig).

Stats_Simple_Application_InsensInstanceFieldPointsTo(?value, ?sig, ?basevalue),
Stats_Simple_Application_InstanceFieldPointsTo(?hctx, ?value, ?sig, ?baseHCtx, ?basevalue) :-
  ApplicationMethod(?meth),
  mainAnalysis.AssignNormalHeapAllocation(?basevalue, _, ?meth),
  mainAnalysis.InstanceFieldPointsTo(?hctx, ?value, ?sig, ?baseHCtx, ?basevalue).




                                                     

Stats_Simple_InsensCallGraphEdge(?from, ?to) :-
   mainAnalysis.CallGraphEdge(_, ?from, _, ?to).

Stats_Simple_VirtualCallGraphEdge(?from, ?to) :-
   Stats_Simple_ReachableVirtualMethodInvocation(?from),
   Stats_Simple_InsensCallGraphEdge(?from, ?to).


                                                     

Stats_Simple_InsensReachableApplicationMethod(?method),
Stats_Simple_ReachableApplicationMethod(?ctx, ?method) :-
  ApplicationMethod(?method),
  mainAnalysis.ReachableContext(?ctx, ?method).

Stats_Simple_ApplicationConcreteMethod(?method) :-
  ApplicationMethod(?method),
  !Method_Modifier("abstract", ?method).

Stats_Simple_NonReachableApplicationConcreteMethod(?method) :-
  Stats_Simple_ApplicationConcreteMethod(?method),
  !Stats_Simple_InsensReachableApplicationMethod(?method).




                                                     

Stats_Simple_ReachableVirtualMethodInvocation(?invocation) :-
  mainAnalysis.Reachable(?method),
  Instruction_Method(?invocation, ?method),
  isVirtualMethodInvocation_Insn(?invocation).

Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation) :-
  Stats_Simple_InsensReachableApplicationMethod(?method),
  Instruction_Method(?invocation, ?method),
  isVirtualMethodInvocation_Insn(?invocation).

Stats_Simple_VirtualTargets(?from, ?c) :-
  Stats_Simple_VirtualCallGraphEdge(?from, _),
  ?c = count : Stats_Simple_VirtualCallGraphEdge(?from, _).

Stats_Simple_PolymorphicCallSite(?from) :-
  Stats_Simple_VirtualTargets(?from, ?size),
  ?size > 1.

/// Too slow for large programs!
// Stats_Simple_PolymorphicCallSite(?from) :-
//   Stats_Simple_VirtualCallGraphEdge(?from, ?to1),
//   Stats_Simple_VirtualCallGraphEdge(?from, ?to2),
//   ord(?to1) < ord(?to2).
  
Stats_Simple_NullVirtualMethodInvocation(?invocation) :-
  mainAnalysis.Value_Null(?null),
  Stats_Simple_InsensVarPointsTo(?null, ?base),
  VirtualMethodInvocation_Base(?invocation, ?base),
  Stats_Simple_ReachableVirtualMethodInvocation(?invocation).

Stats_Simple_EmptyVirtualMethodInvocation(?invocation) :-
  Stats_Simple_ReachableVirtualMethodInvocation(?invocation),
  VirtualMethodInvocation_Base(?invocation, ?base),
  !Stats_Simple_InsensVarPointsTo(_, ?base).

Stats_Simple_Application_VirtualMethodInvocation(?invocation) :-
  ApplicationMethod(?method),
  Instruction_Method(?invocation, ?method),
  isVirtualMethodInvocation_Insn(?invocation).

Stats_Simple_Application_PolymorphicCallSite(?from) :-
  Stats_Simple_PolymorphicCallSite(?from),
  Stats_Simple_Application_ReachableVirtualMethodInvocation(?from).

Stats_Simple_Application_NullVirtualMethodInvocation(?invocation) :-
  mainAnalysis.Value_Null(?null),
  Stats_Simple_InsensVarPointsTo(?null, ?base),
  VirtualMethodInvocation_Base(?invocation, ?base),
  Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation).

Stats_Simple_Application_EmptyReachableVirtualMethodInvocation(?invocation) :-
  Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation),
  VirtualMethodInvocation_Base(?invocation, ?base),
  !Stats_Simple_InsensVarPointsTo(_, ?base).


                                                     

Stats_Simple_ReachableCast(?inmethod, ?type, ?to, ?from) :-
  Stats_Simple_AssignedVariable(?from),
  AssignCast(?type, ?from, ?to, ?inmethod),
  mainAnalysis.Reachable(?inmethod).

Stats_Simple_PotentiallyFailingCast(?type, ?from, ?to) :-
  Stats_Simple_ReachableCast(_, ?type, ?to, ?from),
  Stats_Simple_InsensVarPointsTo(?value, ?from),
  mainAnalysis.Value_Type(?value, ?valuetype),
  !basic.SupertypeOf(?type, ?valuetype).

Stats_Simple_Application_Cast(?type, ?from, ?to, ?inmethod) :-
  ApplicationMethod(?inmethod),
  AssignCast(?type, ?from, ?to, ?inmethod).

Stats_Simple_Application_ReachableCast(?inmethod, ?type, ?to, ?from) :-
  ApplicationMethod(?inmethod),
  Stats_Simple_ReachableCast(?inmethod, ?type, ?to, ?from).

Stats_Simple_Application_ReachableMethod(?method) :-
  mainAnalysis.Reachable(?method),
  ApplicationMethod(?method).

Stats_Simple_Application_PotentiallyFailingCast(?type, ?from, ?to) :-
  Stats_Simple_Application_ReachableCast(_, ?type, ?to, ?from),
  Stats_Simple_InsensVarPointsTo(?value, ?from),
  mainAnalysis.Value_Type(?value, ?valuetype),
  !basic.SupertypeOf(?type, ?valuetype).



Stats_Metrics( "1.0",  "var points-to (INS)", c) :- c = count : {  Stats_Simple_InsensVarPointsTo(_, _) }.
Stats_Metrics( "1.5",  "var points-to (SENS)", c) :- c = count : {  mainAnalysis.VarPointsTo(_, _, _, _) }.
Stats_Metrics( "5.0",  "app var points-to (INS)", c) :- c = count : {  Stats_Simple_Application_InsensVarPointsTo(_, _) }.
Stats_Metrics( "5.5",  "app var points-to (SENS)", c) :- c = count : {  Stats_Simple_Application_VarPointsTo(_, _, _, _) }.
Stats_Metrics( "5.7",  "java.util var points-to (INS)", c) :- c = count : {  Stats_Simple_JavaUtilInsensVarPointsTo(_, _) }.
Stats_Metrics( "5.8",  "java.util var points-to (SENS)", c) :- c = count : {  Stats_Simple_JavaUtilVarPointsTo(_, _, _, _) }.
Stats_Metrics("10.0",  "reachable variables (INS)", c) :- c = count : {  Stats_Simple_InsensReachableVar(_) }.
Stats_Metrics("10.5",  "reachable variables (SENS)", c) :- c = count : {  Stats_Simple_ReachableVar(_, _) }.

Stats_Metrics( "2.0",  "array index points-to (INS)", c) :- c = count : {  Stats_Simple_InsensArrayIndexPointsTo(_, _) }.
Stats_Metrics( "2.5",  "array index points-to (SENS)", c) :- c = count : {  mainAnalysis.ArrayIndexPointsTo(_, _, _, _) }.
Stats_Metrics( "6.0",  "app array index points-to (INS)", c) :- c = count : {  Stats_Simple_Application_InsensArrayIndexPointsTo(_, _) }.
Stats_Metrics( "6.5",  "app array index points-to (SENS)", c) :- c = count : {  Stats_Simple_Application_ArrayIndexPointsTo(_, _, _, _) }.

Stats_Metrics( "3.0",  "instance field points-to (INS)", c) :- c = count : {  Stats_Simple_InsensInstanceFieldPointsTo(_, _, _) }.
Stats_Metrics( "3.5",  "instance field points-to (SENS)", c) :- c = count : {  mainAnalysis.InstanceFieldPointsTo(_, _, _, _, _) }.

Stats_Metrics( "4.0",  "static field points-to (INS)", c) :- c = count : {  Stats_Simple_InsensStaticFieldPointsTo(_, _) }.
Stats_Metrics( "4.5",  "static field points-to (SENS)", c) :- c = count : {  mainAnalysis.StaticFieldPointsTo(_, _, _) }.

Stats_Metrics( "7.0",  "app instance field points-to (INS)", c) :- c = count : {  Stats_Simple_Application_InsensInstanceFieldPointsTo(_, _, _) }.
Stats_Metrics( "7.5",  "app instance field points-to (SENS)", c) :- c = count : {  Stats_Simple_Application_InstanceFieldPointsTo(_, _, _, _, _) }.


Stats_Metrics( "8.0",  "call graph edges (INS)", c) :- c = count : {  Stats_Simple_InsensCallGraphEdge(_, _) }.
Stats_Metrics( "8.5",  "call graph edges (SENS)", c) :- c = count : {  mainAnalysis.CallGraphEdge(_, _, _, _) }.
Stats_Metrics( "9.0",  "non-reachable app concrete methods", c) :- c = count : {  Stats_Simple_NonReachableApplicationConcreteMethod(_) }.
Stats_Metrics("11.0",  "reachable methods (INS)", c) :- c = count : {  mainAnalysis.Reachable(_) }.
Stats_Metrics("11.5",  "reachable methods (SENS)", c) :- c = count : {  mainAnalysis.ReachableContext(_, _) }.
Stats_Metrics("11.75",  "total methods", c) :- c = count : {  isMethod(_) }.


Stats_Metrics("12.0",  "virtual call sites (statically)", c) :- c = count : {  isVirtualMethodInvocation_Insn(_) }.
Stats_Metrics("13.0",  "reachable virtual call sites", c) :- c = count : {  Stats_Simple_ReachableVirtualMethodInvocation(_) }.
Stats_Metrics("14.0",  "polymorphic virtual call sites", c) :- c = count : {  Stats_Simple_PolymorphicCallSite(_) }.
Stats_Metrics("15.0",  "null virtual call sites", c) :- c = count : {  Stats_Simple_NullVirtualMethodInvocation(_) }.
Stats_Metrics("15.5",  "empty virtual call sites", c) :- c = count : {  Stats_Simple_EmptyVirtualMethodInvocation(_) }.
Stats_Metrics("16.0",  "app virtual call sites (statically)", c) :- c = count : {  Stats_Simple_Application_VirtualMethodInvocation(_) }.
Stats_Metrics("17.0",  "app reachable virtual call sites", c) :- c = count : {  Stats_Simple_Application_ReachableVirtualMethodInvocation(_) }.
Stats_Metrics("18.0",  "app polymorphic virtual call sites", c) :- c = count : {  Stats_Simple_Application_PolymorphicCallSite(_) }.
Stats_Metrics("19.0",  "app null virtual call sites", c) :- c = count : {  Stats_Simple_Application_NullVirtualMethodInvocation(_) }.
Stats_Metrics("19.5",  "app empty reachable virtual call sites", c) :- c = count : {  Stats_Simple_Application_EmptyReachableVirtualMethodInvocation(_) }.

Stats_Metrics("20.0",  "casts (statically)", c) :- c = count : {  AssignCast(_, _, _, _) }.
Stats_Metrics("21.0",  "reachable casts", c) :- c = count : {  Stats_Simple_ReachableCast(_, _, _, _) }.
Stats_Metrics("22.0",  "reachable casts that may fail", c) :- c = count : {  Stats_Simple_PotentiallyFailingCast(_, _, _) }.
Stats_Metrics("23.0",  "app casts (statically)", c) :- c = count : {  Stats_Simple_Application_Cast(_, _, _, _) }.
Stats_Metrics("24.0",  "app reachable casts", c) :- c = count : {  Stats_Simple_Application_ReachableCast(_, _, _, _) }.
Stats_Metrics("25.0",  "app reachable casts that may fail", c) :- c = count : {  Stats_Simple_Application_PotentiallyFailingCast(_, _, _) }.
Stats_Metrics("25.5",  "app reachable methods", c) :- c = count : {  Stats_Simple_Application_ReachableMethod(_) }.
Stats_Metrics("25.75",  "app concrete methods", c) :- c = count : {  Stats_Simple_ApplicationConcreteMethod(_) }.

//Stats_Metrics("50.0",  "call sites that did (not) get refined", c) :- c = count : {  SiteToRefine(_) }.
//Stats_Metrics("51.0",  "allocation sites that did (not) get refined", c) :- c = count : {  ValueToRefine(_) }.


                                                     




                                                     




                                                     


Stats_Simple_InsensTaintedVarPointsTo(?value, ?var) :-
  TaintedVarPointsTo(?value, _, ?var).

Stats_Simple_Application_InsensTaintedVarPointsTo(?value, ?var),
Stats_Simple_Application_TaintedVarPointsTo(?value, ?ctx, ?var) :-
  ApplicationMethod(?meth),
  Var_DeclaringMethod(?var, ?meth),
  TaintedVarPointsTo(?value, ?ctx, ?var).

Stats_Simple_LeakingTaintedInformation(?invocation, ?objStr) :-
  LeakingTaintedInformation(_, _, _, ?invocation, ?objStr).

Stats_Simple_OriginalTaintedValue(?id) :-
  SourceFromTaintedValue(_, ?id).

Stats_Metrics("40.0",  "tainted flows-to (INS)", c) :- c = count : {  Stats_Simple_InsensTaintedVarPointsTo(_, _) }.
Stats_Metrics("40.5",  "tainted flows-to (SENS)", c) :- c = count : {  TaintedVarPointsTo(_, _, _) }.
Stats_Metrics("41.0",  "app tainted flows-to (INS)", c) :- c = count : {  Stats_Simple_Application_InsensTaintedVarPointsTo(_, _) }.
Stats_Metrics("41.5",  "app tainted flows-to (SENS)", c) :- c = count : {  Stats_Simple_Application_TaintedVarPointsTo(_, _, _) }.
Stats_Metrics("42.0",  "total tainted values", c) :- c = count : {  TaintedValue(_) }.
Stats_Metrics("43.0",  "original tainted values", c) :- c = count : {  Stats_Simple_OriginalTaintedValue(_) }.
Stats_Metrics("44.0",  "sink variables (SENS)", c) :- c = count : {  LeakingSinkVariable(_, _, _, _) }.
Stats_Metrics("45.0",  "total leaks", c) :- c = count : {  Stats_Simple_LeakingTaintedInformation(_, _) }.



                                                     

Stats_Metrics("61.0",  "mock objects", c) :- c = count : {  MockObject(_, _) }.
Stats_Metrics("61.1",  "mock objects for receivers", c) :- c = count : {  MockObjFromOpenProgramEntryPointReceiver(_) }.
Stats_Metrics("61.2",  "mock objects for arg", c) :- c = count : {  MockObjFromOpenProgramEntryPointArg(_) }.
Stats_Metrics("61.6",  "forced-reachable formals that could not be mocked", c) :- c = count : {  UnmockableFormalOfForcedReachableContext(_, _) }.


//Stats_Simple_ReachableFromOpenProgramEntryPoint(?method) :-
//  MockReachableContext(_, ?method).

//Stats_Metrics("60.0",  "Entry Points", c) :- c = count : {  OpenProgramEntryPoint(_) }.

Stats_Metrics("61.3",  "mock objects for fields", c) :- c = count : {  MockObjFromField(_) }.
Stats_Metrics("61.4",  "mock objects for arrays", c) :- c = count : {  MockObjFromArray(_) }.
Stats_Metrics("61.5",  "mock objects for formals", c) :- c = count : {  MockObjFromFormal(_) }.
//Stats_Metrics("62.0",  "Methods Reachable from open entry points (SENS)", c) :- c = count : {  MockReachableContext(_,_) }.
//Stats_Metrics("62.5",  "Methods Reachable from open entry points (INS)", c) :- c = count : {  Stats_Simple_ReachableFromOpenProgramEntryPoint(_) }.





                                                     



.decl Stats_Simple_Application_InsensCallGraphEdge(?invocation:Instruction, ?toMeth:Method)


Stats_Simple_Application_InsensCallGraphEdge(?invocation, ?toMeth) :-
  Stats_Simple_InsensCallGraphEdge(?invocation, ?toMeth),
  ApplicationMethod(?toMeth),
  Instruction_Method(?invocation, ?fromMeth),
  ApplicationMethod(?fromMeth).

// An output statement like ".output A" is just a shorthand for
// ".output AB(IO="file",filename="A.csv",delimiter="\t")".






                                                                 

// .decl Stats_ReflectiveHeap(?heap:HeapAllocation)
// 

.decl Stats_ApplicationHeap(?heap:HeapAllocation)


//.decl Stats_ReachableValue(?value:Value)
//
//
//.decl Stats_ReachableValueWithContext(?hctx:mainAnalysis.configuration.HContext, ?value:Value)
//
//
//.decl Stats_InsensValuesOnMethodBoundaries(?value:Value, ?var:Var),
//
//
//.decl Stats_ValuesOnMethodBoundaries(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
//
//
//.decl Stats_ThrowablesInMethod(?valuetype:Type, ?method:Method)
//
//
//.decl Stats_InsensThrowableValuesOnMethodBoundaries(?value:Value, ?var:Var)
//
//
//.decl Stats_ThrowableValuesOnMethodBoundaries(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
//
//
//.decl Stats_InsensAppThrowableValuesOnMethodBoundaries(?value:Value, ?var:Var)
//
//
//.decl Stats_AppThrowableValuesOnMethodBoundaries(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
//
//
//.decl Stats_ThrowablesInAppMethod(?valuetype:Type, ?method:Method)
//
//
//.decl Stats_InsensAppMethThrowableValuesOnMethodBoundaries(?value:Value, ?var:Var)
//
//
//.decl Stats_AppMethThrowableValuesOnMethodBoundaries(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
//


                                                                 

// Count how many objects, a var points to (context-sensitive)
.decl Stats_VarCount(?ctx:mainAnalysis.configuration.Context, ?var:Var, ?n:number)


.decl Stats_InsensValueVarPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)


// Count how many objects, a var points to (value context-insensitive)
.decl Stats_InsensValueVarCount(?ctx:mainAnalysis.configuration.Context, ?var:Var, ?n:number)


.decl Stats_InsensBaseVarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?var:Var)


// Count how many objects, a var points to (base context-insensitive)
.decl Stats_InsensBaseVarCount(?var:Var, ?n:number)


// Count how many objects, a var points to (value+base context-insensitive)
.decl Stats_InsensVarCount(?var:Var, ?n:number)


// NOTE: The same applies for Stats_InsensValueVarCount
.decl Stats_Vars(?n:number)


// NOTE: The same applies for Stats_InsensBaseVarCount
.decl Stats_InsensVars(?n:number)


//.decl Stats_InsensVarPointsToNonThrowable(?value:Value, ?var:Var)
//
//
//.decl Stats_VarPointsToNonThrowable(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)
//


                                                                 

// Count how many objects, an array points to (context-sensitive)
.decl Stats_ArrayCount(?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)


.decl Stats_InsensValueArrayIndexPointsTo(?value:Value, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)


// Count how many objects, an array points to (value context-insensitive)
.decl Stats_InsensValueArrayCount(?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)


.decl Stats_InsensBaseValueArrayIndexPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?basevalue:Value)


// Count how many objects, an array points to (basevalue context-insensitive)
.decl Stats_InsensBaseValueArrayCount(?basevalue:Value, ?n:number)


// Count how many objects, an array points to (value+basevalue context-insensitive)
.decl Stats_InsensArrayCount(?basevalue:Value, ?n:number)


// NOTE: The same applies for Stats_InsensValueArrayCount
.decl Stats_Arrays(?n:number)


// NOTE: The same applies for Stats_InsensBaseValueArrayCount
.decl Stats_InsensArrays(?n:number)





                                                                 

// Count how many objects, a field points to (context-sensitive)
.decl Stats_FieldCount(?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)


.decl Stats_InsensValueInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)


// Count how many objects, a field points to (value context-insensitive)
.decl Stats_InsensValueFieldCount(?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)


.decl Stats_InsensBaseValueInstanceFieldPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basevalue:Value)


// Count how many objects, a field points to (basevalue context-insensitive)
.decl Stats_InsensBaseValueFieldCount(?sig:Field, ?basevalue:Value, ?n:number)


// Count how many objects, a field points to (value+basevalue context-insensitive)
.decl Stats_InsensFieldCount(?sig:Field, ?basevalue:Value, ?n:number)


// NOTE: The same applies for Stats_InsensValueFieldCount
.decl Stats_Fields(?n:number)


// NOTE: The same applies for Stats_InsensBaseFieldCount
.decl Stats_InsensFields(?n:number)


//.decl Stats_InsensInstanceFieldPointsToNonThrowable(?value:Value, ?sig:Field, ?basevalue:Value)
//
//
//.decl Stats_InstanceFieldPointsToNonThrowable(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)
//
//
//.decl Stats_InsensInstanceFieldPointsToNonThrowable2(?value:Value, ?sig:Field, ?basevalue:Value)
//
//
//.decl Stats_InstanceFieldPointsToNonThrowable2(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)
//
//
//.decl Stats_InsensInstanceFieldPointsToNonThrowable3(?value:Value, ?sig:Field, ?basevalue:Value)
//
//
//.decl Stats_InstanceFieldPointsToNonThrowable3(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)
//




                                                     

// Count how many contexts, a reachable method appears with
.decl Stats_MethodContextCount(?method:Method, ?n:number)


.decl Stats_Methods(?n:number)


.decl Method_NumberOfContexts(?method:Method, ?n:number)


.decl Method_VPTCountPerMethodVariable(?method:Method, ?var:Var, ?n:number)


.decl Method_TotalVPT(?method:Method, Y:number)


//// Count how many local vars, a reachable method has
//.decl Stats_InsensVarInReachableMethod(?var:Var, ?method:Method)
//
//
//.decl Stats_VarInReachableMethod(?var:Var, ?ctx:mainAnalysis.configuration.Context, ?method:Method)
//
//
//.decl Stats_MethodVarCount(?ctx:mainAnalysis.configuration.Context, ?method:Method, ?n:number)
//
//
//.decl Stats_InsensMethodVarCount(?method:Method, ?n:number)
//
//
//.decl Stats_MethodsWithVars(?n:number)
//
//
//.decl Stats_InsensMethodsWithVars(?n:number)
//
//
//.decl Stats_ReachableNativeMethod(?method:Method)
//


                                                                 

//.decl Stats_Dominance_VarPointsTo_Var(?var:Var, ?count:number)
//
//
//.decl Stats_Dominance_VarPointsTo_AllocationSite(?alloc:Value, ?count:number)
//
//
//.decl Stats_Dominance_VarPointsTo_Object(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?count:number)
//
//
//// Intermediate predicate
//.decl Dominance_VarPointsTo_Method_Var(?method:Method, ?var:Var, ?count:number)
//
//.decl Stats_Dominance_VarPointsTo_Method(?method:Method ?count:number)
//
//
//.decl Stats_Dominance_InstanceFieldPointsTo_Signature(?sig:Field, ?count:number)
//
//
//.decl Stats_Dominance_InstanceFieldPointsTo_BaseAllocationSite(?alloc:Value, ?count:number)
//
//
//.decl Stats_Dominance_InstanceFieldPointsTo_BaseObject(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?count:number)
//
//
//.decl Stats_Dominance_InstanceFieldPointsTo_IdAllocationSite(?alloc:Value, ?count:number)
//
//
//.decl Stats_Dominance_InstanceFieldPointsTo_IdObject(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?count:number)
//


                                                     

//.decl Stats_InsensCallGraphEdgesFromSize(?from:MethodInvocation, ?size:number)
//
//
//.decl Stats_InsensCallGraphEdgesToSize(?to:Method, ?size:number)
//


                                                     



.decl Stats_InsensValueThrowPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?method:Method)


//.decl Stats_InsensValueThrowPointsToSize(?ctx:mainAnalysis.configuration.Context, ?method:Method, ?size:number)
//

.decl Stats_InsensThrowPointsTo(?value:Value, ?method:Method)


//.decl Stats_InsensThrowPointsToSize(?method:Method, ?size:number)
//



//.decl Stats_ReachableExceptionHandler(?handler:ExceptionHandler)
//
//
//.decl Stats_ReachableThrow(?ref:Throw_Insn)
//

//// Count how many objects, a method may throw (context-sensitive)
//.decl Stats_ThrowsPerMethodCount(?ctx:mainAnalysis.configuration.Context, ?method:Method, ?n:number)
//
//
//// Count how many objects, a method may throw (value context-insensitive)
//.decl Stats_InsensValueThrowsPerMethodCount(?ctx:mainAnalysis.configuration.Context, ?method:Method, ?n:number)
//
//
//.decl Stats_InsensMethodThrowPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?method:Method)
//
//
//// Count how many objects, a method may throw (method context-insensitive)
//.decl Stats_InsensMethodThrowsPerMethodCount(?method:Method, ?n:number)
//
//
//// Count how many objects, a method may throw (value+method context-insensitive)
//.decl Stats_InsensThrowsPerMethodCount(?method:Method, ?n:number)
//
//
//// NOTE: The same applies for Stats_InsensValueThrowsPerMethodCount
//.decl Stats_ThrowMethods(?n:number)
//
//
//// NOTE: The same applies for Stats_InsensMethodThrowsPerMethodCount
//.decl Stats_InsensThrowMethods(?n:number)
//



                                                                 

//Stats_ReflectiveHeap(?heap) :-
//  ReflectiveHeapAllocation(_, _, ?heap).

Stats_ApplicationHeap(?heap) :-
  ApplicationMethod(?method),
  mainAnalysis.AssignNormalHeapAllocation(?heap, _, ?method).

Stats_ApplicationHeap(?heap) :-
  ApplicationMethod(?method),
  mainAnalysis.AssignContextInsensitiveHeapAllocation(?heap, _, ?method).

//Stats_ApplicationHeap(?heap) :-
//  ApplicationMethod(?method),
//  Instruction_Method(?instr, ?method),
//  ReflectiveHeapAllocation(?instr, _, ?heap).

//Stats_ReachableValue(?value),
//Stats_ReachableValueWithContext(?hctx, ?value) :-
//   VarPointsTo(?hctx, ?value, _, _).
//
//Stats_InsensValuesOnMethodBoundaries(?value, ?var),
//Stats_ValuesOnMethodBoundaries(?hctx, ?value, ?ctx, ?var) :-
//  (FormalParam(_, ?method, ?var) ;
//   ReturnVar(?var, ?method)),
//  Var_DeclaringMethod(?var, ?method),
//  VarPointsTo(?hctx, ?value, ?ctx, ?var).
//
//Stats_ThrowablesInMethod(?valuetype, ?method),
//Stats_InsensThrowableValuesOnMethodBoundaries(?value, ?var),
//Stats_ThrowableValuesOnMethodBoundaries(?hctx, ?value, ?ctx, ?var) :-
//  SupertypeOf("java.lang.Throwable", ?valuetype),
//  Value_Type(?value, ?valuetype),
//  Stats_ValuesOnMethodBoundaries(?hctx, ?value, ?ctx, ?var),
//  Var_DeclaringMethod(?var, ?method).
//
//Stats_InsensAppThrowableValuesOnMethodBoundaries(?value, ?var),
//Stats_AppThrowableValuesOnMethodBoundaries(?hctx, ?value, ?ctx, ?var) :-
//  ApplicationClass(?valuetype),
//  Value_Type(?value, ?valuetype),
//  Stats_ThrowableValuesOnMethodBoundaries(?hctx, ?value, ?ctx, ?var).
//
//Stats_ThrowablesInAppMethod(?valuetype, ?method),
//Stats_InsensAppMethThrowableValuesOnMethodBoundaries(?value, ?var),
//Stats_AppMethThrowableValuesOnMethodBoundaries(?hctx, ?value, ?ctx, ?var) :-
//  ApplicationMethod(?method),
//  Var_DeclaringMethod(?var, ?method),
//  Stats_ThrowableValuesOnMethodBoundaries(?hctx, ?value, ?ctx, ?var),
//  Value_Type(?value, ?valuetype).


                                                                 

// Count how many objects, a var points to (context-sensitive)
Stats_VarCount(?ctx, ?var, ?n) :-
 mainAnalysis.VarPointsTo(_, _, ?ctx, ?var),
 ?n = count : mainAnalysis.VarPointsTo(_, _, ?ctx, ?var).

// Count how many objects, a var points to (value context-insensitive)
Stats_InsensValueVarPointsTo(?value, ?ctx, ?var) :-
  mainAnalysis.VarPointsTo(_, ?value, ?ctx, ?var).

Stats_InsensValueVarCount(?ctx, ?var, ?n) :-
  Stats_InsensValueVarPointsTo(_, ?ctx, ?var),
  ?n = count : Stats_InsensValueVarPointsTo(_, ?ctx, ?var).

// Count how many objects, a var points to (base context-insensitive)
Stats_InsensBaseVarPointsTo(?hctx, ?value, ?var) :-
  mainAnalysis.VarPointsTo(?hctx, ?value, _, ?var).

Stats_InsensBaseVarCount(?var, ?n) :-
  Stats_InsensBaseVarPointsTo(_, _, ?var),
  ?n = count : Stats_InsensBaseVarPointsTo(_, _, ?var).

// Count how many objects, a var points to (value+base context-insensitive)
Stats_InsensVarCount(?var, ?n) :-
  Stats_Simple_InsensVarPointsTo(_, ?var),
  ?n = count : Stats_Simple_InsensVarPointsTo(_, ?var).

// NOTE: The same applies for Stats_InsensValueVarCount
Stats_Vars(?n) :-
  ?n = count : Stats_VarCount(_, _, _).

// NOTE: The same applies for Stats_InsensBaseVarCount
Stats_InsensVars(?n) :-
  ?n = count : Stats_InsensVarCount(_, _).

//Stats_InsensVarPointsToNonThrowable(?value, ?var),
//Stats_VarPointsToNonThrowable(?hctx, ?value, ?ctx, ?var) :-
//  Value_Type(?value, ?valuetype),
//  VarPointsTo(?hctx, ?value, ?ctx, ?var),
//  !SupertypeOf("java.lang.Throwable", ?valuetype).


                                                                 

// Count how many objects, an array points to (context-sensitive)
Stats_ArrayCount(?basehctx, ?basevalue, ?n) :-
  mainAnalysis.ArrayIndexPointsTo(_, _, ?basehctx, ?basevalue),
  ?n = count : mainAnalysis.ArrayIndexPointsTo(_, _, ?basehctx, ?basevalue).

// Count how many objects, an array points to (value context-insensitive)
Stats_InsensValueArrayIndexPointsTo(?value, ?basehctx, ?basevalue) :-
  mainAnalysis.ArrayIndexPointsTo(_, ?value, ?basehctx, ?basevalue).

Stats_InsensValueArrayCount(?basehctx, ?basevalue, ?n) :-
  Stats_InsensValueArrayIndexPointsTo(_, ?basehctx, ?basevalue),
  ?n = count : Stats_InsensValueArrayIndexPointsTo(_, ?basehctx, ?basevalue).

// Count how many objects, an array points to (basevalue context-insensitive)
Stats_InsensBaseValueArrayIndexPointsTo(?hctx, ?value, ?basevalue) :-
  mainAnalysis.ArrayIndexPointsTo(?hctx, ?value, _, ?basevalue).

Stats_InsensBaseValueArrayCount(?basevalue, ?n) :-
  Stats_InsensBaseValueArrayIndexPointsTo(_, _, ?basevalue),
  ?n = count : Stats_InsensBaseValueArrayIndexPointsTo(_, _, ?basevalue).

// Count how many objects, an array points to (value+basevalue context-insensitive)
Stats_InsensArrayCount(?basevalue, ?n) :-
  Stats_Simple_InsensArrayIndexPointsTo(_, ?basevalue),
  ?n = count : Stats_Simple_InsensArrayIndexPointsTo(_, ?basevalue).

// NOTE: The same applies for Stats_InsensValueArrayCount
Stats_Arrays(?n) :-
  ?n = count : Stats_ArrayCount(_, _, _).

// NOTE: The same applies for Stats_InsensBaseValueArrayCount
Stats_InsensArrays(?n) :-
  ?n = count : Stats_InsensArrayCount(_, _).




                                                                 

// Count how many objects, a field points to (context-sensitive)
Stats_FieldCount(?sig, ?basehctx, ?basevalue, ?n) :-
  mainAnalysis.InstanceFieldPointsTo(_, _, ?sig, ?basehctx, ?basevalue),
  ?n = count : mainAnalysis.InstanceFieldPointsTo(_, _, ?sig, ?basehctx, ?basevalue).

// Count how many objects, a field points to (value context-insensitive)
Stats_InsensValueInstanceFieldPointsTo(?value, ?sig, ?basehctx, ?basevalue) :-
  mainAnalysis.InstanceFieldPointsTo(_, ?value, ?sig, ?basehctx, ?basevalue).

Stats_InsensValueFieldCount(?sig, ?basehctx, ?basevalue, ?n) :-
  Stats_InsensValueInstanceFieldPointsTo(_, ?sig, ?basehctx, ?basevalue),
  ?n = count : Stats_InsensValueInstanceFieldPointsTo(_, ?sig, ?basehctx, ?basevalue).

// Count how many objects, a field points to (basevalue context-insensitive)
Stats_InsensBaseValueInstanceFieldPointsTo(?hctx, ?value, ?sig, ?basevalue) :-
  mainAnalysis.InstanceFieldPointsTo(?hctx, ?value, ?sig, _, ?basevalue).

Stats_InsensBaseValueFieldCount(?sig, ?basevalue, ?n) :-
  Stats_InsensBaseValueInstanceFieldPointsTo(_, _, ?sig, ?basevalue),
  ?n = count : Stats_InsensBaseValueInstanceFieldPointsTo(_, _, ?sig, ?basevalue).

// Count how many objects, a field points to (value+basevalue context-insensitive)
Stats_InsensFieldCount(?sig, ?basevalue, ?n) :-
  Stats_Simple_InsensInstanceFieldPointsTo(_, ?sig, ?basevalue),
  ?n = count : Stats_Simple_InsensInstanceFieldPointsTo(_, ?sig, ?basevalue).

// NOTE: The same applies for Stats_InsensValueFieldCount
Stats_Fields(?n) :-
  ?n = count : Stats_FieldCount(_, _, _, _).

// NOTE: The same applies for Stats_InsensBaseFieldCount
Stats_InsensFields(?n) :-
  ?n = count : Stats_InsensFieldCount(_, _, _).

//Stats_InsensInstanceFieldPointsToNonThrowable(?value, ?sig, ?basevalue),
//Stats_InstanceFieldPointsToNonThrowable(?hctx, ?value, ?sig, ?basehctx, ?basevalue) :-
//  Value_Type(?value, ?valuetype),
//  InstanceFieldPointsTo(?hctx, ?value, ?sig, ?basehctx, ?basevalue),
//  !SupertypeOf("java.lang.Throwable", ?valuetype).
//
//Stats_InsensInstanceFieldPointsToNonThrowable2(?value, ?sig, ?basevalue),
//Stats_InstanceFieldPointsToNonThrowable2(?hctx, ?value, ?sig, ?basehctx, ?basevalue) :-
//  Value_Type(?basevalue, ?valuetype),
//  InstanceFieldPointsTo(?hctx, ?value, ?sig, ?basehctx, ?basevalue),
//  !SupertypeOf("java.lang.Throwable", ?valuetype).
//
//Stats_InsensInstanceFieldPointsToNonThrowable3(?value, ?sig, ?basevalue),
//Stats_InstanceFieldPointsToNonThrowable3(?hctx, ?value, ?sig, ?basehctx, ?basevalue) :-
//  Value_Type(?basevalue, ?basevaluetype),
//  InstanceFieldPointsTo(?hctx, ?value, ?sig, ?basehctx, ?basevalue),
//  Value_Type(?value, ?valuetype),
//  !SupertypeOf("java.lang.Throwable", ?valuetype),
//  !SupertypeOf("java.lang.Throwable", ?basevaluetype).




                                                     

// Count how many contexts, a reachable method appears with
Stats_MethodContextCount(?method, ?n) :-
  mainAnalysis.ReachableContext(_, ?method),
  ?n = count : mainAnalysis.ReachableContext(_, ?method).

Stats_Methods(?n) :-
  ?n = count : mainAnalysis.Reachable(_).

Method_NumberOfContexts(?method, ?n) :-
  mainAnalysis.Reachable(?method),
  ?n =  count : {mainAnalysis.ReachableContext(_, ?method)}.

Method_VPTCountPerMethodVariable(?method, ?var, Y) :-
  Var_DeclaringMethod(?var, ?method),
  Y =  count : {mainAnalysis.VarPointsTo(_, _, _, ?var)}.

Method_TotalVPT(?method, Y) :-
  mainAnalysis.Reachable(?method),
  Y = sum ?n : {Method_VPTCountPerMethodVariable(?method, _, ?n)}.

Method_TotalVPT(?method, 0) :-
  mainAnalysis.Reachable(?method),
  !Var_DeclaringMethod(_, ?method).

//// Count how many local vars, a reachable method has
//Stats_InsensVarInReachableMethod(?var, ?method),
//Stats_VarInReachableMethod(?var, ?ctx, ?method) :-
//  ReachableContext(?ctx, ?method),
//  Var_DeclaringMethod(?var, ?method).
//
//Stats_MethodVarCount(?ctx, ?method, ?n) :-
//  Stats_VarInReachableMethod(_, ?ctx, ?method),
//  ?n = count : Stats_VarInReachableMethod(_, ?ctx, ?method).
//
//Stats_InsensMethodVarCount(?method, ?n) :-
//  Stats_InsensVarInReachableMethod(_, ?method),
//  ?n = count : Stats_InsensVarInReachableMethod(_, ?method).
//
//Stats_MethodsWithVars(?n) :-
//  ?n = count : Stats_MethodVarCount(_, _, _).
//
//Stats_InsensMethodsWithVars(?n) :-
//  ?n = count : Stats_InsensMethodVarCount(_, _).
//
//Stats_ReachableNativeMethod(?method) :-
//  Reachable(?method),
//  Method_Modifier("native", ?method).


                                                                 

//Stats_Dominance_VarPointsTo_Var(?var, ?count) :-
//  VarPointsTo(_, _, _, ?var),
//  ?count = count : VarPointsTo(_, _, _, ?var).
//
//Stats_Dominance_VarPointsTo_AllocationSite(?alloc, ?count) :-
//  VarPointsTo(_, ?alloc, _, _),
//  ?count = count : VarPointsTo(_, ?alloc, _, _).
//
//Stats_Dominance_VarPointsTo_Object(?hctx, ?value, ?count) :-
//  VarPointsTo(?hctx, ?value, _, _),
//  ?count = count : VarPointsTo(?hctx, ?value, _, _).
//
//Dominance_VarPointsTo_Method_Var(?method, ?var, ?varCount) :-
//  Reachable(?method),
//  Var_DeclaringMethod(?var, ?method)
//  Stats_Dominance_VarPointsTo_Var(?var, ?varCount).
//
//Stats_Dominance_VarPointsTo_Method(?method, ?count) :-
//  Dominanace_VarPointsTo_Method_Var(?method, _, _),
//  ?count = sum (?varCount): Dominance_VarPointsTo_Method_Var(?method, _, ?varCount).
//
//Stats_Dominance_InstanceFieldPointsTo_Signature(?sig, ?count) :-
//  InstanceFieldPointsTo(_, _, ?sig, _, _,),
//  ?count = count : InstanceFieldPointsTo(_, _, ?sig, _, _).
//
//Stats_Dominance_InstanceFieldPointsTo_BaseAllocationSite(?alloc, ?count) :-
//  InstanceFieldPointsTo(_, _, _, _, ?alloc),
//  ?count = count : InstanceFieldPointsTo(_, _, _, _, ?alloc).
//
//Stats_Dominance_InstanceFieldPointsTo_BaseObject(?hctx, ?value, ?count) :-
//  InstanceFieldPointsTo(_, _, _, ?hctx, ?value),
//  ?count = count : InstanceFieldPointsTo(_, _, _, ?hctx, ?value).
//
//Stats_Dominance_InstanceFieldPointsTo_IdAllocationSite(?alloc, ?count) :-
//  ?count = count : InstanceFieldPointsTo(_, ?alloc, _, _, _).
//
//Stats_Dominance_InstanceFieldPointsTo_IdObject(?hctx, ?value, ?count) :-
//  InstanceFieldPointsTo(?hctx, ?value, _, _, _),
//  ?count = count : InstanceFieldPointsTo(?hctx, ?value, _, _, _).


                                                     

//Stats_InsensCallGraphEdgesFromSize(?from, ?size) :-
//  Stats_Simple_InsensCallGraphEdge(?from, _),
//  ?size = count : Stats_Simple_InsensCallGraphEdge(?from, _).
//
//Stats_InsensCallGraphEdgesToSize(?to, ?size) :-
//  Stats_Simple_InsensCallGraphEdge(_, ?to),
//  ?size = count : Stats_Simple_InsensCallGraphEdge(_, ?to).


                                                     




Stats_InsensValueThrowPointsTo(?value, ?ctx, ?method) :-
  mainAnalysis.ThrowPointsTo(_, ?value, ?ctx, ?method).

//Stats_InsensValueThrowPointsToSize(?ctx, ?method, ?size) :-
//  Stats_InsensValueThrowPointsTo(_, ?ctx, ?method),
//  ?size = count : Stats_InsensValueThrowPointsTo(_, ?ctx, ?method).

Stats_InsensThrowPointsTo(?value, ?method) :-
  Stats_InsensValueThrowPointsTo(?value, _, ?method).

//Stats_InsensThrowPointsToSize(?method, ?size)
//  Stats_InsensThrowPointsTo(_, ?method),
//  ?size = count : Stats_InsensThrowPointsTo(_, ?method).



//Stats_ReachableExceptionHandler(?handler) :-
//  Reachable(?method),
//  ExceptionHandler_Method(?handler, ?method).
//
//Stats_ReachableThrow(?ref) :-
//  Reachable(?method),
//  Instruction_Method(?ref, ?method),
//  Throw_Insn(?ref).

//// Count how many objects, a method may throw (context-sensitive)
//Stats_ThrowsPerMethodCount(?ctx, ?method, ?n) :-
//  ThrowPointsTo(_, _, ?ctx, ?method),
//  ?n = count : ThrowPointsTo(_, _, ?ctx, ?method).
//
//// Count how many objects, a method may throw (value context-insensitive)
//Stats_InsensValueThrowsPerMethodCount(?ctx, ?method, ?n) :-
//  Stats_InsensValueThrowPointsTo(_, ?ctx, ?method),
//  ?n = count : Stats_InsensValueThrowPointsTo(_, ?ctx, ?method).
//
//// Count how many objects, a method may throw (method context-insensitive)
//Stats_InsensMethodThrowPointsTo(?hctx, ?value, ?method) :-
//  ThrowPointsTo(?hctx, ?value, _, ?method).
//
//Stats_InsensMethodThrowsPerMethodCount(?method, ?n) :-
//  Stats_InsensMethodThrowPointsTo(_, _, ?method),
//  ?n = count : Stats_InsensMethodThrowPointsTo(_, _, ?method).
//
//// Count how many objects, a method may throw (value+method context-insensitive)
//Stats_InsensThrowsPerMethodCount(?method, ?n) :-
//  Stats_InsensThrowPointsTo(_, ?method),
//  ?n = count : Stats_InsensThrowPointsTo(_, ?method).
//
//// NOTE: The same applies for Stats_InsensValueThrowsPerMethodCount
//Stats_ThrowMethods(?n) :-
//  ?n = count : Stats_ThrowsPerMethodCount(_, _, _).
//
//// NOTE: The same applies for Stats_InsensMethodThrowsPerMethodCount
//Stats_InsensThrowMethods(?n) :-
//  ?n = count : Stats_InsensThrowsPerMethodCount(_, _).


                                                     

//VarsRank(?r), VarsRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`VarsRank] = 8388608.
//VarsRankNr(?r) <- uint32_range(1, Stats_Vars[], 1, ?r).
//+VarsRank(?r) <- +VarsRankNr(?r).
//
//InsensVarsRank(?r), InsensVarsRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`InsensVarsRank] = 8388608.
//InsensVarsRankNr(?r) <- uint32_range(1, Stats_InsensVars[], 1, ?r).
//+InsensVarsRank(?r) <- +InsensVarsRankNr(?r).
//
//ArraysRank(?r), ArraysRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`ArraysRank] = 8388608.
//ArraysRankNr(?r) <- uint32_range(1, Stats_Arrays[], 1, ?r).
//+ArraysRank(?r) <- +ArraysRankNr(?r).
//
//InsensArraysRank(?r), InsensArraysRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`InsensArraysRank] = 8388608.
//InsensArraysRankNr(?r) <- uint32_range(1, Stats_InsensArrays[], 1, ?r).
//+InsensArraysRank(?r) <- +InsensArraysRankNr(?r).
//
//FieldsRank(?r), FieldsRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`FieldsRank] = 8388608.
//FieldsRankNr(?r) <- uint32_range(1, Stats_Fields[], 1, ?r).
//+FieldsRank(?r) <- +FieldsRankNr(?r).
//
//InsensFieldsRank(?r), InsensFieldsRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`InsensFieldsRank] = 8388608.
//InsensFieldsRankNr(?r) <- uint32_range(1, Stats_InsensFields[], 1, ?r).
//+InsensFieldsRank(?r) <- +InsensFieldsRankNr(?r).
//
//ThrowsRank(?r), ThrowsRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`ThrowsRank] = 8388608.
//ThrowsRankNr(?r) <- uint32_range(1, Stats_ThrowMethods[], 1, ?r).
//+ThrowsRank(?r) <- +ThrowsRankNr(?r).
//
//MethodsRank(?r), MethodsRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`MethodsRank] = 8388608.
//MethodsRankNr(?r) <- uint32_range(1, Stats_Methods[], 1, ?r).
//+MethodsRank(?r) <- +MethodsRankNr(?r).
//
//MethodVarsRank(?r), MethodVarsRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`MethodVarsRank] = 8388608.
//MethodVarsRankNr(?r) <- uint32_range(1, Stats_MethodsWithVars[], 1, ?r).
//+MethodVarsRank(?r) <- +MethodVarsRankNr(?r).
//
//InsensMethodVarsRank(?r), InsensMethodVarsRank_Id(?r_?n) -> uint[32](?n).
//lang_physical_capacity[`InsensMethodVarsRank] = 8388608.
//InsensMethodVarsRankNr(?r) <- uint32_range(1, Stats_InsensMethodsWithVars[], 1, ?r).
//+InsensMethodVarsRank(?r) <- +InsensMethodVarsRankNr(?r).


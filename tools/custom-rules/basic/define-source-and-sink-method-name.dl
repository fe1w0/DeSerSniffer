// Sink Method
.decl DefineSinkMethod(method: symbol)

DefineSinkMethod("<java.lang.Runtime: java.lang.Process exec(java.lang.String)>").
DefineSinkMethod("<java.lang.System: void load(java.lang.String)>").
DefineSinkMethod("<java.lang.System: void loadLibrary(java.lang.String)>").
DefineSinkMethod("<java.lang.Runtime: java.lang.Process exec(java.lang.String[],java.lang.String[])>").
DefineSinkMethod("<java.lang.ClassLoader: java.lang.Class loadClass(java.lang.String)>").
DefineSinkMethod("<java.lang.ProcessBuilder: java.lang.Process start()>").
DefineSinkMethod("<java.io.FileOutputStream: void write(byte[])>").
DefineSinkMethod("<java.io.FileInputStream: int read(byte[])>").
DefineSinkMethod("<java.io.FileWriter: void write(java.lang.String)>").
DefineSinkMethod("<java.io.FileReader: int read(char[])>").
DefineSinkMethod("<java.net.Socket: void connect(java.net.SocketAddress)>").
DefineSinkMethod("<javax.script.ScriptEngine: java.lang.Object eval(java.lang.String)>").
DefineSinkMethod("<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>").
// DefineSinkMethod("<java.lang.Class: java.lang.Object forName(java.lang.String)>").
DefineSinkMethod("<java.lang.reflect.Constructor: java.lang.Object newInstance(java.lang.Object[])>").


/**
 * SQLI
*/
DefineSinkMethod("<java.sql.Statement: boolean execute(java.lang.String)>").

/**
 * RMI or JNDI
*/
DefineSinkMethod("<javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>").
DefineSinkMethod("<javax.naming.InitialContext: java.lang.Object lookup(javax.naming.Name)>").
DefineSinkMethod("<javax.naming.InitialContext: void rebind(java.lang.String, java.lang.Object)>").
DefineSinkMethod("<javax.naming.InitialContext: void rebind(javax.naming.Name, java.lang.Object)>").

/**
 * LeakingSinkMethodPattern
*/
LeakingSinkMethodPattern(0, "<java.io.Print.*: void println[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.sql.Statement: .* execute.*[(].*[)]>").
LeakingSinkMethodPattern(0, "<javax.servlet.http.HttpServletResponse: void sendRedirect[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.io.File: void <init>[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.io.File.*er: void <init>[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.io.File.*Stream: void <init>[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.sql.Connection: java.sql.PreparedStatement prepareStatement[(].*[)]>").
// Spring-specific sources-sinks-sanitizers
LeakingSinkMethodPattern(0, "<javax.servlet.jsp.JspWriter: void print[(].*[)]>").
LeakingSinkMethodPattern(0, "<javax.servlet.jsp.JspWriter: void println[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.io.Writer: void write[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.io.Writer: java.io.Writer append[(].*[)]>").
// "javax.servlet.http.HttpServletResponse([C)V"])" // TODO it's an interface?
LeakingSinkMethodPattern(0, "<java.io.PrintWriter: void write[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.io.PrintWriter: java.io.Writer append[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.io.PrintWriter: void print[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.io.PrintWriter: void println[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.sql.Statement: void addBatch[(]java.lang.String[)]>").
LeakingSinkMethodPattern(0, "<java.sql.Statement: int executeUpdate[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.sql.Statement: boolean execute[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.sql.Statement: java.sql.ResultSet executeQuery[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.sql.Connection: java.sql.PreparedStatement prepareStatement[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.sql.Connection: java.sql.CallableStatement prepareCall[(].*[)]>").
LeakingSinkMethodPattern(0, "<java.sql.PreparedStatement: void setString[(].*[)]>").

#ifdef ListReadObject
.decl IncludedSinkMethod(method: Method)
.printsize IncludedSinkMethod
.output IncludedSinkMethod

IncludedSinkMethod(method) :-
    DefineSinkMethod(method),
    isMethod(method).

.decl UsingSinkMethod(method: Method, invocation: MethodInvocation)
.printsize UsingSinkMethod
.output UsingSinkMethod

UsingSinkMethod(method, invocation) :-
    IncludedSinkMethod(method),
    MethodInvocation_Method(invocation, method).
#endif


#ifndef ListReadObject

.decl ListReadObjectClass(class: ClassType, label: symbol)
.input ListReadObjectClass(filename="ListReadObjectClass.csv")

DefineSourceMethod(method) :-
    method = cat(cat("<", class), ": void readObject(java.io.ObjectInputStream)>"),
    ListReadObjectClass(class, _).

.decl DefineSourceMethod(method: symbol)

// DefineSourceMethod("<sources.serialize.UnsafeSerialize: void readObject(java.io.ObjectInputStream)>").
// DefineSourceMethod("<java.util.Hashtable: void readObject(java.io.ObjectInputStream)>").
// DefineSourceMethod("<java.util.HashSet: void readObject(java.io.ObjectInputStream)>").

TaintSourceMethod(label, method) :-
	label = method,
	isMethod(method),
    DefineSourceMethod(method).
	
LeakingSinkMethod(label, method) :-
	label = method,
	isMethod(method),
	DefineSinkMethod(method).

.output LeakingSinkMethod
.output TaintSourceMethod
.output TaintedVarPointsTo

/**
 * LeakingTaintedInformation: 用于判断是否存在漏洞，即SinkMethod被污点传播的判断规则
 * 根据doop源代码分析，实际由 LeakingSinkVariable。
 * 原逻辑中分析了：
 * 1. sink 无参数，污点源为 base
 * 2. sink 有参数，且与 source 存在关系
 * 但还需要考虑，
 * 1. sink 有参数，污点源为 base
*/

LeakingSinkVariable(label, invocation, ctx, var) :-
    LeakingSinkMethod(label, tomethod),
    MethodInvocationInContextInApplication(ctx, invocation, tomethod),
    MethodInvocation_Base(invocation, var).

.decl ReachableSinks(invocation:MethodInvocation)

// ReachableTaintedSinks Sinks 中哪些变量是可被污染的
.decl ReachableTaintedSinks(invocation:MethodInvocation, param:Var)
.decl SinkVariable(param:Var)

ReachableSinks(invocation) :-
    LeakingTaintedInformation(_, _, _, invocation, _).

ReachableTaintedSinks(invocation, actual) :-
    ReachableSinks(invocation),
    ActualParam(_, invocation, actual), // FIXME set index in sink
    mainAnalysis.VarPointsTo(_, value, _, actual),
    MockObject(value, _).

ReachableTaintedSinks(invocation, actual) :-
    ReachableSinks(invocation),
    // actual 为 base
    actual = varBase,
    MethodInvocation_Base(invocation, varBase),
    mainAnalysis.VarPointsTo(_, _, _, varBase).

SinkVariable(v) :-
   ReachableTaintedSinks(_, v).

// 污点分析结果
.output SinkVariable
.output ReachableSinks
.output ReachableTaintedSinks

#endif
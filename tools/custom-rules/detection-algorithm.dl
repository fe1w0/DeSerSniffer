// 对于 反序列化 漏洞检测来说，
// 需要考虑到子类的函数调用。
// 但原 doop 中的 污点分析中

// 首先，ContextRequest 是缺少的
// 存在 ContextRequest，才可以分析 generalization-call-graph

.decl fromSourceCallGraph(?fromMethod: Method, ?toMethod: Method)
.decl isMethodInSourceCallGraph(?method: Method)
.decl EndMethodInTransfer(method: Method)

// EndMethodInTransfer("<java.lang.Class: java.lang.Class forName(java.lang.String)>").
// EndMethodInTransfer("<java.lang.Throwable: void printStackTrace()>").
// EndMethodInTransfer("<java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])>").
// EndMethodInTransfer("<java.lang.Class: java.lang.Object newInstance()>").
// EndMethodInTransfer("<java.io.ObjectInputStream: void defaultReadObject()>").

// #define StopMethodInTransfer "java[.].*"

EndMethodInTransfer(method) :-
    match("<java[.].*", method),
    isMethod(method).

// 必须要递归了
// 从 source 的 caller 开始
// 不知道为什么 ApplicationClass
// ApplicationClass(?class),
// ApplicationMethod(?fromMethod),
fromSourceCallGraph("<Start Method>", ?fromMethod) :-
    // (
    //     Instruction_Method(?invocation, ?fromMethod);
    //     // 需要考虑到 mock-invo 这类问题
    //     MockInvocationForEntryPoint(_, ?fromMethod, ?invocation)
    // ),
    // sourceMethod
    ?fromMethod = ?sourceMethod,
    TaintSourceMethod(_, ?sourceMethod),
    // Method_DeclaringType(?fromMethod, ?class),
    MethodInvocationInContext(_, ?invocation, ?sourceMethod),
    mainAnalysis.Reachable(?fromMethod).

// 开始递归
fromSourceCallGraph(?fromMethod, ?toMethod) :-
    fromSourceCallGraph(_, ?fromMethod),
    ?fromMethod != ?toMethod,
    !EndMethodInTransfer(?fromMethod),
    mainAnalysis.AnyCallGraphEdge(?invocation, ?toMethod),
    (
      Instruction_Method(?invocation, ?fromMethod);
      MockInvocationForEntryPoint(_, ?fromMethod, ?invocation)
    ).

isMethodInSourceCallGraph(?toMethod) :-
    fromSourceCallGraph(_, ?toMethod).

isStaticMethodInvocation_Insn(?instruction) :-
    _StaticMethodInvocation(?instruction, _, _, ?method),
    isMethodInSourceCallGraph(?method).

isSpecialMethodInvocation_Insn(?instruction),
SpecialMethodInvocation_Base(?instruction, ?base) :-
    _SpecialMethodInvocation(?instruction, _, _, ?base, ?method),
    isMethodInSourceCallGraph(?method).

isVirtualMethodInvocation_Insn(?instruction),
VirtualMethodInvocation_Base(?instruction, ?base) :-
    _VirtualMethodInvocation(?instruction, _, _, ?base, ?method),
    isMethodInSourceCallGraph(?method).

// subMethod take from souffle-logic/addons/server-logic/queries.dl
.decl Method_Subtype(?method:Method, ?subMethod:Method)

Method_Subtype(?method, ?subMethod) :-
  Method_DeclaringType(?method, ?type),
  Method_SimpleName(?method, ?name),
  Method_Descriptor(?method, ?desc),
  ?method != ?subMethod,
  ?name != "<clinit>",
  ?name != "<init>",
  basic.SubtypeOfDifferent(?subType, ?type),
  // _Valid_Interesting_Type(?type),
  // _Valid_Interesting_Type(?subType),
  Method_DeclaringType(?subMethod, ?subType),
  Method_SimpleName(?subMethod, ?name),
  Method_Descriptor(?subMethod, ?desc).

.decl Middle_ContextRequest(?ctx:mainAnalysis.configuration.Context, ?hctx:mainAnalysis.configuration.HContext, ?invo:MethodInvocation, ?value:Value, ?method:Method, ?createCGE:number)

Middle_ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?subMethod, 1) :-
    mainAnalysis.OptVirtualMethodInvocationBase(?invocation, ?base),
    mainAnalysis.VarPointsTo(?hctx, ?value, ?callerCtx, ?base),
    mainAnalysis.Value_Type(?value, ?valuetype),
    // constructer 需要的是 subMethod
    basic.ResolveInvocation(?valuetype, ?invocation, ?method),
    basic.ResolveInvocation(?subValuetype, ?subInvocation, ?subMethod),
    Method_Subtype(?method, ?subMethod),
    // fromSourceCallGraph(_, ?method).
    isMethodInSourceCallGraph(?method).
// .limitsize Middle_ContextRequest(n=20)

// BUG#1
mainAnalysis.configuration.ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?subMethod, 1) :-
    Middle_ContextRequest(?callerCtx, ?hctx, ?invocation, ?value, ?subMethod, 1).

// 有点小吃惊，上面的代码居然能跑，我还有点疑惑🤔️
// 甚至可以直接影响到 Taint 指针部分

// 补充 LeakingTaintedInformation
// 主要针对以下特殊的潜在漏洞
// 0 methodCallsink() 无函数参数，且污点源为 base(this)
// 1. sink 无参数
// 2. sink 中有参数，且与 source 存在关系
// 3. sink 中有参数，都与 source 无关系

// LeakingTaintedInformation(?sourceLabel, ?destLabel, ?ctx, ?invocation, ?source) :-
//   SourceFromTaintedValue(?value, ?source),
//   LabelFromSource(?source, ?sourceLabel),
//   TaintedVarPointsTo(?value, ?ctx, ?var),
//   LeakingSinkVariable(?destLabel, ?invocation, ?ctx, ?var).

// 宽泛定义
LeakingTaintedInformation(?sourceLabel, ?destLabel, ?ctx, ?invocation, ?source) :-
    // 对于上面的特殊 Sink, 判断当前函数的 base 的 caller 中的 this 是否被污染
    SourceFromTaintedValue(?value, ?source),
    LabelFromSource(?source, ?sourceLabel),
    TaintedVarPointsTo(?value, ?ctx, ?var),
    // ?var 为 caller 的 this
    ThisVar(?inMethod, ?var),
    Instruction_Method(?invocation, ?inMethod),
    MethodInvocation_Base(?invocation, ?varBase),
    // ?varBase 为 caller 的 某个 callee 的 base/receiver
    LeakingSinkVariable(?destLabel, ?invocation, ?ctx, ?varBase).

// 考虑 isOpaqueMethod 导致的屏蔽问题

isStaticMethodInvocation_Insn(?instruction) :-
    _StaticMethodInvocation(?instruction, _, ?signature, _),
    (!isOpaqueMethod(?signature);
    isMethodInSourceCallGraph(?signature)
    ).

isSpecialMethodInvocation_Insn(?instruction),
SpecialMethodInvocation_Base(?instruction, ?base) :-
    _SpecialMethodInvocation(?instruction, _, ?signature, ?base, _),
    (!isOpaqueMethod(?signature);
    isMethodInSourceCallGraph(?signature)
    ).

isVirtualMethodInvocation_Insn(?instruction),
VirtualMethodInvocation_Base(?instruction, ?base) :-
    _VirtualMethodInvocation(?instruction, _, ?signature, ?base, _),
    (!isOpaqueMethod(?signature);
    isMethodInSourceCallGraph(?signature)
    ).

// 添加 SerHybrid 中的部分逻辑
// heap_flowl.dl
#include "SerHybrid/heap_flow.dl"

// 修改 SerHybrid 中的 taint.dl

.decl ReachableSinks(?invocation:MethodInvocation)
.decl ReachableTaintedSinks(?invocation:MethodInvocation, ?param:Var)
.decl SinkVariable(?param:Var)

ReachableSinks(?invocation) :-
    LeakingTaintedInformation(_, _, _, ?invocation, _).

ReachableTaintedSinks(?invocation, ?actual) :-
    ReachableSinks(?invocation),
    ActualParam(_, ?invocation, ?actual), // FIXME set index in sink
    mainAnalysis.VarPointsTo(_, ?value, _, ?actual),
    MockObject(?value, _).

ReachableTaintedSinks(?invocation, ?actual) :-
    ReachableSinks(?invocation),
    // ?actual 为 base
    ?actual = ?varBase,
    MethodInvocation_Base(?invocation, ?varBase),
    mainAnalysis.VarPointsTo(_, _, _, ?varBase).

SinkVariable(?v) :-
   ReachableTaintedSinks(_, ?v).
//-----------------------------------------------------------------------------
// 分析出 属性树
//-----------------------------------------------------------------------------

/**
 * 1.3.0 版中添加的属性树导出功能，需要先提供
 * 属于离线查询，因Call-Graph存在不唯一性和不稳定性，不在 Call-Graph 中直接生成属性树，
 * 而是根据 Neo4j 的最短路径检测后，对于提供的 Call-Graph 生成 Property-Tree
 * 需要注意⚠️: 1.3.0 版本中的属性树导出算法也并不是一个MUST算法，实际上还是一个May算法
 * 且需要二次离线查询。
 * 注意事项: 
 *      - Doop 中并不直接支持，列出 Super 中的所有Field
*/

.type Method = symbol

.decl SourceMethod(method: Method)

.decl SinkMethod(method: Method)

.decl CallGraph(node: Method, node_next: Method)
.input CallGraph(filename="CallGraph.csv")

/**
 * 属性树
*/
.decl PropertyTree(label: symbol, parent_object_class: symbol, field_object_class: symbol, field_name: symbol, whole_name: symbol)
.output PropertyTree

/**
 * 用于判断 Source 的 声明类 是否属于 数据类 
*/
.decl isSourceDataClass()

isSourceDataClass() :-
    SourceMethod(source_method),
    Method_DeclaringType(source_method, source_class_type),
    DataStructureClass(source_class_type).

/**
 * 当 Source 的声明类属于数据类，但不属于 DataStructureMappingClass
*/
PropertyTree(label, root_class, field_class, field_name, field_whole_name) :-
    label = "Root",
    SourceMethod(source_method),
    Method_DeclaringType(source_method, root_class),
    field_name = "value".
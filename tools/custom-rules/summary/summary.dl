/**
 * [-] Log: 2024.01.24, 1.6.0-dev 中的算法还是太慢了
 * 新算法，污点分析摘要算法，首先对每个函数进行构建污点分析摘要信息。
 * 
 * 在污点分析摘要算法中，A 算法内容如下:
 * 1. 列出所有的函数
 * 2. 计算每个函数的污点分析摘要信息
 * 2.1 对于每个函数来说，分别有两种污点源: a. 函数参数，b. 函数的对象指针 (包含对象字段)
 * 2.2 选取某个污点源，如第一个函数参数，假设第一个函数参数为污点源，计算在函数内，哪些变量被污染
 * 2.3 对于函数内变量被污染的情况下，计算 Extend_CallGraph 、Dynamic_CallGraph 和 Original_CallGraph
 * 2.4 在计算 CallGraph 的同时，也要求计算下一个函数中，哪些值会被污点传播
 * 2.5 所以，最终的值 <In_Method, Source_Variable, Source_Value, CallGraph_Label, To_Method, Tainted_Variable, Tainted_Value>
 * 3. 根据污点分析摘要信息，在确定 Source 的信息情况下，计算全局调用图
 * 
 * 评估缺陷: 精度问题会很大，但计算改为线性，基本剔除最大的循环计算
 * 精度问题具体描述：由于缺乏完整的指针分析，会导致 In_Method 产生更多不精确的 To_Method 信息
 * 尝试解决方法: 对于 Virtual Invocation 来说，函数参数有 Var-Type 信息，其中包含了相对精确的变量类型信息，将此类信息也作为 2.2 中的 污点源，但只是改变 Source_Value 类型
 * 在污点分析中，需要注意污点分析断开的问题，在反序列化中，污点分析容易存在污点断开的情况，如 A 为 Source，但在污点分析中 因为 路径中没有对 A.field 进行赋值，导致 A.field 不认为是污点源。
 * 
 * 另一个问题，过程间调用，如何污点摘要
 * 尽可能在 datalog 中实现自低向上地构建污点摘要，
 * 所以需要自低向上的方式来构建。
 * B 算法：
 * 2.2.1 构建无函数调用的污点变量传播信息
 * 2.2.2 对于 一般的静态函数调用 和 虚拟函数调用，认为采用自低向上的分析方法
 * 2.2.2 对于 Native 函数 默认认为是 参数 传播到 base 或 ret
 * 2.2.3 对于 初始化函数 init 函数，认为是 参数 传播到 base
 * 2.2.4 对于 clinit 函数, Todo
 * 2.2.5 对于 没有生成 facts 的 函数 PhantomMethod, 则采用一般的 method-summary 算法
*/

/**
 * 目标:
 *  1. 列出所有的函数
 * 实现:
*/
.decl TargetMethod(method: Method)
.output TargetMethod(filename="TargetMethod.facts")
.printsize TargetMethod

TargetMethod(method) :-
	isMethod(method).

/**
 * 目标:
 *  2.1 对于每个函数来说，分别有两种污点源: a. 函数形式参数，b. 函数的对象指针 (包含对象字段)
 * 实现:
*/
.decl TaintSourceVariable(variable: Var, in_method: Method)
.output TaintSourceVariable(filename="TaintSourceVariable.facts")
.printsize TaintSourceVariable

TaintSourceVariable(var, in_method) :-
	(
		FormalParam(_, in_method, var)
		;ThisVar(in_method, var),
		// 第三种，对象字段，不精确
		// Load: v = o.f
		// 参考 1-version 中 extend-readObject.dl
		(
			Method_DeclaringType(in_method, method_declaring_type),
			Field_DeclaringType(field_signature, method_declaring_type),
   			LoadInstanceField(_, field_signature, var, in_method)
		)
	),
	TargetMethod(in_method).

/**
 * 目标:
 *  2.2 选取某个污点源，如第一个函数参数，假设第一个函数参数为污点源，计算在函数内，哪些变量被污染
 *  具体算法参考 B 算法中的细节，同时参考 1.6.0-dev 中的 tools/custom-rules/analysis/method-summary.dl
 * 实现:
*/

// 2.0.0-dev 版本中直接采用 tools/custom-rules/analysis/method-summary.dl，用于验证思想


// 加载自定义宏
#include "micro.dl"

/**
 * [-] Log: 2024.01.24, 1.6.0-dev 中的算法还是太慢了
 * 新算法，污点分析摘要算法，首先对每个函数进行构建污点分析摘要信息。
 * 
 * 在污点分析摘要算法中，A 算法内容如下:
 * 1. 列出所有的函数
 * 2. 计算每个函数的污点分析摘要信息
 * 2.1 对于每个函数来说，分别有两种污点源: a. 函数参数，b. 函数的对象指针 (包含对象字段)
 * 2.2 选取某个污点源，如第一个函数参数，假设第一个函数参数为污点源，计算在函数内，哪些变量被污染
 * 2.3 对于函数内变量被污染的情况下，计算 Extend_CallGraph 、Dynamic_CallGraph 和 Original_CallGraph
 * 2.4 在计算 CallGraph 的同时，也要求计算下一个函数中，哪些值会被污点传播
 * 2.5 所以，最终的值 <In_Method, Source_Variable, Source_Value, CallGraph_Label, To_Method, Tainted_Variable, Tainted_Value>
 * 3. 根据污点分析摘要信息，在确定 Source 的信息情况下，计算全局调用图
 * 
 * 评估缺陷: 精度问题会很大，但计算改为线性，基本剔除最大的循环计算
 * 精度问题具体描述：由于缺乏完整的指针分析，会导致 In_Method 产生更多不精确的 To_Method 信息
 * 尝试解决方法: 对于 Virtual Invocation 来说，函数参数有 Var-Type 信息，其中包含了相对精确的变量类型信息，将此类信息也作为 2.2 中的 污点源，但只是改变 Source_Value 类型
 * 在污点分析中，需要注意污点分析断开的问题，在反序列化中，污点分析容易存在污点断开的情况，如 A 为 Source，但在污点分析中 因为 路径中没有对 A.field 进行赋值，导致 A.field 不认为是污点源。
 * 
 * 另一个问题，过程间调用，如何污点摘要
 * 尽可能在 datalog 中实现自低向上地构建污点摘要，
 * 所以需要自低向上的方式来构建。
 * B 算法：
 * 2.2.1 构建无函数调用的污点变量传播信息
 * 2.2.2 对于 一般的静态函数调用 和 虚拟函数调用，认为采用自低向上的分析方法
 * 2.2.2 对于 Native 函数 默认认为是 参数 传播到 base 或 ret
 * 2.2.3 对于 初始化函数 init 函数，认为是 参数 传播到 base
 * 2.2.4 对于 clinit 函数, Todo
 * 2.2.5 对于 没有生成 facts 的 函数 PhantomMethod, 则采用一般的 method-summary 算法
 [+] 2024.02.20 对于 递归函数 和 循环调用的函数，采取以下算法进行摘要计算:
 * 1. 定义 函数部分
 * 1.1. 定义 递归函数
 * 1.2. 定义 循环调用
 * 2.0 进行指针分析
 * 3.0 进行污点传播分析
*/

// -----------------------------------------------------------------------------
// Start Summary Analysis rules
// -----------------------------------------------------------------------------

// Step 1 : 列出所有的函数
#include "utils/List-Targets.dl"

// Step 2 : 计算 Bottom 中的 指针分析 和 污点分析 (摘要)
// 注意还需要考虑静态field、静态array、array设置
#include "utils/Bottom-VarPointsTo-analysis.dl"
#include "utils/Bottom-TaintTransfer-analysis.dl"

#include "utils/Node-VarPointsTo-analysis.dl"
#include "utils/Node-TaintTransfer-analysis.dl"

// 基本组件: 根据method中的传播情况，实时增量新的传播摘要信息
#include "utils/MethodSummarizer.dl"

.output SourceFromTaintedValue
.output TaintedValue
.output TaintedValueTransferred
.output VarIsTaintedFromVar

// 无法正常输出，需要先处理plan
// 在 overwrite 上进行修改
.output TaintObjTransfer
.output TaintedVarPointsTo

// -----------------------------------------------------------------------------
// End Summary Analysis rules
// -----------------------------------------------------------------------------
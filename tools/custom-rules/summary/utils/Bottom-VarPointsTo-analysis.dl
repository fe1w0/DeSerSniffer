// -----------------------------------------------------------------------------
// Start bottom - VarPointsTo analysis rules
// -----------------------------------------------------------------------------

/**
 * Mock VarPointsTo & Tainted Value :-
 * - 函数形式参数
 * > 在doop中设计的函数形式参数，为 cat("<mock value for forced-reachable parameter ", cat(?class, ">")).
 * > 无法描述是否为同一函数内
 * > 修改为 cat("<mock value for forced-reachable parameter ", cat(cat(?class, ">"), "in ", ctx)).
 * - 函数内this指针
 * > doop 中的设计为 java.util.LinkedList::MockObject
 * > 改为 cat("<mock value for this ", cat(cat(?class, ">"), "in ", ctx))
 * - 函数内为初始化的变量
 * 	- Fields
 * 	> 原本的设计为 java.util.LinkedList::MockObject
 *  > 缺乏 signature 信息 和 ctx 信息
 *  > cat(cat("<mock value for ", " signature "), cat(cat(?class, ">"), "in ", ctx))
*/

/**
 * 目标:
 *  2.1 计算 Bottom 函数的指针信息
 * 实现:
*/

/**
 * 声明 ImMethod_WithInvocation
*/
.decl ImMethod_WithInvocation(method: Method)
.printsize ImMethod_WithInvocation

ImMethod_WithInvocation(in_method) :-
	isMethodInvocation(instruction),
	Instruction_Method(instruction, in_method).

.decl ImMethod_WithoutInvocation(method: Method)
.printsize ImMethod_WithoutInvocation

ImMethod_WithoutInvocation(method):-
	isMethod(method),
	!ImMethod_WithInvocation(method).

/**
 * 声明 Bottom
*/
.decl BottomMethod(method: Method)
.output BottomMethod(filename="BottomMethod.facts")
.printsize BottomMethod

BottomMethod(in_method) :-
	ImMethod_WithoutInvocation(in_method).
	
/**
 * 通过 ForcedReachable 强制产生, 上下文为 BottomMethod 的 指针信息
 * 指针信息：包括，形式参数 和 this 指针
 * 潜在问题，field 和 数组 上的指针信息可能会丢失
*/
mainAnalysis.ForcedReachable(method) :-
	BottomMethod(method).

.decl Target_Lost_Store_Target(base: symbol, signature: symbol, in_method: symbol, to: symbol)
.output Target_Lost_Store_Target
.printsize Target_Lost_Store_Target

Target_Lost_Store_Target(base, signature, in_method, to) :-
	LoadInstanceField(base, signature, to, in_method),
	!StoreInstanceField(_, base, signature, in_method),
	BottomMethod(in_method).

/**
 * 在利用 ForcedReachable 计算函数内的指针时，需要对 this.field 进行 mock
*/
.decl Extension_Value(hctx: symbol, field_value: symbol, signature: symbol, base_value: symbol, method: Method, from_base: symbol, to: symbol)
.output Extension_Value
.printsize Extension_Value

mainAnalysis.Value_isMock(new_value), isValue(new_value), mainAnalysis.Value_Type(new_value, value_type), mainAnalysis.Value_DeclaringType(new_value, declaring_type),
Extension_Value(hctx, new_value, signature, base_value, in_method, base, to) :-
	new_value = cat(cat("<mock value for ", signature), cat(">:: ", in_method)),
	Field_Type(signature, value_type),
	Target_Lost_Store_Target(base, signature, in_method, to),
	Method_DeclaringType(in_method, declaring_type),
	mainAnalysis.VarPointsTo(hctx, base_value, in_method, base).

// mainAnalysis.InstanceFieldPointsTo(hctx, new_value, signature, hctx, base_value) :-
mainAnalysis.VarPointsTo(hctx, new_value, in_method, from),
mainAnalysis.StoreHeapInstanceField(signature, hctx, base_value, in_method, from) :-
	from = cat(cat(from_base, "."), signature),
	!mainAnalysis.Value_Null(new_value),
	Extension_Value(hctx, new_value, signature, base_value, in_method, from_base, _).
 
.output mainAnalysis.StoreHeapInstanceField
.output mainAnalysis.LoadHeapInstanceField
.output mainAnalysis.InstanceFieldPointsTo

// -----------------------------------------------------------------------------
// End bottom - VarPointsTo analysis rules
// -----------------------------------------------------------------------------
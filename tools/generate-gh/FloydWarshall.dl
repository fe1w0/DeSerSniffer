/**
 * Learning from souffle/tests/example/floydwarshall/component.inc
 * 无法实现，有问题，Node 不能直接为 String
*/

#define NIL "NIL"
#define UR  "UnReachable"
.comp FloydWarshall {
    .type sNode = symbol
    .type Node = number
    
    .decl NumNodes(n: number)

    .decl Nodes(node: Node, r_node: sNode)
    .decl TmpNodes(r_node: sNode)
    .decl SecTmpNodes(node: Node, r_node: sNode)
    
    .decl TargetNode(n: number)

    .decl RealEdge(u: sNode, v: sNode)
    .decl Edge(u: Node, v: Node)
    
    TmpNodes(r_n),
    TmpNodes(r_v) :-
        RealEdge(r_n, r_v).
    
    SecTmpNodes(autoinc(), r_n) :-
        TmpNodes(r_n). 
    
    Nodes(n_code, r_n) :-
        n_code = o_n_code + 1,
        SecTmpNodes(o_n_code, r_n).

    Nodes(0, NIL).

    TargetNode(n) :-
        Nodes(n, "<java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>").

    NumNodes(r_n) :-
        r_n = n - 1,
        n = count : {
            Nodes(_, _)     
        }.

    Edge(u, v) :-
      Nodes(u, r_u),
      Nodes(v, r_v),
      RealEdge(r_u, r_v).

    // Auxiliary relation to perform the dynamic program
    // for shortest path. 
    .decl ShortestKPath(u:Node, v:Node, k:Node, dist:number) // Shortest path from u to v in iteration k 

    // Shortest path tree's next relation  
    .decl Next(u:Node, v:Node, k:Node, succ:Node) // Succ is the next node from u to v in iteration k

    // output relations of this component
    .decl ShortestPath(i: Node, j: Node, d: number) 
    .decl ShortestPathWitness(s:Node, e:Node, witness:Node) // Reconstructing the trace s -> e with witness

    
  // Base cases 

  // set self-loops to zero distance 
  ShortestKPath(1, 1, 0, 0). 
  Next(1,1,0, 1).
  ShortestKPath(i+1, i+1, 0, 0),
  Next(i+1, i+1, 0, i+1) :-
    ShortestKPath(i,i,0,0),
    NumNodes(n),
    i < n.
  // set Edges in the graph to unit distance
  ShortestKPath(i, j, 0, 1),
  Next(i,j,0, j) :- 
   Edge(i, j).
  // set remaining connections to n+1 distance, 
  // (repsenting that they are too expensive 
  // to traverse). 
  ShortestKPath(i+1, j, 0, n+1),
  Next(i+1, j, 0, -1) :- 
    ShortestKPath(i, j, _, _),
    !Edge(i+1,j),  
    i+1 != j,
    NumNodes(n),
    i < n. 

  ShortestKPath(i, j+1, 0, n+1),
  Next(i, j+1, 0, -1) :- 
    ShortestKPath(i, j, _, _),  
    !Edge(i, j+1),
    i != j+1,
    NumNodes(n),
    j < n. 

  // inductive case 

  // Shortest path via k is longer
  ShortestKPath(i, j, k+1, d),
  Next(i,j, k+1, succ):- 
   ShortestKPath(i, j, k, d),
   ShortestKPath(i, k+1, k, d1),
   ShortestKPath(k+1, j, k, d2),
   Next(i, j, k, succ),
   d <= d1 + d2,
   NumNodes(n),
   k < n.

  // Shortest path via k is shorter
   ShortestKPath(i, j, k+1, d1+d2),
   Next(i, j, k+1, succ) :-
    ShortestKPath(i, j, k, d),
    ShortestKPath(i, k+1, k, d1),
    ShortestKPath(k+1, j, k, d2),
    Next(i, k+1, k, succ),
    d > d1 + d2,
    NumNodes(n),
    k < n.

  // Populate shortest-path relation 
  ShortestPath(i, j, d):-
    ShortestKPath(i, j, n, d),
    d != n + 1, 
    NumNodes(n).

  // Compute witness for a shortest-path

  // base case
  ShortestPathWitness(i, j, i) :-
   Next(i, j, n, _),
   ShortestKPath(i, j, n, d),
   d != n + 1, 
   NumNodes(n). 

  // inductive case
  ShortestPathWitness(i, j, succ) :-
   ShortestPathWitness(i, j, u),
   Next(u, j, n, succ),
   NumNodes(n).  
}

.init analysis = FloydWarshall

.input analysis.RealEdge(filename="links.facts")

.output analysis.Nodes
.output analysis.TargetNode
.output analysis.ShortestKPath
.limitsize analysis.ShortestKPath
.output analysis.Edge